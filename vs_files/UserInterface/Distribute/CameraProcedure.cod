; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	D:\Metin2\Metin2\client_source_clean\client_source_clean\source\UserInterface\CameraProcedure.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_R2?$RangeTester@UCameraCollisionChecker@@@@8	; RangeTester<CameraCollisionChecker>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$RangeTester@UCameraCollisionChecker@@@@8 ; RangeTester<CameraCollisionChecker>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3?$RangeTester@UCameraCollisionChecker@@@@8	; RangeTester<CameraCollisionChecker>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AU?$RangeTester@UCameraCollisionChecker@@@@@8 ; RangeTester<CameraCollisionChecker> `RTTI Type Descriptor'
PUBLIC	??_R4?$RangeTester@UCameraCollisionChecker@@@@6B@ ; RangeTester<CameraCollisionChecker>::`RTTI Complete Object Locator'
PUBLIC	??_7?$RangeTester@UCameraCollisionChecker@@@@6B@ ; RangeTester<CameraCollisionChecker>::`vftable'
PUBLIC	??_R0?AVSpherePackCallback@@@8			; SpherePackCallback `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@SpherePackCallback@@8		; SpherePackCallback::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R2SpherePackCallback@@8			; SpherePackCallback::`RTTI Base Class Array'
PUBLIC	??_R3SpherePackCallback@@8			; SpherePackCallback::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4SpherePackCallback@@6B@			; SpherePackCallback::`RTTI Complete Object Locator'
PUBLIC	??_7SpherePackCallback@@6B@			; SpherePackCallback::`vftable'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A ; CSingleton<CPythonBackground>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCCullingManager@@@@0PAVCCullingManager@@A ; CSingleton<CCullingManager>::ms_singleton
PUBLIC	?CAMERA_MAX_DISTANCE@CCamera@@0MA		; CCamera::CAMERA_MAX_DISTANCE
PUBLIC	?CAMERA_MIN_DISTANCE@CCamera@@0MA		; CCamera::CAMERA_MIN_DISTANCE
EXTRN	?RangeTest@SpherePackFactory@@QAEXABVVector3d@@MPAVSpherePackCallback@@@Z:PROC ; SpherePackFactory::RangeTest
EXTRN	?SetTargetHeight@CCamera@@QAEXM@Z:PROC		; CCamera::SetTargetHeight
EXTRN	?SetDistance@CCamera@@QAEXM@Z:PROC		; CCamera::SetDistance
EXTRN	?fMAX@@YAMMM@Z:PROC				; fMAX
EXTRN	?RotateEyeAroundTarget@CCamera@@QAEXMM@Z:PROC	; CCamera::RotateEyeAroundTarget
EXTRN	?fMIN@@YAMMM@Z:PROC				; fMIN
EXTRN	?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ:PROC ; CGraphicObjectInstance::GetPosition
EXTRN	?CollisionDynamicSphere@CGraphicObjectInstance@@QBE_NABUCDynamicSphereInstance@@@Z:PROC ; CGraphicObjectInstance::CollisionDynamicSphere
EXTRN	?SetEye@CCamera@@QAEXABUD3DXVECTOR3@@@Z:PROC	; CCamera::SetEye
EXTRN	?GetHeight@CMapManager@@QAEMMM@Z:PROC		; CMapManager::GetHeight
EXTRN	?SetCameraState@CCamera@@QAEXW4_eCameraState_@@@Z:PROC ; CCamera::SetCameraState
;	COMDAT ?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A DD 01H DUP (?) ; CSingleton<CPythonBackground>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCCullingManager@@@@0PAVCCullingManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCCullingManager@@@@0PAVCCullingManager@@A DD 01H DUP (?) ; CSingleton<CCullingManager>::ms_singleton
_BSS	ENDS
?CAMERA_MIN_DISTANCE@CCamera@@0MA DD 043480000r	; 200	; CCamera::CAMERA_MIN_DISTANCE
_CAMERA_TARGET_FACE DD 043160000r		; 150
_CAMERA_TARGET_STANDARD DD 042c80000r		; 100
?CAMERA_MAX_DISTANCE@CCamera@@0MA DD 0451c4000r	; 2500	; CCamera::CAMERA_MAX_DISTANCE
_DATA	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_7SpherePackCallback@@6B@
CONST	SEGMENT
??_7SpherePackCallback@@6B@ DD FLAT:??_R4SpherePackCallback@@6B@ ; SpherePackCallback::`vftable'
	DD	FLAT:??_ESpherePackCallback@@UAEPAXI@Z
	DD	FLAT:?VisibilityCallback@SpherePackCallback@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z
	DD	FLAT:?RayTraceCallback@SpherePackCallback@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z
	DD	FLAT:?RangeTestCallback@SpherePackCallback@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z
	DD	FLAT:?PointTest2dCallback@SpherePackCallback@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z
CONST	ENDS
;	COMDAT ??_R4SpherePackCallback@@6B@
rdata$r	SEGMENT
??_R4SpherePackCallback@@6B@ DD 00H			; SpherePackCallback::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVSpherePackCallback@@@8
	DD	FLAT:??_R3SpherePackCallback@@8
rdata$r	ENDS
;	COMDAT ??_R3SpherePackCallback@@8
rdata$r	SEGMENT
??_R3SpherePackCallback@@8 DD 00H			; SpherePackCallback::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2SpherePackCallback@@8
rdata$r	ENDS
;	COMDAT ??_R2SpherePackCallback@@8
rdata$r	SEGMENT
??_R2SpherePackCallback@@8 DD FLAT:??_R1A@?0A@EA@SpherePackCallback@@8 ; SpherePackCallback::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@SpherePackCallback@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@SpherePackCallback@@8 DD FLAT:??_R0?AVSpherePackCallback@@@8 ; SpherePackCallback::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3SpherePackCallback@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVSpherePackCallback@@@8
data$r	SEGMENT
??_R0?AVSpherePackCallback@@@8 DD FLAT:??_7type_info@@6B@ ; SpherePackCallback `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVSpherePackCallback@@', 00H
data$r	ENDS
;	COMDAT ??_7?$RangeTester@UCameraCollisionChecker@@@@6B@
CONST	SEGMENT
??_7?$RangeTester@UCameraCollisionChecker@@@@6B@ DD FLAT:??_R4?$RangeTester@UCameraCollisionChecker@@@@6B@ ; RangeTester<CameraCollisionChecker>::`vftable'
	DD	FLAT:??_E?$RangeTester@UCameraCollisionChecker@@@@UAEPAXI@Z
	DD	FLAT:?VisibilityCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z
	DD	FLAT:?RayTraceCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z
	DD	FLAT:?RangeTestCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z
	DD	FLAT:?PointTest2dCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z
CONST	ENDS
;	COMDAT ??_R4?$RangeTester@UCameraCollisionChecker@@@@6B@
rdata$r	SEGMENT
??_R4?$RangeTester@UCameraCollisionChecker@@@@6B@ DD 00H ; RangeTester<CameraCollisionChecker>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AU?$RangeTester@UCameraCollisionChecker@@@@@8
	DD	FLAT:??_R3?$RangeTester@UCameraCollisionChecker@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AU?$RangeTester@UCameraCollisionChecker@@@@@8
data$r	SEGMENT
??_R0?AU?$RangeTester@UCameraCollisionChecker@@@@@8 DD FLAT:??_7type_info@@6B@ ; RangeTester<CameraCollisionChecker> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AU?$RangeTester@UCameraCollisionChecker@@@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$RangeTester@UCameraCollisionChecker@@@@8
rdata$r	SEGMENT
??_R3?$RangeTester@UCameraCollisionChecker@@@@8 DD 00H	; RangeTester<CameraCollisionChecker>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$RangeTester@UCameraCollisionChecker@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$RangeTester@UCameraCollisionChecker@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$RangeTester@UCameraCollisionChecker@@@@8 DD FLAT:??_R0?AU?$RangeTester@UCameraCollisionChecker@@@@@8 ; RangeTester<CameraCollisionChecker>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$RangeTester@UCameraCollisionChecker@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$RangeTester@UCameraCollisionChecker@@@@8
rdata$r	SEGMENT
??_R2?$RangeTester@UCameraCollisionChecker@@@@8 DD FLAT:??_R1A@?0A@EA@?$RangeTester@UCameraCollisionChecker@@@@8 ; RangeTester<CameraCollisionChecker>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@SpherePackCallback@@8
PUBLIC	??0D3DXVECTOR3@@QAE@XZ				; D3DXVECTOR3::D3DXVECTOR3
PUBLIC	??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z			; D3DXVECTOR3::operator-
PUBLIC	??0D3DXVECTOR3@@QAE@MMM@Z			; D3DXVECTOR3::D3DXVECTOR3
PUBLIC	??D@YA?AUD3DXVECTOR3@@MABU0@@Z			; operator*
PUBLIC	_floorf
PUBLIC	??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z			; D3DXVECTOR3::operator+
PUBLIC	?D3DXVec3Length@@YAMPBUD3DXVECTOR3@@@Z		; D3DXVec3Length
PUBLIC	_sqrtf
PUBLIC	??0Vector3d@@QAE@XZ				; Vector3d::Vector3d
PUBLIC	?Set@Vector3d@@QAEXMMM@Z			; Vector3d::Set
PUBLIC	?D3DXVec3Cross@@YAPAUD3DXVECTOR3@@PAU1@PBU1@1@Z	; D3DXVec3Cross
PUBLIC	?D3DXVec3Dot@@YAMPBUD3DXVECTOR3@@0@Z		; D3DXVec3Dot
PUBLIC	??XD3DXVECTOR3@@QAEAAU0@M@Z			; D3DXVECTOR3::operator*=
PUBLIC	?fabs@@YAMM@Z					; fabs
PUBLIC	_fabsf
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	??0SpherePackCallback@@QAE@XZ			; SpherePackCallback::SpherePackCallback
PUBLIC	?PointTest2dCallback@SpherePackCallback@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z ; SpherePackCallback::PointTest2dCallback
PUBLIC	?RangeTestCallback@SpherePackCallback@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z ; SpherePackCallback::RangeTestCallback
PUBLIC	?RayTraceCallback@SpherePackCallback@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z ; SpherePackCallback::RayTraceCallback
PUBLIC	?VisibilityCallback@SpherePackCallback@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z ; SpherePackCallback::VisibilityCallback
PUBLIC	??_GSpherePackCallback@@UAEPAXI@Z		; SpherePackCallback::`scalar deleting destructor'
PUBLIC	??1SpherePackCallback@@UAE@XZ			; SpherePackCallback::~SpherePackCallback
PUBLIC	?GetUserData@SpherePack@@QBEPAXXZ		; SpherePack::GetUserData
PUBLIC	??$construct@UD3DXVECTOR3@@U1@@?$allocator@UD3DXVECTOR3@@@std@@QAEXPAUD3DXVECTOR3@@$$QAU2@@Z ; std::allocator<D3DXVECTOR3>::construct<D3DXVECTOR3,D3DXVECTOR3>
PUBLIC	??$construct@UD3DXVECTOR3@@U1@@?$allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAXAAV?$allocator@UD3DXVECTOR3@@@1@PAUD3DXVECTOR3@@$$QAU3@@Z ; std::allocator_traits<std::allocator<D3DXVECTOR3> >::construct<D3DXVECTOR3,D3DXVECTOR3>
PUBLIC	??$forward@UD3DXVECTOR3@@@std@@YA$$QAUD3DXVECTOR3@@AAU1@@Z ; std::forward<D3DXVECTOR3>
PUBLIC	??$construct@UD3DXVECTOR3@@U1@@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXPAUD3DXVECTOR3@@$$QAU2@@Z ; std::_Wrap_alloc<std::allocator<D3DXVECTOR3> >::construct<D3DXVECTOR3,D3DXVECTOR3>
PUBLIC	??$destroy@UD3DXVECTOR3@@@?$allocator@UD3DXVECTOR3@@@std@@QAEXPAUD3DXVECTOR3@@@Z ; std::allocator<D3DXVECTOR3>::destroy<D3DXVECTOR3>
PUBLIC	??$_Uninit_move@PAUD3DXVECTOR3@@PAU1@V?$allocator@UD3DXVECTOR3@@@std@@U1@@std@@YAPAUD3DXVECTOR3@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<D3DXVECTOR3 *,D3DXVECTOR3 *,std::allocator<D3DXVECTOR3>,D3DXVECTOR3>
PUBLIC	??$_Val_type@PAUD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@PAU1@@Z ; std::_Val_type<D3DXVECTOR3 *>
PUBLIC	??$destroy@UD3DXVECTOR3@@@?$allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAXAAV?$allocator@UD3DXVECTOR3@@@1@PAUD3DXVECTOR3@@@Z ; std::allocator_traits<std::allocator<D3DXVECTOR3> >::destroy<D3DXVECTOR3>
PUBLIC	??$_Rechecked@PAUD3DXVECTOR3@@PAU1@@std@@YAAAPAUD3DXVECTOR3@@AAPAU1@PAU1@@Z ; std::_Rechecked<D3DXVECTOR3 *,D3DXVECTOR3 *>
PUBLIC	??$_Uninit_move@PAUD3DXVECTOR3@@PAU1@U?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@YAPAUD3DXVECTOR3@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@0@@Z ; std::_Uninit_move<D3DXVECTOR3 *,D3DXVECTOR3 *,std::_Wrap_alloc<std::allocator<D3DXVECTOR3> > >
PUBLIC	??$_Unchecked@PAUD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@PAU1@@Z ; std::_Unchecked<D3DXVECTOR3 *>
PUBLIC	??$destroy@UD3DXVECTOR3@@@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXPAUD3DXVECTOR3@@@Z ; std::_Wrap_alloc<std::allocator<D3DXVECTOR3> >::destroy<D3DXVECTOR3>
PUBLIC	??$construct@UD3DXVECTOR3@@AAU1@@?$allocator@UD3DXVECTOR3@@@std@@QAEXPAUD3DXVECTOR3@@AAU2@@Z ; std::allocator<D3DXVECTOR3>::construct<D3DXVECTOR3,D3DXVECTOR3 &>
PUBLIC	?construct@?$allocator@UD3DXVECTOR3@@@std@@QAEXPAUD3DXVECTOR3@@ABU3@@Z ; std::allocator<D3DXVECTOR3>::construct
PUBLIC	??$_Uninitialized_move@PAUD3DXVECTOR3@@PAU1@U?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@YAPAUD3DXVECTOR3@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@0@@Z ; std::_Uninitialized_move<D3DXVECTOR3 *,D3DXVECTOR3 *,std::_Wrap_alloc<std::allocator<D3DXVECTOR3> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@YAXPAUD3DXVECTOR3@@0AAU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<D3DXVECTOR3> > >
PUBLIC	??$_Ptr_cat@UD3DXVECTOR3@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUD3DXVECTOR3@@0@Z ; std::_Ptr_cat<D3DXVECTOR3,D3DXVECTOR3>
PUBLIC	??$construct@UD3DXVECTOR3@@ABU1@@?$allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAXAAV?$allocator@UD3DXVECTOR3@@@1@PAUD3DXVECTOR3@@ABU3@@Z ; std::allocator_traits<std::allocator<D3DXVECTOR3> >::construct<D3DXVECTOR3,D3DXVECTOR3 const &>
PUBLIC	??$forward@ABUD3DXVECTOR3@@@std@@YAABUD3DXVECTOR3@@ABU1@@Z ; std::forward<D3DXVECTOR3 const &>
PUBLIC	??$construct@UD3DXVECTOR3@@AAU1@@?$allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAXAAV?$allocator@UD3DXVECTOR3@@@1@PAUD3DXVECTOR3@@AAU3@@Z ; std::allocator_traits<std::allocator<D3DXVECTOR3> >::construct<D3DXVECTOR3,D3DXVECTOR3 &>
PUBLIC	??$forward@AAUD3DXVECTOR3@@@std@@YAAAUD3DXVECTOR3@@AAU1@@Z ; std::forward<D3DXVECTOR3 &>
PUBLIC	??_G?$RangeTester@UCameraCollisionChecker@@@@UAEPAXI@Z ; RangeTester<CameraCollisionChecker>::`scalar deleting destructor'
PUBLIC	?PointTest2dCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z ; RangeTester<CameraCollisionChecker>::PointTest2dCallback
PUBLIC	?RangeTestCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z ; RangeTester<CameraCollisionChecker>::RangeTestCallback
PUBLIC	?VisibilityCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z ; RangeTester<CameraCollisionChecker>::VisibilityCallback
PUBLIC	?RayTraceCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z ; RangeTester<CameraCollisionChecker>::RayTraceCallback
PUBLIC	??1?$RangeTester@UCameraCollisionChecker@@@@UAE@XZ ; RangeTester<CameraCollisionChecker>::~RangeTester<CameraCollisionChecker>
PUBLIC	??$_Allocate@UD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@IPAU1@@Z ; std::_Allocate<D3DXVECTOR3>
PUBLIC	??$_Umove@PAUD3DXVECTOR3@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEPAUD3DXVECTOR3@@PAU2@00@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Umove<D3DXVECTOR3 *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@YAXPAUD3DXVECTOR3@@0AAU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<D3DXVECTOR3> > >
PUBLIC	??$construct@UD3DXVECTOR3@@ABU1@@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXPAUD3DXVECTOR3@@ABU2@@Z ; std::_Wrap_alloc<std::allocator<D3DXVECTOR3> >::construct<D3DXVECTOR3,D3DXVECTOR3 const &>
PUBLIC	??$construct@UD3DXVECTOR3@@AAU1@@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXPAUD3DXVECTOR3@@AAU2@@Z ; std::_Wrap_alloc<std::allocator<D3DXVECTOR3> >::construct<D3DXVECTOR3,D3DXVECTOR3 &>
PUBLIC	??$addressof@$$CBUD3DXVECTOR3@@@std@@YAPBUD3DXVECTOR3@@ABU1@@Z ; std::addressof<D3DXVECTOR3 const >
PUBLIC	?max_size@?$allocator@UD3DXVECTOR3@@@std@@QBEIXZ ; std::allocator<D3DXVECTOR3>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAIABV?$allocator@UD3DXVECTOR3@@@2@@Z ; std::allocator_traits<std::allocator<D3DXVECTOR3> >::max_size
PUBLIC	?allocate@?$allocator@UD3DXVECTOR3@@@std@@QAEPAUD3DXVECTOR3@@I@Z ; std::allocator<D3DXVECTOR3>::allocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<D3DXVECTOR3> >::max_size
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEPAUD3DXVECTOR3@@I@Z ; std::_Wrap_alloc<std::allocator<D3DXVECTOR3> >::allocate
PUBLIC	?deallocate@?$allocator@UD3DXVECTOR3@@@std@@QAEXPAUD3DXVECTOR3@@I@Z ; std::allocator<D3DXVECTOR3>::deallocate
PUBLIC	?capacity@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QBEIXZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::capacity
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXPAUD3DXVECTOR3@@I@Z ; std::_Wrap_alloc<std::allocator<D3DXVECTOR3> >::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<D3DXVECTOR3> >::_Wrap_alloc<std::allocator<D3DXVECTOR3> >
PUBLIC	?_Xlen@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IBEXXZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Xlen
PUBLIC	?_Reallocate@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXI@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Reallocate
PUBLIC	?_Grow_to@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IBEII@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Grow_to
PUBLIC	?_Destroy@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXPAUD3DXVECTOR3@@0@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Destroy
PUBLIC	?max_size@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QBEIXZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::max_size
PUBLIC	?_Unused_capacity@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QBEIXZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Unused_capacity
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > >::_Getal
PUBLIC	??0?$allocator@UD3DXVECTOR3@@@std@@QAE@XZ	; std::allocator<D3DXVECTOR3>::allocator<D3DXVECTOR3>
PUBLIC	?_Orphan_range@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IBEXPAUD3DXVECTOR3@@0@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Orphan_range
PUBLIC	?_Tidy@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXXZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Tidy
PUBLIC	?_Reserve@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXI@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Reserve
PUBLIC	?_Inside@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IBE_NPBUD3DXVECTOR3@@@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Inside
PUBLIC	?Instance@?$CSingleton@VCPythonBackground@@@@SAAAVCPythonBackground@@XZ ; CSingleton<CPythonBackground>::Instance
PUBLIC	?push_back@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXABUD3DXVECTOR3@@@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::push_back
PUBLIC	?size@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QBEIXZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::size
PUBLIC	??1?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::~vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >
PUBLIC	?Instance@?$CSingleton@VCCullingManager@@@@SAAAVCCullingManager@@XZ ; CSingleton<CCullingManager>::Instance
PUBLIC	?Update@CCamera@@QAEXXZ				; CCamera::Update
PUBLIC	??RCameraCollisionChecker@@QAEXPAVCGraphicObjectInstance@@@Z ; CameraCollisionChecker::operator()
PUBLIC	?ProcessTerrainCollision@CCamera@@AAEXXZ	; CCamera::ProcessTerrainCollision
PUBLIC	?GetDistance@CCamera@@QBEMXZ			; CCamera::GetDistance
EXTRN	??_ESpherePackCallback@@UAEPAXI@Z:PROC		; SpherePackCallback::`vector deleting destructor'
EXTRN	??_E?$RangeTester@UCameraCollisionChecker@@@@UAEPAXI@Z:PROC ; RangeTester<CameraCollisionChecker>::`vector deleting destructor'
	ALIGN	4

_piecewise_construct DB 01H DUP (?)
_BSS	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\camera.h
;	COMDAT ?GetDistance@CCamera@@QBEMXZ
_TEXT	SEGMENT
?GetDistance@CCamera@@QBEMXZ PROC			; CCamera::GetDistance, COMDAT
; _this$ = ecx

; 186  : 		float GetDistance() const { return m_fDistance; }

  00000	d9 81 34 01 00
	00		 fld	 DWORD PTR [ecx+308]
  00006	c3		 ret	 0
?GetDistance@CCamera@@QBEMXZ ENDP			; CCamera::GetDistance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\cameraprocedure.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\cameraprocedure.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\cameraprocedure.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\cameraprocedure.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\cameraprocedure.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\cameraprocedure.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\cameraprocedure.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\cameraprocedure.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\cameraprocedure.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\cameraprocedure.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\cameraprocedure.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\cameraprocedure.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\cameraprocedure.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\cameraprocedure.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\cameraprocedure.cpp
;	COMDAT ?ProcessTerrainCollision@CCamera@@AAEXXZ
_TEXT	SEGMENT
_f$1$ = -52						; size = 4
_v3CheckVector$2$ = -52					; size = 4
tv714 = -48						; size = 8
tv708 = -48						; size = 4
tv706 = -48						; size = 8
tv700 = -48						; size = 4
_v3CheckVector$1 = -48					; size = 12
_v3CheckVector$1$ = -32					; size = 4
_v3CollisionPoint$ = -28				; size = 12
_v3NewEye$2 = -16					; size = 12
_v3NewEye$3 = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
?ProcessTerrainCollision@CCamera@@AAEXXZ PROC		; CCamera::ProcessTerrainCollision, COMDAT
; _this$ = ecx

; 14   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 c0	 and	 esp, -64		; ffffffc0H
  00006	83 ec 38	 sub	 esp, 56			; 00000038H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c4		 xor	 eax, esp
  00010	89 44 24 34	 mov	 DWORD PTR __$ArrayPad$[esp+56], eax
  00014	56		 push	 esi
  00015	8b f1		 mov	 esi, ecx

; 15   : 	CPythonBackground & rPythonBackground = CPythonBackground::Instance();
; 16   : 	D3DXVECTOR3 v3CollisionPoint;
; 17   : 
; 18   : 	if (rPythonBackground.GetPickingPointWithRayOnlyTerrain(m_kTargetToCameraBottomRay, &v3CollisionPoint))

  00017	8d 44 24 20	 lea	 eax, DWORD PTR _v3CollisionPoint$[esp+60]
  0001b	57		 push	 edi
  0001c	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A ; CSingleton<CPythonBackground>::ms_singleton
  00022	8b cf		 mov	 ecx, edi
  00024	50		 push	 eax
  00025	8d 86 00 02 00
	00		 lea	 eax, DWORD PTR [esi+512]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ?GetPickingPointWithRayOnlyTerrain@CPythonBackground@@QAE_NABVCRay@@PAUD3DXVECTOR3@@@Z ; CPythonBackground::GetPickingPointWithRayOnlyTerrain

; 19   : 	{
; 20   : 		SetCameraState(CAMERA_STATE_CANTGODOWN);

  00031	8b ce		 mov	 ecx, esi
  00033	84 c0		 test	 al, al
  00035	0f 84 02 01 00
	00		 je	 $LN6@ProcessTer
  0003b	6a 01		 push	 1
  0003d	e8 00 00 00 00	 call	 ?SetCameraState@CCamera@@QAEXW4_eCameraState_@@@Z ; CCamera::SetCameraState

; 21   : 		D3DXVECTOR3 v3CheckVector = m_v3Eye - 2.0f * m_fTerrainCollisionRadius * m_v3Up;

  00042	f3 0f 10 86 f0
	02 00 00	 movss	 xmm0, DWORD PTR [esi+752]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 701  :     return (float)floor(_X);

  0004a	83 ec 08	 sub	 esp, 8
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\cameraprocedure.cpp

; 21   : 		D3DXVECTOR3 v3CheckVector = m_v3Eye - 2.0f * m_fTerrainCollisionRadius * m_v3Up;

  0004d	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00055	f3 0f 10 56 4c	 movss	 xmm2, DWORD PTR [esi+76]
  0005a	0f 28 c8	 movaps	 xmm1, xmm0
  0005d	f3 0f 59 d0	 mulss	 xmm2, xmm0
  00061	f3 0f 59 4e 48	 mulss	 xmm1, DWORD PTR [esi+72]

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00066	f3 0f 10 46 30	 movss	 xmm0, DWORD PTR [esi+48]
  0006b	f3 0f 5c c1	 subss	 xmm0, xmm1
  0006f	f3 0f 11 44 24
	28		 movss	 DWORD PTR _v3CheckVector$1$[esp+72], xmm0
  00075	f3 0f 10 46 34	 movss	 xmm0, DWORD PTR [esi+52]
  0007a	f3 0f 5c c2	 subss	 xmm0, xmm2
  0007e	f3 0f 11 44 24
	14		 movss	 DWORD PTR _v3CheckVector$2$[esp+72], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 701  :     return (float)floor(_X);

  00084	0f 5a c0	 cvtps2pd xmm0, xmm0
  00087	f2 0f 11 44 24
	18		 movsd	 QWORD PTR tv714[esp+72], xmm0
  0008d	dd 44 24 18	 fld	 QWORD PTR tv714[esp+72]
  00091	dd 1c 24	 fstp	 QWORD PTR [esp]
  00094	e8 00 00 00 00	 call	 _floor
  00099	f3 0f 10 44 24
	28		 movss	 xmm0, DWORD PTR _v3CheckVector$1$[esp+72]
  0009f	d9 5c 24 18	 fstp	 DWORD PTR tv708[esp+72]
  000a3	d9 44 24 18	 fld	 DWORD PTR tv708[esp+72]
  000a7	0f 5a c0	 cvtps2pd xmm0, xmm0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\cameraprocedure.cpp

; 22   : 		v3CheckVector.z = rPythonBackground.GetHeight(floorf(v3CheckVector.x), floorf(v3CheckVector.y));

  000aa	51		 push	 ecx
  000ab	d9 5c 24 08	 fstp	 DWORD PTR [esp+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 701  :     return (float)floor(_X);

  000af	f2 0f 11 44 24
	1c		 movsd	 QWORD PTR tv706[esp+76], xmm0
  000b5	dd 44 24 1c	 fld	 QWORD PTR tv706[esp+76]
  000b9	dd 1c 24	 fstp	 QWORD PTR [esp]
  000bc	e8 00 00 00 00	 call	 _floor
  000c1	d9 5c 24 1c	 fstp	 DWORD PTR tv700[esp+76]
  000c5	d9 44 24 1c	 fld	 DWORD PTR tv700[esp+76]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\cameraprocedure.cpp

; 22   : 		v3CheckVector.z = rPythonBackground.GetHeight(floorf(v3CheckVector.x), floorf(v3CheckVector.y));

  000c9	83 c4 04	 add	 esp, 4
  000cc	8b cf		 mov	 ecx, edi
  000ce	d9 1c 24	 fstp	 DWORD PTR [esp]
  000d1	e8 00 00 00 00	 call	 ?GetHeight@CMapManager@@QAEMMM@Z ; CMapManager::GetHeight

; 23   : 		D3DXVECTOR3 v3NewEye = v3CheckVector + 2.0f * m_fTerrainCollisionRadius * m_v3Up;

  000d6	f3 0f 10 86 f0
	02 00 00	 movss	 xmm0, DWORD PTR [esi+752]
  000de	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  000e6	f3 0f 10 5e 50	 movss	 xmm3, DWORD PTR [esi+80]
  000eb	f3 0f 10 4e 48	 movss	 xmm1, DWORD PTR [esi+72]
  000f0	f3 0f 10 56 4c	 movss	 xmm2, DWORD PTR [esi+76]
  000f5	f3 0f 59 d8	 mulss	 xmm3, xmm0
  000f9	f3 0f 59 c8	 mulss	 xmm1, xmm0
  000fd	f3 0f 59 d0	 mulss	 xmm2, xmm0

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00101	f3 0f 58 4c 24
	20		 addss	 xmm1, DWORD PTR _v3CheckVector$1$[esp+64]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\cameraprocedure.cpp

; 22   : 		v3CheckVector.z = rPythonBackground.GetHeight(floorf(v3CheckVector.x), floorf(v3CheckVector.y));

  00107	d9 5c 24 18	 fstp	 DWORD PTR _v3CheckVector$1[esp+72]
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  0010b	f3 0f 58 5c 24
	18		 addss	 xmm3, DWORD PTR _v3CheckVector$1[esp+72]
  00111	f3 0f 58 54 24
	0c		 addss	 xmm2, DWORD PTR _v3CheckVector$2$[esp+64]

; 180  :     x = fx;

  00117	f3 0f 11 4c 24
	30		 movss	 DWORD PTR _v3NewEye$3[esp+64], xmm1
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\cameraprocedure.cpp

; 24   : 		if (v3NewEye.z > m_v3Eye.z)

  0011d	0f 2f 5e 38	 comiss	 xmm3, DWORD PTR [esi+56]
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl

; 181  :     y = fy;

  00121	f3 0f 11 54 24
	34		 movss	 DWORD PTR _v3NewEye$3[esp+68], xmm2

; 182  :     z = fz;

  00127	f3 0f 11 5c 24
	38		 movss	 DWORD PTR _v3NewEye$3[esp+72], xmm3
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\cameraprocedure.cpp

; 24   : 		if (v3NewEye.z > m_v3Eye.z)

  0012d	76 15		 jbe	 SHORT $LN4@ProcessTer

; 25   : 		{
; 26   : 			//printf("ToCameraBottom(%f, %f, %f) TCR %f, UP(%f, %f, %f), new %f > old %f", 
; 27   : 			//	v3CheckVector.x, v3CheckVector.y, v3CheckVector.z, 
; 28   : 			//	m_fTerrainCollisionRadius,
; 29   : 			//	m_v3Up.x, m_v3Up.y, m_v3Up.z,
; 30   : 			//	v3NewEye.z, m_v3Eye.z);
; 31   : 			SetEye(v3NewEye);

  0012f	8d 44 24 30	 lea	 eax, DWORD PTR _v3NewEye$3[esp+64]
  00133	8b ce		 mov	 ecx, esi
  00135	50		 push	 eax
  00136	e8 00 00 00 00	 call	 ?SetEye@CCamera@@QAEXABUD3DXVECTOR3@@@Z ; CCamera::SetEye

; 32   : 		}
; 33   : 		/*
; 34   : 		SetCameraState(CAMERA_STATE_NORMAL);
; 35   : 		D3DXVECTOR3 v3NewEye = v3CollisionPoint;
; 36   : 		SetEye(v3NewEye);
; 37   : 		*/
; 38   : 	}
; 39   : 	else

  0013b	eb 07		 jmp	 SHORT $LN4@ProcessTer
$LN6@ProcessTer:

; 40   : 		SetCameraState(CAMERA_STATE_NORMAL);

  0013d	6a 00		 push	 0
  0013f	e8 00 00 00 00	 call	 ?SetCameraState@CCamera@@QAEXW4_eCameraState_@@@Z ; CCamera::SetCameraState
$LN4@ProcessTer:

; 41   : 
; 42   : 	if (rPythonBackground.GetPickingPointWithRayOnlyTerrain(m_kCameraBottomToTerrainRay, &v3CollisionPoint))

  00144	8d 44 24 24	 lea	 eax, DWORD PTR _v3CollisionPoint$[esp+64]
  00148	8b cf		 mov	 ecx, edi
  0014a	50		 push	 eax
  0014b	8d 86 38 01 00
	00		 lea	 eax, DWORD PTR [esi+312]
  00151	50		 push	 eax
  00152	e8 00 00 00 00	 call	 ?GetPickingPointWithRayOnlyTerrain@CPythonBackground@@QAE_NABVCRay@@PAUD3DXVECTOR3@@@Z ; CPythonBackground::GetPickingPointWithRayOnlyTerrain

; 43   : 	{
; 44   : 		SetCameraState(CAMERA_STATE_CANTGODOWN);

  00157	8b ce		 mov	 ecx, esi
  00159	84 c0		 test	 al, al
  0015b	0f 84 c5 00 00
	00		 je	 $LN3@ProcessTer
  00161	6a 01		 push	 1
  00163	e8 00 00 00 00	 call	 ?SetCameraState@CCamera@@QAEXW4_eCameraState_@@@Z ; CCamera::SetCameraState
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00168	f3 0f 10 4e 30	 movss	 xmm1, DWORD PTR [esi+48]
  0016d	f3 0f 10 56 34	 movss	 xmm2, DWORD PTR [esi+52]
  00172	f3 0f 5c 54 24
	28		 subss	 xmm2, DWORD PTR _v3CollisionPoint$[esp+68]
  00178	f3 0f 5c 4c 24
	24		 subss	 xmm1, DWORD PTR _v3CollisionPoint$[esp+64]
  0017e	f3 0f 10 46 38	 movss	 xmm0, DWORD PTR [esi+56]
  00183	f3 0f 5c 44 24
	2c		 subss	 xmm0, DWORD PTR _v3CollisionPoint$[esp+72]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\cameraprocedure.cpp

; 45   : 		if (D3DXVec3Length(&(m_v3Eye - v3CollisionPoint)) < 2.0f * m_fTerrainCollisionRadius)

  00189	f3 0f 10 9e f0
	02 00 00	 movss	 xmm3, DWORD PTR [esi+752]
  00191	f3 0f 59 1d 00
	00 00 00	 mulss	 xmm3, DWORD PTR __real@40000000
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl

; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);

  00199	f3 0f 59 d2	 mulss	 xmm2, xmm2
  0019d	f3 0f 59 c9	 mulss	 xmm1, xmm1
  001a1	f3 0f 59 c0	 mulss	 xmm0, xmm0
  001a5	f3 0f 58 d1	 addss	 xmm2, xmm1
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\cameraprocedure.cpp

; 45   : 		if (D3DXVec3Length(&(m_v3Eye - v3CollisionPoint)) < 2.0f * m_fTerrainCollisionRadius)

  001a9	f3 0f 11 5c 24
	0c		 movss	 DWORD PTR _f$1$[esp+64], xmm3
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl

; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);

  001af	f3 0f 58 d0	 addss	 xmm2, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

  001b3	0f 5a c2	 cvtps2pd xmm0, xmm2
  001b6	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\cameraprocedure.cpp

; 45   : 		if (D3DXVec3Length(&(m_v3Eye - v3CollisionPoint)) < 2.0f * m_fTerrainCollisionRadius)

  001bb	f3 0f 10 5c 24
	0c		 movss	 xmm3, DWORD PTR _f$1$[esp+64]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

  001c1	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\cameraprocedure.cpp

; 45   : 		if (D3DXVec3Length(&(m_v3Eye - v3CollisionPoint)) < 2.0f * m_fTerrainCollisionRadius)

  001c5	0f 2f d8	 comiss	 xmm3, xmm0
  001c8	76 63		 jbe	 SHORT $LN1@ProcessTer
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  001ca	f3 0f 10 46 48	 movss	 xmm0, DWORD PTR [esi+72]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\cameraprocedure.cpp

; 49   : 			SetEye(v3NewEye);

  001cf	8d 44 24 30	 lea	 eax, DWORD PTR _v3NewEye$2[esp+64]
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  001d3	f3 0f 10 4e 4c	 movss	 xmm1, DWORD PTR [esi+76]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\cameraprocedure.cpp

; 49   : 			SetEye(v3NewEye);

  001d8	8b ce		 mov	 ecx, esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  001da	f3 0f 10 56 50	 movss	 xmm2, DWORD PTR [esi+80]
  001df	f3 0f 59 c3	 mulss	 xmm0, xmm3
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\cameraprocedure.cpp

; 49   : 			SetEye(v3NewEye);

  001e3	50		 push	 eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  001e4	f3 0f 59 cb	 mulss	 xmm1, xmm3

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  001e8	f3 0f 58 44 24
	28		 addss	 xmm0, DWORD PTR _v3CollisionPoint$[esp+68]

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  001ee	f3 0f 59 d3	 mulss	 xmm2, xmm3

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  001f2	f3 0f 58 4c 24
	2c		 addss	 xmm1, DWORD PTR _v3CollisionPoint$[esp+72]
  001f8	f3 0f 58 54 24
	30		 addss	 xmm2, DWORD PTR _v3CollisionPoint$[esp+76]

; 180  :     x = fx;

  001fe	f3 0f 11 44 24
	34		 movss	 DWORD PTR _v3NewEye$2[esp+68], xmm0

; 181  :     y = fy;

  00204	f3 0f 11 4c 24
	38		 movss	 DWORD PTR _v3NewEye$2[esp+72], xmm1

; 182  :     z = fz;

  0020a	f3 0f 11 54 24
	3c		 movss	 DWORD PTR _v3NewEye$2[esp+76], xmm2
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\cameraprocedure.cpp

; 49   : 			SetEye(v3NewEye);

  00210	e8 00 00 00 00	 call	 ?SetEye@CCamera@@QAEXABUD3DXVECTOR3@@@Z ; CCamera::SetEye

; 54   : /*
; 55   : 	if (rPythonBackground.GetPickingPointWithRayOnlyTerrain(m_kCameraFrontToTerrainRay, &v3CollisionPoint))
; 56   : 	{
; 57   : 		if (D3DXVec3Length(&(m_v3Eye - v3CollisionPoint)) < 4.0f * m_fTerrainCollisionRadius)
; 58   : 		{
; 59   : 			D3DXVECTOR3 v3NewEye = v3CollisionPoint - 4.0f * m_fTerrainCollisionRadius * m_v3View;
; 60   : 			//printf("CameraFrontToTerrain new %f > old %f", v3NewEye.z, m_v3Eye.z);
; 61   : 			SetEye(v3NewEye);
; 62   : 		}
; 63   : 	}
; 64   : 
; 65   : 	if (rPythonBackground.GetPickingPointWithRayOnlyTerrain(m_kCameraBackToTerrainRay, &v3CollisionPoint))
; 66   : 	{
; 67   : 		if (D3DXVec3Length(&(m_v3Eye - v3CollisionPoint)) < m_fTerrainCollisionRadius)
; 68   : 		{
; 69   : 			D3DXVECTOR3 v3NewEye = v3CollisionPoint + m_fTerrainCollisionRadius * m_v3View;
; 70   : 			//printf("CameraBackToTerrain new %f > old %f", v3NewEye.z, m_v3Eye.z);
; 71   : 			SetEye(v3NewEye);
; 72   : 		}
; 73   : 	}
; 74   : 
; 75   : 	// Left
; 76   : 	if (rPythonBackground.GetPickingPointWithRayOnlyTerrain(m_kCameraLeftToTerrainRay, &v3CollisionPoint))
; 77   : 	{
; 78   : 		SetCameraState(CAMERA_STATE_CANTGOLEFT);
; 79   : 		if (D3DXVec3Length(&(m_v3Eye - v3CollisionPoint)) < 3.0f * m_fTerrainCollisionRadius)
; 80   : 		{
; 81   : 			D3DXVECTOR3 v3NewEye = v3CollisionPoint + 3.0f * m_fTerrainCollisionRadius * m_v3Cross;
; 82   : 			//printf("CameraLeftToTerrain new %f > old %f", v3NewEye.z, m_v3Eye.z);
; 83   : 			SetEye(v3NewEye);
; 84   : 		}
; 85   : 	}
; 86   : 	else
; 87   : 		SetCameraState(CAMERA_STATE_NORMAL);
; 88   : 
; 89   : 	// Right
; 90   : 	if (rPythonBackground.GetPickingPointWithRayOnlyTerrain(m_kCameraRightToTerrainRay, &v3CollisionPoint))
; 91   : 	{
; 92   : 		SetCameraState(CAMERA_STATE_CANTGORIGHT);
; 93   : 		if (D3DXVec3Length(&(m_v3Eye - v3CollisionPoint)) < 3.0f * m_fTerrainCollisionRadius)
; 94   : 		{
; 95   : 			D3DXVECTOR3 v3NewEye = v3CollisionPoint - 3.0f * m_fTerrainCollisionRadius * m_v3Cross;
; 96   : 			//printf("CameraRightToTerrain new %f > old %f", v3NewEye.z, m_v3Eye.z);
; 97   : 			SetEye(v3NewEye);
; 98   : 		}
; 99   : 	}
; 100  : 	else
; 101  : 		SetCameraState(CAMERA_STATE_NORMAL);
; 102  : 	*/
; 103  : }

  00215	5f		 pop	 edi
  00216	5e		 pop	 esi
  00217	8b 4c 24 34	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+56]
  0021b	33 cc		 xor	 ecx, esp
  0021d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00222	8b e5		 mov	 esp, ebp
  00224	5d		 pop	 ebp
  00225	c3		 ret	 0
$LN3@ProcessTer:

; 50   : 		}
; 51   : 	}
; 52   : 	else
; 53   : 		SetCameraState(CAMERA_STATE_NORMAL);

  00226	6a 00		 push	 0
  00228	e8 00 00 00 00	 call	 ?SetCameraState@CCamera@@QAEXW4_eCameraState_@@@Z ; CCamera::SetCameraState
$LN1@ProcessTer:

; 54   : /*
; 55   : 	if (rPythonBackground.GetPickingPointWithRayOnlyTerrain(m_kCameraFrontToTerrainRay, &v3CollisionPoint))
; 56   : 	{
; 57   : 		if (D3DXVec3Length(&(m_v3Eye - v3CollisionPoint)) < 4.0f * m_fTerrainCollisionRadius)
; 58   : 		{
; 59   : 			D3DXVECTOR3 v3NewEye = v3CollisionPoint - 4.0f * m_fTerrainCollisionRadius * m_v3View;
; 60   : 			//printf("CameraFrontToTerrain new %f > old %f", v3NewEye.z, m_v3Eye.z);
; 61   : 			SetEye(v3NewEye);
; 62   : 		}
; 63   : 	}
; 64   : 
; 65   : 	if (rPythonBackground.GetPickingPointWithRayOnlyTerrain(m_kCameraBackToTerrainRay, &v3CollisionPoint))
; 66   : 	{
; 67   : 		if (D3DXVec3Length(&(m_v3Eye - v3CollisionPoint)) < m_fTerrainCollisionRadius)
; 68   : 		{
; 69   : 			D3DXVECTOR3 v3NewEye = v3CollisionPoint + m_fTerrainCollisionRadius * m_v3View;
; 70   : 			//printf("CameraBackToTerrain new %f > old %f", v3NewEye.z, m_v3Eye.z);
; 71   : 			SetEye(v3NewEye);
; 72   : 		}
; 73   : 	}
; 74   : 
; 75   : 	// Left
; 76   : 	if (rPythonBackground.GetPickingPointWithRayOnlyTerrain(m_kCameraLeftToTerrainRay, &v3CollisionPoint))
; 77   : 	{
; 78   : 		SetCameraState(CAMERA_STATE_CANTGOLEFT);
; 79   : 		if (D3DXVec3Length(&(m_v3Eye - v3CollisionPoint)) < 3.0f * m_fTerrainCollisionRadius)
; 80   : 		{
; 81   : 			D3DXVECTOR3 v3NewEye = v3CollisionPoint + 3.0f * m_fTerrainCollisionRadius * m_v3Cross;
; 82   : 			//printf("CameraLeftToTerrain new %f > old %f", v3NewEye.z, m_v3Eye.z);
; 83   : 			SetEye(v3NewEye);
; 84   : 		}
; 85   : 	}
; 86   : 	else
; 87   : 		SetCameraState(CAMERA_STATE_NORMAL);
; 88   : 
; 89   : 	// Right
; 90   : 	if (rPythonBackground.GetPickingPointWithRayOnlyTerrain(m_kCameraRightToTerrainRay, &v3CollisionPoint))
; 91   : 	{
; 92   : 		SetCameraState(CAMERA_STATE_CANTGORIGHT);
; 93   : 		if (D3DXVec3Length(&(m_v3Eye - v3CollisionPoint)) < 3.0f * m_fTerrainCollisionRadius)
; 94   : 		{
; 95   : 			D3DXVECTOR3 v3NewEye = v3CollisionPoint - 3.0f * m_fTerrainCollisionRadius * m_v3Cross;
; 96   : 			//printf("CameraRightToTerrain new %f > old %f", v3NewEye.z, m_v3Eye.z);
; 97   : 			SetEye(v3NewEye);
; 98   : 		}
; 99   : 	}
; 100  : 	else
; 101  : 		SetCameraState(CAMERA_STATE_NORMAL);
; 102  : 	*/
; 103  : }

  0022d	8b 4c 24 3c	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+64]
  00231	5f		 pop	 edi
  00232	5e		 pop	 esi
  00233	33 cc		 xor	 ecx, esp
  00235	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0023a	8b e5		 mov	 esp, ebp
  0023c	5d		 pop	 ebp
  0023d	c3		 ret	 0
?ProcessTerrainCollision@CCamera@@AAEXXZ ENDP		; CCamera::ProcessTerrainCollision
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\cameraprocedure.cpp
;	COMDAT ??RCameraCollisionChecker@@QAEXPAVCGraphicObjectInstance@@@Z
_TEXT	SEGMENT
_pOpponent$ = 8						; size = 4
??RCameraCollisionChecker@@QAEXPAVCGraphicObjectInstance@@@Z PROC ; CameraCollisionChecker::operator(), COMDAT
; _this$ = ecx

; 115  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 116  : 		if (pOpponent->CollisionDynamicSphere(*m_pdsi))

  00006	8b 4d 08	 mov	 ecx, DWORD PTR _pOpponent$[ebp]
  00009	ff 76 08	 push	 DWORD PTR [esi+8]
  0000c	e8 00 00 00 00	 call	 ?CollisionDynamicSphere@CGraphicObjectInstance@@QBE_NABUCDynamicSphereInstance@@@Z ; CGraphicObjectInstance::CollisionDynamicSphere
  00011	84 c0		 test	 al, al
  00013	74 14		 je	 SHORT $LN1@operator

; 117  :  		{
; 118  : 			m_pkVct_v3Position->push_back(pOpponent->GetPosition());

  00015	8b 4d 08	 mov	 ecx, DWORD PTR _pOpponent$[ebp]
  00018	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
  0001d	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ?push_back@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXABUD3DXVECTOR3@@@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::push_back

; 119  : 			m_isBlocked = true;

  00026	c6 06 01	 mov	 BYTE PTR [esi], 1
$LN1@operator:
  00029	5e		 pop	 esi

; 120  :  		}
; 121  : 	}

  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??RCameraCollisionChecker@@QAEXPAVCGraphicObjectInstance@@@Z ENDP ; CameraCollisionChecker::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\cameraprocedure.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\camera.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\cameraprocedure.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\cameraprocedure.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\cameraprocedure.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\cameraprocedure.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\cameraprocedure.cpp
;	COMDAT ?Update@CCamera@@QAEXXZ
_TEXT	SEGMENT
_fNewDistance$ = -4					; size = 4
?Update@CCamera@@QAEXXZ PROC				; CCamera::Update, COMDAT
; _this$ = ecx

; 314  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	51		 push	 ecx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 315  : // 	ProcessBuildingCollision();
; 316  : 
; 317  : 	RotateEyeAroundTarget(m_v3AngularVelocity.z, m_v3AngularVelocity.x);

  0000a	83 ec 08	 sub	 esp, 8
  0000d	f3 0f 10 86 24
	03 00 00	 movss	 xmm0, DWORD PTR [esi+804]
  00015	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0001b	f3 0f 10 86 2c
	03 00 00	 movss	 xmm0, DWORD PTR [esi+812]
  00023	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00028	e8 00 00 00 00	 call	 ?RotateEyeAroundTarget@CCamera@@QAEXMM@Z ; CCamera::RotateEyeAroundTarget
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\camera.h

; 186  : 		float GetDistance() const { return m_fDistance; }

  0002d	f3 0f 10 86 34
	01 00 00	 movss	 xmm0, DWORD PTR [esi+308]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\cameraprocedure.cpp

; 319  : 	float fNewDistance=fMAX(CAMERA_MIN_DISTANCE, fMIN( CAMERA_MAX_DISTANCE, GetDistance() - m_v3AngularVelocity.y ) );

  00035	83 ec 08	 sub	 esp, 8
  00038	f3 0f 5c 86 28
	03 00 00	 subss	 xmm0, DWORD PTR [esi+808]
  00040	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00046	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR ?CAMERA_MAX_DISTANCE@CCamera@@0MA
  0004e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00053	e8 00 00 00 00	 call	 ?fMIN@@YAMMM@Z		; fMIN
  00058	d9 5c 24 04	 fstp	 DWORD PTR [esp+4]
  0005c	c7 04 24 00 00
	48 43		 mov	 DWORD PTR [esp], 1128792064 ; 43480000H
  00063	e8 00 00 00 00	 call	 ?fMAX@@YAMMM@Z		; fMAX

; 320  : 	SetDistance(fNewDistance);

  00068	83 c4 04	 add	 esp, 4
  0006b	8b ce		 mov	 ecx, esi
  0006d	d9 5c 24 08	 fstp	 DWORD PTR _fNewDistance$[esp+12]
  00071	f3 0f 10 44 24
	08		 movss	 xmm0, DWORD PTR _fNewDistance$[esp+12]
  00077	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0007c	e8 00 00 00 00	 call	 ?SetDistance@CCamera@@QAEXM@Z ; CCamera::SetDistance

; 321  : 	
; 322  : 	if (m_bProcessTerrainCollision)

  00081	80 be 34 03 00
	00 00		 cmp	 BYTE PTR [esi+820], 0
  00088	74 07		 je	 SHORT $LN4@Update

; 323  :  		ProcessTerrainCollision();

  0008a	8b ce		 mov	 ecx, esi
  0008c	e8 00 00 00 00	 call	 ?ProcessTerrainCollision@CCamera@@AAEXXZ ; CCamera::ProcessTerrainCollision
$LN4@Update:
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl

; 222  :     x *= f;

  00091	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f000000
  00099	f3 0f 10 86 24
	03 00 00	 movss	 xmm0, DWORD PTR [esi+804]
  000a1	f3 0f 59 c1	 mulss	 xmm0, xmm1
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\cameraprocedure.cpp

; 326  : 	if (fabs(m_v3AngularVelocity.x) < 1.0f)

  000a5	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3f800000
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl

; 222  :     x *= f;

  000ad	f3 0f 11 86 24
	03 00 00	 movss	 DWORD PTR [esi+804], xmm0

; 223  :     y *= f;

  000b5	f3 0f 10 86 28
	03 00 00	 movss	 xmm0, DWORD PTR [esi+808]
  000bd	f3 0f 59 c1	 mulss	 xmm0, xmm1
  000c1	f3 0f 11 86 28
	03 00 00	 movss	 DWORD PTR [esi+808], xmm0

; 224  :     z *= f;

  000c9	f3 0f 10 86 2c
	03 00 00	 movss	 xmm0, DWORD PTR [esi+812]
  000d1	f3 0f 59 c1	 mulss	 xmm0, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

  000d5	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl

; 224  :     z *= f;

  000dd	f3 0f 11 86 2c
	03 00 00	 movss	 DWORD PTR [esi+812], xmm0
  000e5	f3 0f 10 86 24
	03 00 00	 movss	 xmm0, DWORD PTR [esi+804]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

  000ed	0f 5a c0	 cvtps2pd xmm0, xmm0
  000f0	66 0f 54 c1	 andpd	 xmm0, xmm1
  000f4	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\cameraprocedure.cpp

; 326  : 	if (fabs(m_v3AngularVelocity.x) < 1.0f)

  000f8	0f 2f d0	 comiss	 xmm2, xmm0
  000fb	76 0a		 jbe	 SHORT $LN3@Update

; 327  : 		m_v3AngularVelocity.x = 0.0f;

  000fd	c7 86 24 03 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+804], 0
$LN3@Update:
  00107	f3 0f 10 86 28
	03 00 00	 movss	 xmm0, DWORD PTR [esi+808]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

  0010f	0f 5a c0	 cvtps2pd xmm0, xmm0
  00112	66 0f 54 c1	 andpd	 xmm0, xmm1
  00116	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\cameraprocedure.cpp

; 328  : 	if (fabs(m_v3AngularVelocity.y) < 1.0f)

  0011a	0f 2f d0	 comiss	 xmm2, xmm0
  0011d	76 0a		 jbe	 SHORT $LN2@Update

; 329  : 		m_v3AngularVelocity.y = 0.0f;

  0011f	c7 86 28 03 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+808], 0
$LN2@Update:
  00129	f3 0f 10 86 2c
	03 00 00	 movss	 xmm0, DWORD PTR [esi+812]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

  00131	0f 5a c0	 cvtps2pd xmm0, xmm0
  00134	66 0f 54 c1	 andpd	 xmm0, xmm1
  00138	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\cameraprocedure.cpp

; 330  : 	if (fabs(m_v3AngularVelocity.z) < 1.0f)

  0013c	0f 2f d0	 comiss	 xmm2, xmm0
  0013f	76 0a		 jbe	 SHORT $LN1@Update

; 331  : 		m_v3AngularVelocity.z = 0.0f;

  00141	c7 86 2c 03 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+812], 0
$LN1@Update:

; 332  : 
; 333  : 	const float CAMERA_MOVABLE_DISTANCE = CAMERA_MAX_DISTANCE - CAMERA_MIN_DISTANCE;
; 334  : 	const float CAMERA_TARGET_DELTA = CAMERA_TARGET_FACE - CAMERA_TARGET_STANDARD;
; 335  : 	float fCameraCurMovableDistance=CAMERA_MAX_DISTANCE - GetDistance();

  0014b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR ?CAMERA_MAX_DISTANCE@CCamera@@0MA
  00153	0f 28 c8	 movaps	 xmm1, xmm0
  00156	f3 0f 5c 8e 34
	01 00 00	 subss	 xmm1, DWORD PTR [esi+308]
  0015e	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@43480000

; 336  : 	float fNewTargetHeight = CAMERA_TARGET_STANDARD + CAMERA_TARGET_DELTA * fCameraCurMovableDistance / CAMERA_MOVABLE_DISTANCE;
; 337  : 
; 338  : 	SetTargetHeight(fNewTargetHeight);

  00166	51		 push	 ecx
  00167	8b ce		 mov	 ecx, esi
  00169	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@42480000
  00171	f3 0f 5e c8	 divss	 xmm1, xmm0
  00175	f3 0f 58 0d 00
	00 00 00	 addss	 xmm1, DWORD PTR __real@42c80000
  0017d	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  00182	e8 00 00 00 00	 call	 ?SetTargetHeight@CCamera@@QAEXM@Z ; CCamera::SetTargetHeight

; 339  : 
; 340  : 	// Cinematic
; 341  : #ifdef __20040725_CAMERA_WORK__
; 342  : 	m_MovementPosition += m_MovementSpeed;
; 343  : 	
; 344  : 	if (0.0f != m_MovementPosition.m_fViewDir)
; 345  : 		MoveFront(m_MovementPosition.m_fViewDir);
; 346  : 	if (0.0f != m_MovementPosition.m_fCrossDir)
; 347  : 		MoveAlongCross(m_MovementPosition.m_fCrossDir);
; 348  : 	if (0.0f != m_MovementPosition.m_fUpDir)
; 349  : 		MoveVertical(m_MovementPosition.m_fUpDir);
; 350  : #endif
; 351  : }

  00187	5e		 pop	 esi
  00188	8b e5		 mov	 esp, ebp
  0018a	5d		 pop	 ebp
  0018b	c3		 ret	 0
?Update@CCamera@@QAEXXZ ENDP				; CCamera::Update
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h
;	COMDAT ?Instance@?$CSingleton@VCCullingManager@@@@SAAAVCCullingManager@@XZ
_TEXT	SEGMENT
?Instance@?$CSingleton@VCCullingManager@@@@SAAAVCCullingManager@@XZ PROC ; CSingleton<CCullingManager>::Instance, COMDAT

; 26   : 		assert(ms_singleton);
; 27   : 		return (*ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCCullingManager@@@@0PAVCCullingManager@@A ; CSingleton<CCullingManager>::ms_singleton

; 28   : 	}

  00005	c3		 ret	 0
?Instance@?$CSingleton@VCCullingManager@@@@SAAAVCCullingManager@@XZ ENDP ; CSingleton<CCullingManager>::Instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??1?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::~vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN3@vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@vector:
  00026	5e		 pop	 esi

; 945  : 		_Tidy();
; 946  : 		}

  00027	c3		 ret	 0
??1?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::~vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?size@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QBEIXZ PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::size, COMDAT
; _this$ = ecx

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00008	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000a	f7 ea		 imul	 edx
  0000c	d1 fa		 sar	 edx, 1
  0000e	8b c2		 mov	 eax, edx
  00010	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00013	03 c2		 add	 eax, edx

; 1149 : 		}

  00015	c3		 ret	 0
?size@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QBEIXZ ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?push_back@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXABUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXABUD3DXVECTOR3@@@Z PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::push_back, COMDAT
; _this$ = ecx

; 1243 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00007	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0000d	3b f9		 cmp	 edi, ecx
  0000f	73 4d		 jae	 SHORT $LN4@push_back
  00011	8b 06		 mov	 eax, DWORD PTR [esi]
  00013	3b c7		 cmp	 eax, edi
  00015	77 47		 ja	 SHORT $LN4@push_back

; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00017	2b f8		 sub	 edi, eax
  00019	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0001e	f7 ef		 imul	 edi
  00020	d1 fa		 sar	 edx, 1
  00022	8b fa		 mov	 edi, edx
  00024	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  00027	03 fa		 add	 edi, edx

; 1247 : 			if (this->_Mylast == this->_Myend)

  00029	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  0002c	75 09		 jne	 SHORT $LN3@push_back

; 1248 : 				_Reserve(1);

  0002e	6a 01		 push	 1
  00030	8b ce		 mov	 ecx, esi
  00032	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXI@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Reserve
$LN3@push_back:

; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);

  00037	8b 06		 mov	 eax, DWORD PTR [esi]
  00039	8d 0c 7f	 lea	 ecx, DWORD PTR [edi+edi*2]
  0003c	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0003f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00042	85 c9		 test	 ecx, ecx
  00044	74 3b		 je	 SHORT $LN49@push_back
  00046	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  0004a	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  0004e	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00051	89 41 08	 mov	 DWORD PTR [ecx+8], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

  00054	83 46 04 0c	 add	 DWORD PTR [esi+4], 12	; 0000000cH
  00058	5f		 pop	 edi
  00059	5e		 pop	 esi

; 1262 : 			}
; 1263 : 		}

  0005a	5d		 pop	 ebp
  0005b	c2 04 00	 ret	 4
$LN4@push_back:

; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

  0005e	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  00061	75 09		 jne	 SHORT $LN1@push_back

; 1257 : 				_Reserve(1);

  00063	6a 01		 push	 1
  00065	8b ce		 mov	 ecx, esi
  00067	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXI@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Reserve
$LN1@push_back:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  0006c	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0006f	85 c9		 test	 ecx, ecx
  00071	74 0e		 je	 SHORT $LN49@push_back
  00073	f3 0f 7e 07	 movq	 xmm0, QWORD PTR [edi]
  00077	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  0007b	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0007e	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN49@push_back:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

  00081	83 46 04 0c	 add	 DWORD PTR [esi+4], 12	; 0000000cH
  00085	5f		 pop	 edi
  00086	5e		 pop	 esi

; 1262 : 			}
; 1263 : 		}

  00087	5d		 pop	 ebp
  00088	c2 04 00	 ret	 4
?push_back@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXABUD3DXVECTOR3@@@Z ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h
;	COMDAT ?Instance@?$CSingleton@VCPythonBackground@@@@SAAAVCPythonBackground@@XZ
_TEXT	SEGMENT
?Instance@?$CSingleton@VCPythonBackground@@@@SAAAVCPythonBackground@@XZ PROC ; CSingleton<CPythonBackground>::Instance, COMDAT

; 26   : 		assert(ms_singleton);
; 27   : 		return (*ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A ; CSingleton<CPythonBackground>::ms_singleton

; 28   : 	}

  00005	c3		 ret	 0
?Instance@?$CSingleton@VCPythonBackground@@@@SAAAVCPythonBackground@@XZ ENDP ; CSingleton<CPythonBackground>::Instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IBE_NPBUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IBE_NPBUD3DXVECTOR3@@@Z PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Inside, COMDAT
; _this$ = ecx

; 1582 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0a		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 06		 ja	 SHORT $LN3@Inside
  0000f	b0 01		 mov	 al, 1

; 1584 : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
$LN3@Inside:

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00015	32 c0		 xor	 al, al

; 1584 : 		}

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?_Inside@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IBE_NPBUD3DXVECTOR3@@@Z ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXI@Z PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Reserve, COMDAT
; _this$ = ecx

; 1612 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

  00004	8b 59 08	 mov	 ebx, DWORD PTR [ecx+8]
  00007	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0000c	56		 push	 esi
  0000d	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00010	8b d3		 mov	 edx, ebx
  00012	2b d6		 sub	 edx, esi
  00014	f7 ea		 imul	 edx
  00016	57		 push	 edi

; 1613 : 		if (_Unused_capacity() < _Count)

  00017	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

  0001a	d1 fa		 sar	 edx, 1
  0001c	8b c2		 mov	 eax, edx
  0001e	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00021	03 c2		 add	 eax, edx

; 1613 : 		if (_Unused_capacity() < _Count)

  00023	3b c7		 cmp	 eax, edi
  00025	73 66		 jae	 SHORT $LN2@Reserve

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00027	2b 31		 sub	 esi, DWORD PTR [ecx]
  00029	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0002e	f7 ee		 imul	 esi

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  00030	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00035	d1 fa		 sar	 edx, 1
  00037	8b f2		 mov	 esi, edx
  00039	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  0003c	03 f2		 add	 esi, edx

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  0003e	2b c6		 sub	 eax, esi
  00040	3b c7		 cmp	 eax, edi
  00042	72 50		 jb	 SHORT $LN43@Reserve

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00044	2b 19		 sub	 ebx, DWORD PTR [ecx]
  00046	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0004b	f7 eb		 imul	 ebx

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0004d	03 f7		 add	 esi, edi

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  0004f	bf 55 55 55 15	 mov	 edi, 357913941		; 15555555H

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00054	d1 fa		 sar	 edx, 1
  00056	8b c2		 mov	 eax, edx
  00058	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0005b	03 c2		 add	 eax, edx

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  0005d	8b d0		 mov	 edx, eax
  0005f	d1 ea		 shr	 edx, 1
  00061	2b fa		 sub	 edi, edx
  00063	3b f8		 cmp	 edi, eax
  00065	73 13		 jae	 SHORT $LN27@Reserve
  00067	33 c0		 xor	 eax, eax

; 1576 : 		if (_Capacity < _Count)

  00069	3b c6		 cmp	 eax, esi
  0006b	5f		 pop	 edi
  0006c	0f 42 c6	 cmovb	 eax, esi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00071	89 45 08	 mov	 DWORD PTR __Count$[ebp], eax

; 1618 : 			}
; 1619 : 		}

  00074	5d		 pop	 ebp

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00075	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXI@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Reallocate
$LN27@Reserve:

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  0007a	03 c2		 add	 eax, edx

; 1576 : 		if (_Capacity < _Count)

  0007c	3b c6		 cmp	 eax, esi
  0007e	5f		 pop	 edi
  0007f	0f 42 c6	 cmovb	 eax, esi
  00082	5e		 pop	 esi
  00083	5b		 pop	 ebx

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00084	89 45 08	 mov	 DWORD PTR __Count$[ebp], eax

; 1618 : 			}
; 1619 : 		}

  00087	5d		 pop	 ebp

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00088	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXI@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Reallocate
$LN2@Reserve:
  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	5b		 pop	 ebx

; 1618 : 			}
; 1619 : 		}

  00090	5d		 pop	 ebp
  00091	c2 04 00	 ret	 4
$LN43@Reserve:

; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

  00094	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00099	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN45@Reserve:
$LN42@Reserve:
  0009e	cc		 int	 3
?_Reserve@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXI@Z ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXXZ PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN1@Tidy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Tidy:
  00026	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXXZ ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IBEXPAUD3DXVECTOR3@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IBEXPAUD3DXVECTOR3@@0@Z PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1781 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IBEXPAUD3DXVECTOR3@@0@Z ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@UD3DXVECTOR3@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@UD3DXVECTOR3@@@std@@QAE@XZ PROC		; std::allocator<D3DXVECTOR3>::allocator<D3DXVECTOR3>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@UD3DXVECTOR3@@@std@@QAE@XZ ENDP		; std::allocator<D3DXVECTOR3>::allocator<D3DXVECTOR3>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QBEIXZ PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1015 : 		return (this->_Myend - this->_Mylast);

  00000	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00003	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00008	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  0000b	f7 ea		 imul	 edx
  0000d	d1 fa		 sar	 edx, 1
  0000f	8b c2		 mov	 eax, edx
  00011	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00014	03 c2		 add	 eax, edx

; 1016 : 		}

  00016	c3		 ret	 0
?_Unused_capacity@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QBEIXZ ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?max_size@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QBEIXZ PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::max_size, COMDAT
; _this$ = ecx

; 1153 : 		return (this->_Getal().max_size());

  00000	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 1154 : 		}

  00005	c3		 ret	 0
?max_size@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QBEIXZ ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXPAUD3DXVECTOR3@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXPAUD3DXVECTOR3@@0@Z PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Destroy, COMDAT
; _this$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXPAUD3DXVECTOR3@@0@Z ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IBEII@Z PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Grow_to, COMDAT
; _this$ = ecx

; 1571 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00006	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0000b	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000d	f7 ea		 imul	 edx
  0000f	56		 push	 esi
  00010	d1 fa		 sar	 edx, 1

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00012	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00017	8b f2		 mov	 esi, edx
  00019	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  0001c	03 f2		 add	 esi, edx

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  0001e	8b ce		 mov	 ecx, esi
  00020	d1 e9		 shr	 ecx, 1
  00022	2b c1		 sub	 eax, ecx
  00024	3b c6		 cmp	 eax, esi
  00026	73 10		 jae	 SHORT $LN4@Grow_to
  00028	33 f6		 xor	 esi, esi

; 1576 : 		if (_Capacity < _Count)

  0002a	3b 75 08	 cmp	 esi, DWORD PTR __Count$[ebp]
  0002d	0f 42 75 08	 cmovb	 esi, DWORD PTR __Count$[ebp]

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

  00031	8b c6		 mov	 eax, esi
  00033	5e		 pop	 esi

; 1579 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN4@Grow_to:

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00038	03 f1		 add	 esi, ecx

; 1576 : 		if (_Capacity < _Count)

  0003a	3b 75 08	 cmp	 esi, DWORD PTR __Count$[ebp]
  0003d	0f 42 75 08	 cmovb	 esi, DWORD PTR __Count$[ebp]

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

  00041	8b c6		 mov	 eax, esi
  00043	5e		 pop	 esi

; 1579 : 		}

  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
?_Grow_to@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IBEII@Z ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$1$ = 8						; size = 4
__Cat$1 = 8						; size = 1
__Count$ = 8						; size = 4
__Alval$2 = 11						; size = 1
?_Reallocate@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXI@Z PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Reallocate, COMDAT
; _this$ = ecx

; 1587 : 		{	// move to array of exactly _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 25   : 	if (_Count == 0)

  00005	8b 75 08	 mov	 esi, DWORD PTR __Count$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1587 : 		{	// move to array of exactly _Count elements

  00008	8b d9		 mov	 ebx, ecx
  0000a	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 23   : 	void *_Ptr = 0;

  0000b	33 ff		 xor	 edi, edi

; 25   : 	if (_Count == 0)

  0000d	85 f6		 test	 esi, esi
  0000f	74 1d		 je	 SHORT $LN16@Reallocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00011	81 fe 55 55 55
	15		 cmp	 esi, 357913941		; 15555555H
  00017	77 71		 ja	 SHORT $LN59@Reallocate
  00019	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
  0001c	c1 e0 02	 shl	 eax, 2
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00025	8b f8		 mov	 edi, eax
  00027	83 c4 04	 add	 esp, 4
  0002a	85 ff		 test	 edi, edi
  0002c	74 5c		 je	 SHORT $LN59@Reallocate
$LN16@Reallocate:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  0002e	ff 75 08	 push	 DWORD PTR __Cat$1[ebp]
  00031	8d 45 0b	 lea	 eax, DWORD PTR __Alval$2[ebp]
  00034	6a 00		 push	 0
  00036	50		 push	 eax
  00037	57		 push	 edi
  00038	ff 73 04	 push	 DWORD PTR [ebx+4]
  0003b	ff 33		 push	 DWORD PTR [ebx]
  0003d	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUD3DXVECTOR3@@PAU1@V?$allocator@UD3DXVECTOR3@@@std@@U1@@std@@YAPAUD3DXVECTOR3@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<D3DXVECTOR3 *,D3DXVECTOR3 *,std::allocator<D3DXVECTOR3>,D3DXVECTOR3>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00042	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00045	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0004a	2b 0b		 sub	 ecx, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  0004c	83 c4 18	 add	 esp, 24			; 00000018H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0004f	f7 e9		 imul	 ecx

; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())

  00051	8b 03		 mov	 eax, DWORD PTR [ebx]

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00053	d1 fa		 sar	 edx, 1
  00055	8b ca		 mov	 ecx, edx
  00057	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0005a	03 ca		 add	 ecx, edx
  0005c	89 4d 08	 mov	 DWORD PTR __Size$1$[ebp], ecx

; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())

  0005f	85 c0		 test	 eax, eax
  00061	74 0c		 je	 SHORT $LN54@Reallocate
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00069	8b 4d 08	 mov	 ecx, DWORD PTR __Size$1$[ebp]
  0006c	83 c4 04	 add	 esp, 4
$LN54@Reallocate:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1606 : 		this->_Myend = _Ptr + _Count;

  0006f	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]

; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;

  00072	89 3b		 mov	 DWORD PTR [ebx], edi
  00074	8d 04 87	 lea	 eax, DWORD PTR [edi+eax*4]
  00077	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  0007a	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  0007d	8d 04 87	 lea	 eax, DWORD PTR [edi+eax*4]
  00080	5f		 pop	 edi
  00081	5e		 pop	 esi
  00082	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  00085	5b		 pop	 ebx

; 1609 : 		}

  00086	5d		 pop	 ebp
  00087	c2 04 00	 ret	 4
$LN59@Reallocate:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  0008a	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN61@Reallocate:
$LN58@Reallocate:
  0008f	cc		 int	 3
?_Reallocate@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXI@Z ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Reallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IBEXXZ PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Xlen, COMDAT
; _this$ = ecx

; 1754 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IBEXXZ ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<D3DXVECTOR3> >::_Wrap_alloc<std::allocator<D3DXVECTOR3> >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<D3DXVECTOR3> >::_Wrap_alloc<std::allocator<D3DXVECTOR3> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXPAUD3DXVECTOR3@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXPAUD3DXVECTOR3@@I@Z PROC ; std::_Wrap_alloc<std::allocator<D3DXVECTOR3> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXPAUD3DXVECTOR3@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<D3DXVECTOR3> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?capacity@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QBEIXZ PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::capacity, COMDAT
; _this$ = ecx

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00000	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00003	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00008	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000a	f7 ea		 imul	 edx
  0000c	d1 fa		 sar	 edx, 1
  0000e	8b c2		 mov	 eax, edx
  00010	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00013	03 c2		 add	 eax, edx

; 1011 : 		}

  00015	c3		 ret	 0
?capacity@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QBEIXZ ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@UD3DXVECTOR3@@@std@@QAEXPAUD3DXVECTOR3@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UD3DXVECTOR3@@@std@@QAEXPAUD3DXVECTOR3@@I@Z PROC ; std::allocator<D3DXVECTOR3>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@UD3DXVECTOR3@@@std@@QAEXPAUD3DXVECTOR3@@I@Z ENDP ; std::allocator<D3DXVECTOR3>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEPAUD3DXVECTOR3@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEPAUD3DXVECTOR3@@I@Z PROC ; std::_Wrap_alloc<std::allocator<D3DXVECTOR3> >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 1c		 je	 SHORT $LN6@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d 55 55 55 15	 cmp	 eax, 357913941		; 15555555H
  00011	77 1b		 ja	 SHORT $LN14@allocate
  00013	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00016	c1 e0 02	 shl	 eax, 2
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001f	8b c8		 mov	 ecx, eax
  00021	83 c4 04	 add	 esp, 4
  00024	85 c9		 test	 ecx, ecx
  00026	74 06		 je	 SHORT $LN14@allocate
$LN6@allocate:

; 847  : 		return (_Mybase::allocate(_Count));

  00028	8b c1		 mov	 eax, ecx

; 848  : 		}

  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
$LN14@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002e	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN16@allocate:
$LN13@allocate:
  00033	cc		 int	 3
?allocate@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEPAUD3DXVECTOR3@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<D3DXVECTOR3> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<D3DXVECTOR3> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (_Mytraits::max_size(*this));

  00000	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<D3DXVECTOR3> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@UD3DXVECTOR3@@@std@@QAEPAUD3DXVECTOR3@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@UD3DXVECTOR3@@@std@@QAEPAUD3DXVECTOR3@@I@Z PROC ; std::allocator<D3DXVECTOR3>::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 1c		 je	 SHORT $LN4@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d 55 55 55 15	 cmp	 eax, 357913941		; 15555555H
  00011	77 1b		 ja	 SHORT $LN11@allocate
  00013	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00016	c1 e0 02	 shl	 eax, 2
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001f	8b c8		 mov	 ecx, eax
  00021	83 c4 04	 add	 esp, 4
  00024	85 c9		 test	 ecx, ecx
  00026	74 06		 je	 SHORT $LN11@allocate
$LN4@allocate:

; 578  : 		return (_Allocate(_Count, (pointer)0));

  00028	8b c1		 mov	 eax, ecx

; 579  : 		}

  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
$LN11@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002e	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN13@allocate:
$LN10@allocate:
  00033	cc		 int	 3
?allocate@?$allocator@UD3DXVECTOR3@@@std@@QAEPAUD3DXVECTOR3@@I@Z ENDP ; std::allocator<D3DXVECTOR3>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAIABV?$allocator@UD3DXVECTOR3@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAIABV?$allocator@UD3DXVECTOR3@@@2@@Z PROC ; std::allocator_traits<std::allocator<D3DXVECTOR3> >::max_size, COMDAT

; 735  : 		return (_Al.max_size());

  00000	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 736  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAIABV?$allocator@UD3DXVECTOR3@@@2@@Z ENDP ; std::allocator_traits<std::allocator<D3DXVECTOR3> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@UD3DXVECTOR3@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UD3DXVECTOR3@@@std@@QBEIXZ PROC	; std::allocator<D3DXVECTOR3>::max_size, COMDAT
; _this$ = ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 613  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@UD3DXVECTOR3@@@std@@QBEIXZ ENDP	; std::allocator<D3DXVECTOR3>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@$$CBUD3DXVECTOR3@@@std@@YAPBUD3DXVECTOR3@@ABU1@@Z
_TEXT	SEGMENT
??$addressof@$$CBUD3DXVECTOR3@@@std@@YAPBUD3DXVECTOR3@@ABU1@@Z PROC ; std::addressof<D3DXVECTOR3 const >, COMDAT
; __Val$ = ecx

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00000	8b c1		 mov	 eax, ecx

; 96   : 	}

  00002	c3		 ret	 0
??$addressof@$$CBUD3DXVECTOR3@@@std@@YAPBUD3DXVECTOR3@@ABU1@@Z ENDP ; std::addressof<D3DXVECTOR3 const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@UD3DXVECTOR3@@AAU1@@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXPAUD3DXVECTOR3@@AAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UD3DXVECTOR3@@AAU1@@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXPAUD3DXVECTOR3@@AAU2@@Z PROC ; std::_Wrap_alloc<std::allocator<D3DXVECTOR3> >::construct<D3DXVECTOR3,D3DXVECTOR3 &>, COMDAT
; _this$dead$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 11		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00011	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
??$construct@UD3DXVECTOR3@@AAU1@@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXPAUD3DXVECTOR3@@AAU2@@Z ENDP ; std::_Wrap_alloc<std::allocator<D3DXVECTOR3> >::construct<D3DXVECTOR3,D3DXVECTOR3 &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@UD3DXVECTOR3@@ABU1@@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXPAUD3DXVECTOR3@@ABU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UD3DXVECTOR3@@ABU1@@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXPAUD3DXVECTOR3@@ABU2@@Z PROC ; std::_Wrap_alloc<std::allocator<D3DXVECTOR3> >::construct<D3DXVECTOR3,D3DXVECTOR3 const &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 11		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00011	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
??$construct@UD3DXVECTOR3@@ABU1@@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXPAUD3DXVECTOR3@@ABU2@@Z ENDP ; std::_Wrap_alloc<std::allocator<D3DXVECTOR3> >::construct<D3DXVECTOR3,D3DXVECTOR3 const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@YAXPAUD3DXVECTOR3@@0AAU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@YAXPAUD3DXVECTOR3@@0AAU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<D3DXVECTOR3> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@YAXPAUD3DXVECTOR3@@0AAU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<D3DXVECTOR3> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??$_Umove@PAUD3DXVECTOR3@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEPAUD3DXVECTOR3@@PAU2@00@Z
_TEXT	SEGMENT
__Alval$ = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$1 = 16						; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAUD3DXVECTOR3@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEPAUD3DXVECTOR3@@PAU2@00@Z PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Umove<D3DXVECTOR3 *>, COMDAT
; _this$ = ecx

; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00004	ff 75 10	 push	 DWORD PTR __Cat$1[ebp]
  00007	8d 45 ff	 lea	 eax, DWORD PTR __Alval$[ebp]
  0000a	6a 00		 push	 0
  0000c	50		 push	 eax
  0000d	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  00010	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00013	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00016	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUD3DXVECTOR3@@PAU1@V?$allocator@UD3DXVECTOR3@@@std@@U1@@std@@YAPAUD3DXVECTOR3@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<D3DXVECTOR3 *,D3DXVECTOR3 *,std::allocator<D3DXVECTOR3>,D3DXVECTOR3>
  0001b	83 c4 18	 add	 esp, 24			; 00000018H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1649 : 		}

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUD3DXVECTOR3@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEPAUD3DXVECTOR3@@PAU2@00@Z ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Umove<D3DXVECTOR3 *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@UD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@IPAU1@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@IPAU1@@Z PROC ; std::_Allocate<D3DXVECTOR3>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 21		 je	 SHORT $LN2@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d 55 55 55 15	 cmp	 eax, 357913941		; 15555555H
  00011	77 15		 ja	 SHORT $LN1@Allocate
  00013	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00016	c1 e0 02	 shl	 eax, 2
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001f	8b c8		 mov	 ecx, eax
  00021	83 c4 04	 add	 esp, 4
  00024	85 c9		 test	 ecx, ecx
  00026	75 05		 jne	 SHORT $LN2@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00028	e9 00 00 00 00	 jmp	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN2@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

  0002d	8b c1		 mov	 eax, ecx

; 32   : 	}

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
??$_Allocate@UD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@IPAU1@@Z ENDP ; std::_Allocate<D3DXVECTOR3>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\cullingmanager.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\spherelib\spherepack.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\cullingmanager.h
;	COMDAT ??1?$RangeTester@UCameraCollisionChecker@@@@UAE@XZ
_TEXT	SEGMENT
??1?$RangeTester@UCameraCollisionChecker@@@@UAE@XZ PROC	; RangeTester<CameraCollisionChecker>::~RangeTester<CameraCollisionChecker>, COMDAT
; _this$ = ecx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\spherelib\spherepack.h

; 56   : 	virtual ~SpherePackCallback() {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7SpherePackCallback@@6B@
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\cullingmanager.h

; 19   : 	{}

  00006	c3		 ret	 0
??1?$RangeTester@UCameraCollisionChecker@@@@UAE@XZ ENDP	; RangeTester<CameraCollisionChecker>::~RangeTester<CameraCollisionChecker>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\cullingmanager.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\spherelib\spherepack.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\cullingmanager.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\spherelib\spherepack.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\cameraprocedure.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\cullingmanager.h
;	COMDAT ?RayTraceCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z
_TEXT	SEGMENT
_p1$ = 8						; size = 4
_dir$ = 12						; size = 4
_distance$ = 16						; size = 4
_sect$ = 20						; size = 4
_sphere$ = 24						; size = 4
?RayTraceCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z PROC ; RangeTester<CameraCollisionChecker>::RayTraceCallback, COMDAT
; _this$ = ecx

; 27   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 28   : #ifdef SPHERELIB_STRICT
; 29   : 		if (sphere->IS_SPHERE)
; 30   : 			puts("RangeTester::RayTraceCallback");
; 31   : #endif	
; 32   : 		if (dist<=0.0f || dist>=distance)

  00003	f3 0f 10 49 08	 movss	 xmm1, DWORD PTR [ecx+8]
  00008	0f 57 c0	 xorps	 xmm0, xmm0
  0000b	0f 2f c1	 comiss	 xmm0, xmm1
  0000e	73 06		 jae	 SHORT $LN1@RayTraceCa
  00010	0f 2f 4d 10	 comiss	 xmm1, DWORD PTR _distance$[ebp]
  00014	72 2e		 jb	 SHORT $LN7@RayTraceCa
$LN1@RayTraceCa:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\spherelib\spherepack.h

; 209  : 	void * GetUserData(void) const { return mUserData; };

  00016	8b 45 18	 mov	 eax, DWORD PTR _sphere$[ebp]
  00019	56		 push	 esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\cullingmanager.h

; 33   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());

  0001a	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0001d	57		 push	 edi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\spherelib\spherepack.h

; 209  : 	void * GetUserData(void) const { return mUserData; };

  0001e	8b 78 44	 mov	 edi, DWORD PTR [eax+68]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\cameraprocedure.cpp

; 116  : 		if (pOpponent->CollisionDynamicSphere(*m_pdsi))

  00021	8b cf		 mov	 ecx, edi
  00023	ff 76 08	 push	 DWORD PTR [esi+8]
  00026	e8 00 00 00 00	 call	 ?CollisionDynamicSphere@CGraphicObjectInstance@@QBE_NABUCDynamicSphereInstance@@@Z ; CGraphicObjectInstance::CollisionDynamicSphere
  0002b	84 c0		 test	 al, al
  0002d	74 13		 je	 SHORT $LN10@RayTraceCa

; 117  :  		{
; 118  : 			m_pkVct_v3Position->push_back(pOpponent->GetPosition());

  0002f	8b cf		 mov	 ecx, edi
  00031	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
  00036	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 ?push_back@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXABUD3DXVECTOR3@@@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::push_back

; 119  : 			m_isBlocked = true;

  0003f	c6 06 01	 mov	 BYTE PTR [esi], 1
$LN10@RayTraceCa:
  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
$LN7@RayTraceCa:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\cullingmanager.h

; 34   : 	};

  00044	5d		 pop	 ebp
  00045	c2 14 00	 ret	 20			; 00000014H
?RayTraceCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z ENDP ; RangeTester<CameraCollisionChecker>::RayTraceCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\cullingmanager.h
;	COMDAT ?VisibilityCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z
_TEXT	SEGMENT
_f$ = 8							; size = 4
_sphere$ = 12						; size = 4
_state$ = 16						; size = 4
?VisibilityCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z PROC ; RangeTester<CameraCollisionChecker>::VisibilityCallback, COMDAT
; _this$ = ecx

; 37   : 	virtual void VisibilityCallback(const Frustum &f,SpherePack *sphere,ViewState state){};

  00000	c2 0c 00	 ret	 12			; 0000000cH
?VisibilityCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z ENDP ; RangeTester<CameraCollisionChecker>::VisibilityCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\cullingmanager.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\spherelib\spherepack.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\cullingmanager.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\spherelib\spherepack.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\cameraprocedure.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\cullingmanager.h
;	COMDAT ?RangeTestCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_distance$ = 12						; size = 4
_sphere$ = 16						; size = 4
_state$ = 20						; size = 4
?RangeTestCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z PROC ; RangeTester<CameraCollisionChecker>::RangeTestCallback, COMDAT
; _this$ = ecx

; 40   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 41   : #ifdef SPHERELIB_STRICT
; 42   : 		if (sphere->IS_SPHERE)
; 43   : 			puts("RangeTester::RangeTestCallback");
; 44   : #endif	
; 45   : 		if (state!=VS_OUTSIDE)

  00003	83 7d 14 02	 cmp	 DWORD PTR _state$[ebp], 2
  00007	74 2e		 je	 SHORT $LN6@RangeTestC
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\spherelib\spherepack.h

; 209  : 	void * GetUserData(void) const { return mUserData; };

  00009	8b 45 10	 mov	 eax, DWORD PTR _sphere$[ebp]
  0000c	56		 push	 esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\cullingmanager.h

; 46   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());

  0000d	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00010	57		 push	 edi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\spherelib\spherepack.h

; 209  : 	void * GetUserData(void) const { return mUserData; };

  00011	8b 78 44	 mov	 edi, DWORD PTR [eax+68]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\cameraprocedure.cpp

; 116  : 		if (pOpponent->CollisionDynamicSphere(*m_pdsi))

  00014	8b cf		 mov	 ecx, edi
  00016	ff 76 08	 push	 DWORD PTR [esi+8]
  00019	e8 00 00 00 00	 call	 ?CollisionDynamicSphere@CGraphicObjectInstance@@QBE_NABUCDynamicSphereInstance@@@Z ; CGraphicObjectInstance::CollisionDynamicSphere
  0001e	84 c0		 test	 al, al
  00020	74 13		 je	 SHORT $LN9@RangeTestC

; 117  :  		{
; 118  : 			m_pkVct_v3Position->push_back(pOpponent->GetPosition());

  00022	8b cf		 mov	 ecx, edi
  00024	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
  00029	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ?push_back@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXABUD3DXVECTOR3@@@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::push_back

; 119  : 			m_isBlocked = true;

  00032	c6 06 01	 mov	 BYTE PTR [esi], 1
$LN9@RangeTestC:
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
$LN6@RangeTestC:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\cullingmanager.h

; 47   : 	}

  00037	5d		 pop	 ebp
  00038	c2 10 00	 ret	 16			; 00000010H
?RangeTestCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z ENDP ; RangeTester<CameraCollisionChecker>::RangeTestCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\cullingmanager.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\spherelib\spherepack.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\cullingmanager.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\spherelib\spherepack.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\cameraprocedure.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\cullingmanager.h
;	COMDAT ?PointTest2dCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_sphere$ = 12						; size = 4
_state$ = 16						; size = 4
?PointTest2dCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z PROC ; RangeTester<CameraCollisionChecker>::PointTest2dCallback, COMDAT
; _this$ = ecx

; 50   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 51   : #ifdef SPHERELIB_STRICT
; 52   : 		if (sphere->IS_SPHERE)
; 53   : 			puts("RangeTester::PointTest2dCallback");	
; 54   : #endif
; 55   : 		if (state!=VS_OUTSIDE)

  00003	83 7d 10 02	 cmp	 DWORD PTR _state$[ebp], 2
  00007	74 2e		 je	 SHORT $LN6@PointTest2
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\spherelib\spherepack.h

; 209  : 	void * GetUserData(void) const { return mUserData; };

  00009	8b 45 0c	 mov	 eax, DWORD PTR _sphere$[ebp]
  0000c	56		 push	 esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\cullingmanager.h

; 60   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());

  0000d	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00010	57		 push	 edi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\spherelib\spherepack.h

; 209  : 	void * GetUserData(void) const { return mUserData; };

  00011	8b 78 44	 mov	 edi, DWORD PTR [eax+68]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\cameraprocedure.cpp

; 116  : 		if (pOpponent->CollisionDynamicSphere(*m_pdsi))

  00014	8b cf		 mov	 ecx, edi
  00016	ff 76 08	 push	 DWORD PTR [esi+8]
  00019	e8 00 00 00 00	 call	 ?CollisionDynamicSphere@CGraphicObjectInstance@@QBE_NABUCDynamicSphereInstance@@@Z ; CGraphicObjectInstance::CollisionDynamicSphere
  0001e	84 c0		 test	 al, al
  00020	74 13		 je	 SHORT $LN9@PointTest2

; 117  :  		{
; 118  : 			m_pkVct_v3Position->push_back(pOpponent->GetPosition());

  00022	8b cf		 mov	 ecx, edi
  00024	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
  00029	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ?push_back@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXABUD3DXVECTOR3@@@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::push_back

; 119  : 			m_isBlocked = true;

  00032	c6 06 01	 mov	 BYTE PTR [esi], 1
$LN9@PointTest2:
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
$LN6@PointTest2:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\cullingmanager.h

; 62   : 	}

  00037	5d		 pop	 ebp
  00038	c2 0c 00	 ret	 12			; 0000000cH
?PointTest2dCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z ENDP ; RangeTester<CameraCollisionChecker>::PointTest2dCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\spherelib\spherepack.h
;	COMDAT ??_G?$RangeTester@UCameraCollisionChecker@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$RangeTester@UCameraCollisionChecker@@@@UAEPAXI@Z PROC ; RangeTester<CameraCollisionChecker>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 56   : 	virtual ~SpherePackCallback() {}

  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7SpherePackCallback@@6B@
  00010	74 09		 je	 SHORT $LN8@scalar
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	83 c4 04	 add	 esp, 4
$LN8@scalar:
  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
??_G?$RangeTester@UCameraCollisionChecker@@@@UAEPAXI@Z ENDP ; RangeTester<CameraCollisionChecker>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AAUD3DXVECTOR3@@@std@@YAAAUD3DXVECTOR3@@AAU1@@Z
_TEXT	SEGMENT
??$forward@AAUD3DXVECTOR3@@@std@@YAAAUD3DXVECTOR3@@AAU1@@Z PROC ; std::forward<D3DXVECTOR3 &>, COMDAT
; __Arg$ = ecx

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1506 : 	}

  00002	c3		 ret	 0
??$forward@AAUD3DXVECTOR3@@@std@@YAAAUD3DXVECTOR3@@AAU1@@Z ENDP ; std::forward<D3DXVECTOR3 &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@UD3DXVECTOR3@@AAU1@@?$allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAXAAV?$allocator@UD3DXVECTOR3@@@1@PAUD3DXVECTOR3@@AAU3@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@UD3DXVECTOR3@@AAU1@@?$allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAXAAV?$allocator@UD3DXVECTOR3@@@1@PAUD3DXVECTOR3@@AAU3@@Z PROC ; std::allocator_traits<std::allocator<D3DXVECTOR3> >::construct<D3DXVECTOR3,D3DXVECTOR3 &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	85 d2		 test	 edx, edx
  00005	74 11		 je	 SHORT $LN7@construct
  00007	8b 45 08	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000a	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  0000e	66 0f d6 02	 movq	 QWORD PTR [edx], xmm0
  00012	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00015	89 42 08	 mov	 DWORD PTR [edx+8], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??$construct@UD3DXVECTOR3@@AAU1@@?$allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAXAAV?$allocator@UD3DXVECTOR3@@@1@PAUD3DXVECTOR3@@AAU3@@Z ENDP ; std::allocator_traits<std::allocator<D3DXVECTOR3> >::construct<D3DXVECTOR3,D3DXVECTOR3 &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@ABUD3DXVECTOR3@@@std@@YAABUD3DXVECTOR3@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUD3DXVECTOR3@@@std@@YAABUD3DXVECTOR3@@ABU1@@Z PROC ; std::forward<D3DXVECTOR3 const &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABUD3DXVECTOR3@@@std@@YAABUD3DXVECTOR3@@ABU1@@Z ENDP ; std::forward<D3DXVECTOR3 const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@UD3DXVECTOR3@@ABU1@@?$allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAXAAV?$allocator@UD3DXVECTOR3@@@1@PAUD3DXVECTOR3@@ABU3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UD3DXVECTOR3@@ABU1@@?$allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAXAAV?$allocator@UD3DXVECTOR3@@@1@PAUD3DXVECTOR3@@ABU3@@Z PROC ; std::allocator_traits<std::allocator<D3DXVECTOR3> >::construct<D3DXVECTOR3,D3DXVECTOR3 const &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 11		 je	 SHORT $LN7@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00011	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??$construct@UD3DXVECTOR3@@ABU1@@?$allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAXAAV?$allocator@UD3DXVECTOR3@@@1@PAUD3DXVECTOR3@@ABU3@@Z ENDP ; std::allocator_traits<std::allocator<D3DXVECTOR3> >::construct<D3DXVECTOR3,D3DXVECTOR3 const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@UD3DXVECTOR3@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUD3DXVECTOR3@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UD3DXVECTOR3@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUD3DXVECTOR3@@0@Z PROC ; std::_Ptr_cat<D3DXVECTOR3,D3DXVECTOR3>, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@UD3DXVECTOR3@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUD3DXVECTOR3@@0@Z ENDP ; std::_Ptr_cat<D3DXVECTOR3,D3DXVECTOR3>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@YAXPAUD3DXVECTOR3@@0AAU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@YAXPAUD3DXVECTOR3@@0AAU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<D3DXVECTOR3> > >, COMDAT

; 81   : 	for (; _First != _Last; ++_First)
; 82   : 		_Al.destroy(_First);
; 83   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@YAXPAUD3DXVECTOR3@@0AAU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<D3DXVECTOR3> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUD3DXVECTOR3@@PAU1@U?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@YAPAUD3DXVECTOR3@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$1 = 16						; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUD3DXVECTOR3@@PAU1@U?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@YAPAUD3DXVECTOR3@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@0@@Z PROC ; std::_Uninitialized_move<D3DXVECTOR3 *,D3DXVECTOR3 *,std::_Wrap_alloc<std::allocator<D3DXVECTOR3> > >, COMDAT

; 492  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00003	ff 75 10	 push	 DWORD PTR __Cat$1[ebp]
  00006	6a 00		 push	 0
  00008	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0000b	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000e	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00011	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00014	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUD3DXVECTOR3@@PAU1@V?$allocator@UD3DXVECTOR3@@@std@@U1@@std@@YAPAUD3DXVECTOR3@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<D3DXVECTOR3 *,D3DXVECTOR3 *,std::allocator<D3DXVECTOR3>,D3DXVECTOR3>
  00019	83 c4 18	 add	 esp, 24			; 00000018H

; 493  : 	return (_Rechecked(_Dest,
; 494  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 495  : 			_Unchecked(_Dest), _Al)));
; 496  : 	}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Uninitialized_move@PAUD3DXVECTOR3@@PAU1@U?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@YAPAUD3DXVECTOR3@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<D3DXVECTOR3 *,D3DXVECTOR3 *,std::_Wrap_alloc<std::allocator<D3DXVECTOR3> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?construct@?$allocator@UD3DXVECTOR3@@@std@@QAEXPAUD3DXVECTOR3@@ABU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UD3DXVECTOR3@@@std@@QAEXPAUD3DXVECTOR3@@ABU3@@Z PROC ; std::allocator<D3DXVECTOR3>::construct, COMDAT
; _this$ = ecx

; 592  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 11		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000d	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00011	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN3@construct:

; 594  : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
?construct@?$allocator@UD3DXVECTOR3@@@std@@QAEXPAUD3DXVECTOR3@@ABU3@@Z ENDP ; std::allocator<D3DXVECTOR3>::construct
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@UD3DXVECTOR3@@AAU1@@?$allocator@UD3DXVECTOR3@@@std@@QAEXPAUD3DXVECTOR3@@AAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UD3DXVECTOR3@@AAU1@@?$allocator@UD3DXVECTOR3@@@std@@QAEXPAUD3DXVECTOR3@@AAU2@@Z PROC ; std::allocator<D3DXVECTOR3>::construct<D3DXVECTOR3,D3DXVECTOR3 &>, COMDAT
; _this$dead$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 11		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00011	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN3@construct:

; 601  : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
??$construct@UD3DXVECTOR3@@AAU1@@?$allocator@UD3DXVECTOR3@@@std@@QAEXPAUD3DXVECTOR3@@AAU2@@Z ENDP ; std::allocator<D3DXVECTOR3>::construct<D3DXVECTOR3,D3DXVECTOR3 &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@UD3DXVECTOR3@@@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXPAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@UD3DXVECTOR3@@@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXPAUD3DXVECTOR3@@@Z PROC ; std::_Wrap_alloc<std::allocator<D3DXVECTOR3> >::destroy<D3DXVECTOR3>, COMDAT
; _this$ = ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);
; 880  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@UD3DXVECTOR3@@@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXPAUD3DXVECTOR3@@@Z ENDP ; std::_Wrap_alloc<std::allocator<D3DXVECTOR3> >::destroy<D3DXVECTOR3>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAUD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@PAU1@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAUD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@PAU1@@Z PROC ; std::_Unchecked<D3DXVECTOR3 *>, COMDAT

; 280  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 281  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 282  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@PAUD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@PAU1@@Z ENDP ; std::_Unchecked<D3DXVECTOR3 *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAUD3DXVECTOR3@@PAU1@U?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@YAPAUD3DXVECTOR3@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_move@PAUD3DXVECTOR3@@PAU1@U?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@YAPAUD3DXVECTOR3@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@0@@Z PROC ; std::_Uninit_move<D3DXVECTOR3 *,D3DXVECTOR3 *,std::_Wrap_alloc<std::allocator<D3DXVECTOR3> > >, COMDAT

; 482  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 483  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00004	ff 75 fc	 push	 DWORD PTR __Cat$1[ebp]
  00007	6a 00		 push	 0
  00009	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0000c	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000f	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00012	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00015	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUD3DXVECTOR3@@PAU1@V?$allocator@UD3DXVECTOR3@@@std@@U1@@std@@YAPAUD3DXVECTOR3@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<D3DXVECTOR3 *,D3DXVECTOR3 *,std::allocator<D3DXVECTOR3>,D3DXVECTOR3>
  0001a	83 c4 18	 add	 esp, 24			; 00000018H

; 485  : 	}

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??$_Uninit_move@PAUD3DXVECTOR3@@PAU1@U?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@YAPAUD3DXVECTOR3@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@0@@Z ENDP ; std::_Uninit_move<D3DXVECTOR3 *,D3DXVECTOR3 *,std::_Wrap_alloc<std::allocator<D3DXVECTOR3> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAUD3DXVECTOR3@@PAU1@@std@@YAAAPAUD3DXVECTOR3@@AAPAU1@PAU1@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAUD3DXVECTOR3@@PAU1@@std@@YAAAPAUD3DXVECTOR3@@AAPAU1@PAU1@@Z PROC ; std::_Rechecked<D3DXVECTOR3 *,D3DXVECTOR3 *>, COMDAT

; 288  : 	{	// reset checked from unchecked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 289  : 	_Dest = _Src;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Src$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 290  : 	return (_Dest);
; 291  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Rechecked@PAUD3DXVECTOR3@@PAU1@@std@@YAAAPAUD3DXVECTOR3@@AAPAU1@PAU1@@Z ENDP ; std::_Rechecked<D3DXVECTOR3 *,D3DXVECTOR3 *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@UD3DXVECTOR3@@@?$allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAXAAV?$allocator@UD3DXVECTOR3@@@1@PAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@UD3DXVECTOR3@@@?$allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAXAAV?$allocator@UD3DXVECTOR3@@@1@PAUD3DXVECTOR3@@@Z PROC ; std::allocator_traits<std::allocator<D3DXVECTOR3> >::destroy<D3DXVECTOR3>, COMDAT

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);
; 731  : 		}

  00000	c3		 ret	 0
??$destroy@UD3DXVECTOR3@@@?$allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAXAAV?$allocator@UD3DXVECTOR3@@@1@PAUD3DXVECTOR3@@@Z ENDP ; std::allocator_traits<std::allocator<D3DXVECTOR3> >::destroy<D3DXVECTOR3>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAUD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@PAU1@@Z PROC ; std::_Val_type<D3DXVECTOR3 *>, COMDAT

; 646  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 647  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAUD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@PAU1@@Z ENDP ; std::_Val_type<D3DXVECTOR3 *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAUD3DXVECTOR3@@PAU1@V?$allocator@UD3DXVECTOR3@@@std@@U1@@std@@YAPAUD3DXVECTOR3@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUD3DXVECTOR3@@PAU1@V?$allocator@UD3DXVECTOR3@@@std@@U1@@std@@YAPAUD3DXVECTOR3@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<D3DXVECTOR3 *,D3DXVECTOR3 *,std::allocator<D3DXVECTOR3>,D3DXVECTOR3>, COMDAT

; 437  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 443  : 	for (; _First != _Last; ++_Dest, ++_First)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00009	56		 push	 esi
  0000a	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  0000d	3b ce		 cmp	 ecx, esi
  0000f	74 1c		 je	 SHORT $LN4@Uninit_mov
$LL6@Uninit_mov:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00011	85 c0		 test	 eax, eax
  00013	74 0e		 je	 SHORT $LN24@Uninit_mov
  00015	f3 0f 7e 01	 movq	 xmm0, QWORD PTR [ecx]
  00019	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  0001d	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00020	89 50 08	 mov	 DWORD PTR [eax+8], edx
$LN24@Uninit_mov:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 443  : 	for (; _First != _Last; ++_Dest, ++_First)

  00023	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00026	83 c0 0c	 add	 eax, 12			; 0000000cH
  00029	3b ce		 cmp	 ecx, esi
  0002b	75 e4		 jne	 SHORT $LL6@Uninit_mov
$LN4@Uninit_mov:
  0002d	5e		 pop	 esi

; 444  : 		_Al.construct(_Dest, (_Valty&&)*_First);
; 445  : 	_CATCH_ALL
; 446  : 	for (; _Next != _Dest; ++_Next)
; 447  : 		_Al.destroy(_Next);
; 448  : 	_RERAISE;
; 449  : 	_CATCH_END
; 450  : 	return (_Dest);
; 451  : 	}

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
??$_Uninit_move@PAUD3DXVECTOR3@@PAU1@V?$allocator@UD3DXVECTOR3@@@std@@U1@@std@@YAPAUD3DXVECTOR3@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<D3DXVECTOR3 *,D3DXVECTOR3 *,std::allocator<D3DXVECTOR3>,D3DXVECTOR3>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@UD3DXVECTOR3@@@?$allocator@UD3DXVECTOR3@@@std@@QAEXPAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@UD3DXVECTOR3@@@?$allocator@UD3DXVECTOR3@@@std@@QAEXPAUD3DXVECTOR3@@@Z PROC ; std::allocator<D3DXVECTOR3>::destroy<D3DXVECTOR3>, COMDAT
; _this$ = ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@UD3DXVECTOR3@@@?$allocator@UD3DXVECTOR3@@@std@@QAEXPAUD3DXVECTOR3@@@Z ENDP ; std::allocator<D3DXVECTOR3>::destroy<D3DXVECTOR3>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@UD3DXVECTOR3@@U1@@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXPAUD3DXVECTOR3@@$$QAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UD3DXVECTOR3@@U1@@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXPAUD3DXVECTOR3@@$$QAU2@@Z PROC ; std::_Wrap_alloc<std::allocator<D3DXVECTOR3> >::construct<D3DXVECTOR3,D3DXVECTOR3>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 11		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00011	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
??$construct@UD3DXVECTOR3@@U1@@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXPAUD3DXVECTOR3@@$$QAU2@@Z ENDP ; std::_Wrap_alloc<std::allocator<D3DXVECTOR3> >::construct<D3DXVECTOR3,D3DXVECTOR3>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@UD3DXVECTOR3@@@std@@YA$$QAUD3DXVECTOR3@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UD3DXVECTOR3@@@std@@YA$$QAUD3DXVECTOR3@@AAU1@@Z PROC ; std::forward<D3DXVECTOR3>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@UD3DXVECTOR3@@@std@@YA$$QAUD3DXVECTOR3@@AAU1@@Z ENDP ; std::forward<D3DXVECTOR3>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@UD3DXVECTOR3@@U1@@?$allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAXAAV?$allocator@UD3DXVECTOR3@@@1@PAUD3DXVECTOR3@@$$QAU3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UD3DXVECTOR3@@U1@@?$allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAXAAV?$allocator@UD3DXVECTOR3@@@1@PAUD3DXVECTOR3@@$$QAU3@@Z PROC ; std::allocator_traits<std::allocator<D3DXVECTOR3> >::construct<D3DXVECTOR3,D3DXVECTOR3>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 11		 je	 SHORT $LN7@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00011	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??$construct@UD3DXVECTOR3@@U1@@?$allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAXAAV?$allocator@UD3DXVECTOR3@@@1@PAUD3DXVECTOR3@@$$QAU3@@Z ENDP ; std::allocator_traits<std::allocator<D3DXVECTOR3> >::construct<D3DXVECTOR3,D3DXVECTOR3>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@UD3DXVECTOR3@@U1@@?$allocator@UD3DXVECTOR3@@@std@@QAEXPAUD3DXVECTOR3@@$$QAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UD3DXVECTOR3@@U1@@?$allocator@UD3DXVECTOR3@@@std@@QAEXPAUD3DXVECTOR3@@$$QAU2@@Z PROC ; std::allocator<D3DXVECTOR3>::construct<D3DXVECTOR3,D3DXVECTOR3>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 11		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00011	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN3@construct:

; 601  : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
??$construct@UD3DXVECTOR3@@U1@@?$allocator@UD3DXVECTOR3@@@std@@QAEXPAUD3DXVECTOR3@@$$QAU2@@Z ENDP ; std::allocator<D3DXVECTOR3>::construct<D3DXVECTOR3,D3DXVECTOR3>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\spherelib\spherepack.h
;	COMDAT ?GetUserData@SpherePack@@QBEPAXXZ
_TEXT	SEGMENT
?GetUserData@SpherePack@@QBEPAXXZ PROC			; SpherePack::GetUserData, COMDAT
; _this$ = ecx

; 209  : 	void * GetUserData(void) const { return mUserData; };

  00000	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  00003	c3		 ret	 0
?GetUserData@SpherePack@@QBEPAXXZ ENDP			; SpherePack::GetUserData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\spherelib\spherepack.h
;	COMDAT ??1SpherePackCallback@@UAE@XZ
_TEXT	SEGMENT
??1SpherePackCallback@@UAE@XZ PROC			; SpherePackCallback::~SpherePackCallback, COMDAT
; _this$ = ecx

; 56   : 	virtual ~SpherePackCallback() {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7SpherePackCallback@@6B@
  00006	c3		 ret	 0
??1SpherePackCallback@@UAE@XZ ENDP			; SpherePackCallback::~SpherePackCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\spherelib\spherepack.h
;	COMDAT ??_GSpherePackCallback@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GSpherePackCallback@@UAEPAXI@Z PROC			; SpherePackCallback::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 56   : 	virtual ~SpherePackCallback() {}

  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7SpherePackCallback@@6B@
  00010	74 09		 je	 SHORT $LN6@scalar
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	83 c4 04	 add	 esp, 4
$LN6@scalar:
  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
??_GSpherePackCallback@@UAEPAXI@Z ENDP			; SpherePackCallback::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\spherelib\spherepack.h
;	COMDAT ?VisibilityCallback@SpherePackCallback@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z
_TEXT	SEGMENT
_f$ = 8							; size = 4
_sphere$ = 12						; size = 4
_state$ = 16						; size = 4
?VisibilityCallback@SpherePackCallback@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z PROC ; SpherePackCallback::VisibilityCallback, COMDAT
; _this$ = ecx

; 61   : 	{};

  00000	c2 0c 00	 ret	 12			; 0000000cH
?VisibilityCallback@SpherePackCallback@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z ENDP ; SpherePackCallback::VisibilityCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\spherelib\spherepack.h
;	COMDAT ?RayTraceCallback@SpherePackCallback@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z
_TEXT	SEGMENT
_p1$ = 8						; size = 4
_dir$ = 12						; size = 4
_distance$ = 16						; size = 4
_sect$ = 20						; size = 4
_sphere$ = 24						; size = 4
?RayTraceCallback@SpherePackCallback@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z PROC ; SpherePackCallback::RayTraceCallback, COMDAT
; _this$ = ecx

; 68   : 	{};

  00000	c2 14 00	 ret	 20			; 00000014H
?RayTraceCallback@SpherePackCallback@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z ENDP ; SpherePackCallback::RayTraceCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\spherelib\spherepack.h
;	COMDAT ?RangeTestCallback@SpherePackCallback@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z
_TEXT	SEGMENT
_searchpos$ = 8						; size = 4
_distance$ = 12						; size = 4
_sphere$ = 16						; size = 4
_state$ = 20						; size = 4
?RangeTestCallback@SpherePackCallback@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z PROC ; SpherePackCallback::RangeTestCallback, COMDAT
; _this$ = ecx

; 74   : 	{};

  00000	c2 10 00	 ret	 16			; 00000010H
?RangeTestCallback@SpherePackCallback@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z ENDP ; SpherePackCallback::RangeTestCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\spherelib\spherepack.h
;	COMDAT ?PointTest2dCallback@SpherePackCallback@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z
_TEXT	SEGMENT
_searchpos$ = 8						; size = 4
_sphere$ = 12						; size = 4
_state$ = 16						; size = 4
?PointTest2dCallback@SpherePackCallback@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z PROC ; SpherePackCallback::PointTest2dCallback, COMDAT
; _this$ = ecx

; 79   : 	{};

  00000	c2 0c 00	 ret	 12			; 0000000cH
?PointTest2dCallback@SpherePackCallback@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z ENDP ; SpherePackCallback::PointTest2dCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\spherelib\spherepack.h
;	COMDAT ??0SpherePackCallback@@QAE@XZ
_TEXT	SEGMENT
??0SpherePackCallback@@QAE@XZ PROC			; SpherePackCallback::SpherePackCallback, COMDAT
; _this$ = ecx

; 55   : 	SpherePackCallback() {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7SpherePackCallback@@6B@
  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0SpherePackCallback@@QAE@XZ ENDP			; SpherePackCallback::SpherePackCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 44   : 		}

  00000	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv68 = -4						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 686  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 08	 sub	 esp, 8
  00009	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __X$[ebp]

; 687  :     return (float)fabs(_X);

  0000e	0f 5a c0	 cvtps2pd xmm0, xmm0
  00011	66 0f 54 05 00
	00 00 00	 andpd	 xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
  00019	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  0001d	f3 0f 11 44 24
	04		 movss	 DWORD PTR tv68[esp+8], xmm0
  00023	d9 44 24 04	 fld	 DWORD PTR tv68[esp+8]

; 688  : }

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
_fabsf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
;	COMDAT ?fabs@@YAMM@Z
_TEXT	SEGMENT
tv65 = -4						; size = 4
__X$ = 8						; size = 4
?fabs@@YAMM@Z PROC					; fabs, COMDAT

; 1066 :         {return (fabsf(_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 08	 sub	 esp, 8
  00009	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __X$[ebp]

; 687  :     return (float)fabs(_X);

  0000e	0f 5a c0	 cvtps2pd xmm0, xmm0
  00011	66 0f 54 05 00
	00 00 00	 andpd	 xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
  00019	66 0f 5a c0	 cvtpd2ps xmm0, xmm0

; 1066 :         {return (fabsf(_X)); }

  0001d	f3 0f 11 44 24
	04		 movss	 DWORD PTR tv65[esp+8], xmm0
  00023	d9 44 24 04	 fld	 DWORD PTR tv65[esp+8]
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
?fabs@@YAMM@Z ENDP					; fabs
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl
;	COMDAT ??XD3DXVECTOR3@@QAEAAU0@M@Z
_TEXT	SEGMENT
_f$ = 8							; size = 4
??XD3DXVECTOR3@@QAEAAU0@M@Z PROC			; D3DXVECTOR3::operator*=, COMDAT
; _this$ = ecx

; 221  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 222  :     x *= f;

  00003	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]

; 223  :     y *= f;
; 224  :     z *= f;
; 225  :     return *this;

  00007	8b c1		 mov	 eax, ecx
  00009	f3 0f 10 4d 08	 movss	 xmm1, DWORD PTR _f$[ebp]
  0000e	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00012	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0
  00016	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  0001b	f3 0f 59 c1	 mulss	 xmm0, xmm1
  0001f	f3 0f 11 41 04	 movss	 DWORD PTR [ecx+4], xmm0
  00024	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  00029	f3 0f 59 c1	 mulss	 xmm0, xmm1
  0002d	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0

; 226  : }

  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??XD3DXVECTOR3@@QAEAAU0@M@Z ENDP			; D3DXVECTOR3::operator*=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl
;	COMDAT ?D3DXVec3Dot@@YAMPBUD3DXVECTOR3@@0@Z
_TEXT	SEGMENT
_pV1$ = 8						; size = 4
_pV2$ = 12						; size = 4
?D3DXVec3Dot@@YAMPBUD3DXVECTOR3@@0@Z PROC		; D3DXVec3Dot, COMDAT

; 1258 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1259 : #ifdef D3DX_DEBUG
; 1260 :     if(!pV1 || !pV2)
; 1261 :         return 0.0f;
; 1262 : #endif
; 1263 : 
; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _pV1$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR _pV2$[ebp]
  00009	d9 41 04	 fld	 DWORD PTR [ecx+4]
  0000c	d8 48 04	 fmul	 DWORD PTR [eax+4]
  0000f	d9 01		 fld	 DWORD PTR [ecx]
  00011	d8 08		 fmul	 DWORD PTR [eax]
  00013	de c1		 faddp	 ST(1), ST(0)
  00015	d9 41 08	 fld	 DWORD PTR [ecx+8]
  00018	d8 48 08	 fmul	 DWORD PTR [eax+8]
  0001b	de c1		 faddp	 ST(1), ST(0)

; 1265 : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?D3DXVec3Dot@@YAMPBUD3DXVECTOR3@@0@Z ENDP		; D3DXVec3Dot
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl
;	COMDAT ?D3DXVec3Cross@@YAPAUD3DXVECTOR3@@PAU1@PBU1@1@Z
_TEXT	SEGMENT
_v$ = -12						; size = 12
_pOut$ = 8						; size = 4
_pV1$ = 12						; size = 4
_pV2$ = 16						; size = 4
?D3DXVec3Cross@@YAPAUD3DXVECTOR3@@PAU1@PBU1@1@Z PROC	; D3DXVec3Cross, COMDAT

; 1269 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1270 :     D3DXVECTOR3 v;
; 1271 : 
; 1272 : #ifdef D3DX_DEBUG
; 1273 :     if(!pOut || !pV1 || !pV2)
; 1274 :         return NULL;
; 1275 : #endif
; 1276 : 
; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  00006	8b 45 10	 mov	 eax, DWORD PTR _pV2$[ebp]
  00009	8b 4d 0c	 mov	 ecx, DWORD PTR _pV1$[ebp]
  0000c	f3 0f 10 78 08	 movss	 xmm7, DWORD PTR [eax+8]
  00011	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00016	f3 0f 59 41 08	 mulss	 xmm0, DWORD PTR [ecx+8]
  0001b	f3 0f 59 79 04	 mulss	 xmm7, DWORD PTR [ecx+4]

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  00020	f3 0f 10 18	 movss	 xmm3, DWORD PTR [eax]
  00024	f3 0f 10 11	 movss	 xmm2, DWORD PTR [ecx]
  00028	0f 28 cb	 movaps	 xmm1, xmm3
  0002b	f3 0f 59 49 08	 mulss	 xmm1, DWORD PTR [ecx+8]
  00030	f3 0f 5c f8	 subss	 xmm7, xmm0

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  00034	f3 0f 59 59 04	 mulss	 xmm3, DWORD PTR [ecx+4]
  00039	0f 28 c2	 movaps	 xmm0, xmm2
  0003c	f3 0f 59 40 08	 mulss	 xmm0, DWORD PTR [eax+8]
  00041	f3 0f 59 50 04	 mulss	 xmm2, DWORD PTR [eax+4]

; 1280 : 
; 1281 :     *pOut = v;

  00046	8b 45 08	 mov	 eax, DWORD PTR _pOut$[ebp]
  00049	f3 0f 5c c8	 subss	 xmm1, xmm0
  0004d	f3 0f 5c d3	 subss	 xmm2, xmm3
  00051	0f 14 f9	 unpcklps xmm7, xmm1
  00054	66 0f d6 38	 movq	 QWORD PTR [eax], xmm7
  00058	f3 0f 11 55 fc	 movss	 DWORD PTR _v$[ebp+8], xmm2
  0005d	8b 4d fc	 mov	 ecx, DWORD PTR _v$[ebp+8]
  00060	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1282 :     return pOut;
; 1283 : }

  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
?D3DXVec3Cross@@YAPAUD3DXVECTOR3@@PAU1@PBU1@1@Z ENDP	; D3DXVec3Cross
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\spherelib\vector.h
;	COMDAT ?Set@Vector3d@@QAEXMMM@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_c$ = 16						; size = 4
?Set@Vector3d@@QAEXMMM@Z PROC				; Vector3d::Set, COMDAT
; _this$ = ecx

; 106  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 107  : 		x = a;

  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _a$[ebp]
  00008	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0

; 108  : 		y = b;

  0000c	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _b$[ebp]
  00011	f3 0f 11 41 04	 movss	 DWORD PTR [ecx+4], xmm0

; 109  : 		z = c;

  00016	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _c$[ebp]
  0001b	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0

; 110  : 	};

  00020	5d		 pop	 ebp
  00021	c2 0c 00	 ret	 12			; 0000000cH
?Set@Vector3d@@QAEXMMM@Z ENDP				; Vector3d::Set
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\spherelib\vector.h
;	COMDAT ??0Vector3d@@QAE@XZ
_TEXT	SEGMENT
??0Vector3d@@QAE@XZ PROC				; Vector3d::Vector3d, COMDAT
; _this$ = ecx

; 26   : 	Vector3d(void) { };  // null constructor, does not inialize point.

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0Vector3d@@QAE@XZ ENDP				; Vector3d::Vector3d
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv68 = -4						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC						; COMDAT

; 774  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 08	 sub	 esp, 8
  00009	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __X$[ebp]

; 775  :     return (float)sqrt(_X);

  0000e	0f 5a c0	 cvtps2pd xmm0, xmm0
  00011	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
  00016	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0001a	f3 0f 11 44 24
	04		 movss	 DWORD PTR tv68[esp+8], xmm0
  00020	d9 44 24 04	 fld	 DWORD PTR tv68[esp+8]

; 776  : }

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
_sqrtf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl
;	COMDAT ?D3DXVec3Length@@YAMPBUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
tv161 = -4						; size = 4
_pV$ = 8						; size = 4
?D3DXVec3Length@@YAMPBUD3DXVECTOR3@@@Z PROC		; D3DXVec3Length, COMDAT

; 1232 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 08	 sub	 esp, 8

; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);

  00009	8b 45 08	 mov	 eax, DWORD PTR _pV$[ebp]
  0000c	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  00011	f3 0f 10 10	 movss	 xmm2, DWORD PTR [eax]
  00015	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0001a	f3 0f 59 d2	 mulss	 xmm2, xmm2
  0001e	f3 0f 59 c9	 mulss	 xmm1, xmm1
  00022	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00026	f3 0f 58 d1	 addss	 xmm2, xmm1
  0002a	f3 0f 58 d0	 addss	 xmm2, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

  0002e	0f 5a c2	 cvtps2pd xmm0, xmm2
  00031	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
  00036	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl

; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);

  0003a	f3 0f 11 44 24
	04		 movss	 DWORD PTR tv161[esp+8], xmm0
  00040	d9 44 24 04	 fld	 DWORD PTR tv161[esp+8]

; 1240 : #else
; 1241 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1242 : #endif
; 1243 : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?D3DXVec3Length@@YAMPBUD3DXVECTOR3@@@Z ENDP		; D3DXVec3Length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl
;	COMDAT ??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z PROC			; D3DXVECTOR3::operator+, COMDAT
; _this$ = ecx

; 256  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00003	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp]

; 180  :     x = fx;

  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00009	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
  0000d	f3 0f 58 01	 addss	 xmm0, DWORD PTR [ecx]

; 180  :     x = fx;

  00011	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00015	f3 0f 10 42 04	 movss	 xmm0, DWORD PTR [edx+4]
  0001a	f3 0f 58 41 04	 addss	 xmm0, DWORD PTR [ecx+4]

; 181  :     y = fy;

  0001f	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00024	f3 0f 10 42 08	 movss	 xmm0, DWORD PTR [edx+8]
  00029	f3 0f 58 41 08	 addss	 xmm0, DWORD PTR [ecx+8]

; 182  :     z = fz;

  0002e	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 258  : }

  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z ENDP			; D3DXVECTOR3::operator+
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
;	COMDAT _floorf
_TEXT	SEGMENT
tv75 = -8						; size = 4
tv69 = -8						; size = 8
__X$ = 8						; size = 4
_floorf	PROC						; COMDAT

; 700  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 c0	 and	 esp, -64		; ffffffc0H
  00006	83 ec 40	 sub	 esp, 64			; 00000040H
  00009	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __X$[ebp]

; 701  :     return (float)floor(_X);

  0000e	83 ec 08	 sub	 esp, 8
  00011	0f 5a c0	 cvtps2pd xmm0, xmm0
  00014	f2 0f 11 44 24
	40		 movsd	 QWORD PTR tv69[esp+72], xmm0
  0001a	dd 44 24 40	 fld	 QWORD PTR tv69[esp+72]
  0001e	dd 1c 24	 fstp	 QWORD PTR [esp]
  00021	e8 00 00 00 00	 call	 _floor
  00026	d9 5c 24 40	 fstp	 DWORD PTR tv75[esp+72]
  0002a	d9 44 24 40	 fld	 DWORD PTR tv75[esp+72]
  0002e	83 c4 08	 add	 esp, 8

; 702  : }

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
_floorf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl
;	COMDAT ??D@YA?AUD3DXVECTOR3@@MABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_f$ = 12						; size = 4
_v$ = 16						; size = 4
??D@YA?AUD3DXVECTOR3@@MABU0@@Z PROC			; operator*, COMDAT

; 282  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00003	8b 4d 10	 mov	 ecx, DWORD PTR _v$[ebp]
  00006	f3 0f 10 4d 0c	 movss	 xmm1, DWORD PTR _f$[ebp]

; 180  :     x = fx;

  0000b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  0000e	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00012	f3 0f 59 c1	 mulss	 xmm0, xmm1

; 180  :     x = fx;

  00016	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  0001a	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  0001f	f3 0f 59 c1	 mulss	 xmm0, xmm1

; 181  :     y = fy;

  00023	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00028	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  0002d	f3 0f 59 c1	 mulss	 xmm0, xmm1

; 182  :     z = fz;

  00031	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 284  : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
??D@YA?AUD3DXVECTOR3@@MABU0@@Z ENDP			; operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
_fz$ = 16						; size = 4
??0D3DXVECTOR3@@QAE@MMM@Z PROC				; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 179  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 180  :     x = fx;

  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fx$[ebp]

; 181  :     y = fy;
; 182  :     z = fz;
; 183  : }

  00008	8b c1		 mov	 eax, ecx
  0000a	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0
  0000e	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00013	f3 0f 11 41 04	 movss	 DWORD PTR [ecx+4], xmm0
  00018	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0001d	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0
  00022	5d		 pop	 ebp
  00023	c2 0c 00	 ret	 12			; 0000000cH
??0D3DXVECTOR3@@QAE@MMM@Z ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl
;	COMDAT ??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z PROC			; D3DXVECTOR3::operator-, COMDAT
; _this$ = ecx

; 262  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00003	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp]
  00006	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]

; 180  :     x = fx;

  0000a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0000d	f3 0f 5c 02	 subss	 xmm0, DWORD PTR [edx]

; 180  :     x = fx;

  00011	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00015	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  0001a	f3 0f 5c 42 04	 subss	 xmm0, DWORD PTR [edx+4]

; 181  :     y = fy;

  0001f	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00024	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  00029	f3 0f 5c 42 08	 subss	 xmm0, DWORD PTR [edx+8]

; 182  :     z = fz;

  0002e	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 264  : }

  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z ENDP			; D3DXVECTOR3::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.h
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT
??0D3DXVECTOR3@@QAE@XZ PROC				; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 89   :     D3DXVECTOR3() {};

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXVECTOR3@@QAE@XZ ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
END
