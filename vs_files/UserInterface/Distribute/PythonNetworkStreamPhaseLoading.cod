; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	D:\Metin2\Metin2\client_source_clean\client_source_clean\source\UserInterface\PythonNetworkStreamPhaseLoading.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BO@GPONOGFJ@?$CD?$CD?5Network?5?9?5Loading?5Phase?5?$CD?$CD?$AA@ ; `string'
PUBLIC	??_C@_07BINAGFIJ@Loading?$AA@			; `string'
PUBLIC	??_C@_0BK@DINNAMGH@Send?5EnterFrontGamePacket?$AA@ ; `string'
PUBLIC	??_C@_08JHMIFHMN@LoadData?$AA@			; `string'
EXTRN	?DeleteAllInstances@CFlyingManager@@QAEXXZ:PROC	; CFlyingManager::DeleteAllInstances
EXTRN	?DeleteAllInstances@CEffectManager@@QAEXXZ:PROC	; CEffectManager::DeleteAllInstances
;	COMDAT ??_C@_08JHMIFHMN@LoadData?$AA@
CONST	SEGMENT
??_C@_08JHMIFHMN@LoadData?$AA@ DB 'LoadData', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@DINNAMGH@Send?5EnterFrontGamePacket?$AA@
CONST	SEGMENT
??_C@_0BK@DINNAMGH@Send?5EnterFrontGamePacket?$AA@ DB 'Send EnterFrontGam'
	DB	'ePacket', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07BINAGFIJ@Loading?$AA@
CONST	SEGMENT
??_C@_07BINAGFIJ@Loading?$AA@ DB 'Loading', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@GPONOGFJ@?$CD?$CD?5Network?5?9?5Loading?5Phase?5?$CD?$CD?$AA@
CONST	SEGMENT
??_C@_0BO@GPONOGFJ@?$CD?$CD?5Network?5?9?5Loading?5Phase?5?$CD?$CD?$AA@ DB '#'
	DB	'# Network - Loading Phase ##', 00H		; `string'
_gs_fieldMusic_volume DD 03ca3d70br		; 0.02
PUBLIC	?__SetFieldMusicFileInfo@CPythonNetworkStream@@IAEXPBDM@Z ; CPythonNetworkStream::__SetFieldMusicFileInfo
PUBLIC	?__SetFieldMusicFileName@CPythonNetworkStream@@IAEXPBD@Z ; CPythonNetworkStream::__SetFieldMusicFileName
PUBLIC	?RecvMainCharacter4_BGM_VOL@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvMainCharacter4_BGM_VOL
PUBLIC	?RecvMainCharacter3_BGM@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvMainCharacter3_BGM
PUBLIC	?RecvMainCharacter2_EMPIRE@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvMainCharacter2_EMPIRE
PUBLIC	?RecvMainCharacter@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvMainCharacter
PUBLIC	?LoadingPhase@CPythonNetworkStream@@IAEXXZ	; CPythonNetworkStream::LoadingPhase
PUBLIC	?__LeaveLoadingPhase@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__LeaveLoadingPhase
PUBLIC	?__RecvPlayerPoints@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::__RecvPlayerPoints
PUBLIC	?__FilterInsult@CPythonNetworkStream@@IAEXPADI@Z ; CPythonNetworkStream::__FilterInsult
PUBLIC	?StartGame@CPythonNetworkStream@@QAEXXZ		; CPythonNetworkStream::StartGame
PUBLIC	?GetFieldMusicFileName@CPythonNetworkStream@@QAEPBDXZ ; CPythonNetworkStream::GetFieldMusicFileName
PUBLIC	?GetFieldMusicVolume@CPythonNetworkStream@@QAEMXZ ; CPythonNetworkStream::GetFieldMusicVolume
PUBLIC	?EnableChatInsultFilter@CPythonNetworkStream@@QAEX_N@Z ; CPythonNetworkStream::EnableChatInsultFilter
PUBLIC	?IsChatInsultIn@CPythonNetworkStream@@QAE_NPBD@Z ; CPythonNetworkStream::IsChatInsultIn
PUBLIC	?IsInsultIn@CPythonNetworkStream@@QAE_NPBD@Z	; CPythonNetworkStream::IsInsultIn
PUBLIC	?SendEnterGame@CPythonNetworkStream@@QAE_NXZ	; CPythonNetworkStream::SendEnterGame
PUBLIC	?SetLoadingPhase@CPythonNetworkStream@@QAEXXZ	; CPythonNetworkStream::SetLoadingPhase
PUBLIC	?LoadInsultList@CPythonNetworkStream@@QAE_NPBD@Z ; CPythonNetworkStream::LoadInsultList
PUBLIC	?LoadConvertTable@CPythonNetworkStream@@QAE_NKPBD@Z ; CPythonNetworkStream::LoadConvertTable
	ALIGN	4

_piecewise_construct DB 01H DUP (?)
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LoadConvertTable@CPythonNetworkStream@@QAE_NKPBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?LoadConvertTable@CPythonNetworkStream@@QAE_NKPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LoadConvertTable@CPythonNetworkStream@@QAE_NKPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadConvertTable@CPythonNetworkStream@@QAE_NKPBD@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LoadInsultList@CPythonNetworkStream@@QAE_NPBD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?LoadInsultList@CPythonNetworkStream@@QAE_NPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LoadInsultList@CPythonNetworkStream@@QAE_NPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadInsultList@CPythonNetworkStream@@QAE_NPBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadInsultList@CPythonNetworkStream@@QAE_NPBD@Z$1
_gs_fieldMusic_fileName DB 00H
	DB	15 DUP(00H)
	DD	00H
	DD	0fH
_gs_fieldMusic_fileName$initializer$ DD FLAT:??__Egs_fieldMusic_fileName@@YAXXZ
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphaseloading.cpp
;	COMDAT ?LoadConvertTable@CPythonNetworkStream@@QAE_NKPBD@Z
_TEXT	SEGMENT
_pvData$ = -344						; size = 4
_file$ = -340						; size = 324
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_dwEmpireID$ = 8					; size = 4
_c_szFileName$ = 12					; size = 4
?LoadConvertTable@CPythonNetworkStream@@QAE_NKPBD@Z PROC ; CPythonNetworkStream::LoadConvertTable, COMDAT
; _this$ = ecx

; 54   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?LoadConvertTable@CPythonNetworkStream@@QAE_NKPBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 4c 01 00
	00		 sub	 esp, 332		; 0000014cH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	8b d9		 mov	 ebx, ecx
  00030	8b 75 08	 mov	 esi, DWORD PTR _dwEmpireID$[ebp]
  00033	8b 7d 0c	 mov	 edi, DWORD PTR _c_szFileName$[ebp]

; 55   : 	if (dwEmpireID<1 || dwEmpireID>=4)

  00036	8d 46 ff	 lea	 eax, DWORD PTR [esi-1]
  00039	83 f8 02	 cmp	 eax, 2
  0003c	0f 87 9f 00 00
	00		 ja	 $LN3@LoadConver

; 57   : 
; 58   : 	CMappedFile file;

  00042	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR _file$[ebp]
  00048	e8 00 00 00 00	 call	 ??0CMappedFile@@QAE@XZ	; CMappedFile::CMappedFile

; 59   : 	const VOID* pvData;
; 60   : 	if (!CEterPackManager::Instance().Get(file, c_szFileName, &pvData))

  0004d	8d 85 a8 fe ff
	ff		 lea	 eax, DWORD PTR _pvData$[ebp]
  00053	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0005a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A ; CSingleton<CEterPackManager>::ms_singleton
  00060	50		 push	 eax
  00061	57		 push	 edi
  00062	8d 85 ac fe ff
	ff		 lea	 eax, DWORD PTR _file$[ebp]
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 ?Get@CEterPackManager@@QAE_NAAVCMappedFile@@PBDPAPBX@Z ; CEterPackManager::Get
  0006e	84 c0		 test	 al, al
  00070	74 57		 je	 SHORT $LN8@LoadConver

; 61   : 		return false;
; 62   : 
; 63   : 	DWORD dwEngCount=26;
; 64   : 	DWORD dwHanCount=(0xc8-0xb0+1)*(0xfe-0xa1+1);
; 65   : 	DWORD dwHanSize=dwHanCount*2;
; 66   : 	DWORD dwFileSize=dwEngCount*2+dwHanSize;
; 67   : 
; 68   : 	if (file.Size()<dwFileSize)

  00072	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR _file$[ebp]
  00078	e8 00 00 00 00	 call	 ?Size@CMappedFile@@QAEKXZ ; CMappedFile::Size
  0007d	3d 90 12 00 00	 cmp	 eax, 4752		; 00001290H
  00082	72 45		 jb	 SHORT $LN8@LoadConver

; 69   : 		return false;
; 70   : 
; 71   : 	char* pcData=(char*)pvData;
; 72   : 
; 73   : 	STextConvertTable& rkTextConvTable=m_aTextConvTable[dwEmpireID-1];		

  00084	69 fe 44 27 00
	00		 imul	 edi, esi, 10052

; 74   : 	memcpy(rkTextConvTable.acUpper, pcData, dwEngCount);pcData+=dwEngCount;

  0008a	8b b5 a8 fe ff
	ff		 mov	 esi, DWORD PTR _pvData$[ebp]
  00090	6a 1a		 push	 26			; 0000001aH
  00092	56		 push	 esi
  00093	81 c7 e8 db ff
	ff		 add	 edi, -9240		; ffffdbe8H
  00099	03 fb		 add	 edi, ebx
  0009b	57		 push	 edi
  0009c	e8 00 00 00 00	 call	 _memcpy

; 75   : 	memcpy(rkTextConvTable.acLower, pcData, dwEngCount);pcData+=dwEngCount;

  000a1	6a 1a		 push	 26			; 0000001aH
  000a3	83 c6 1a	 add	 esi, 26			; 0000001aH
  000a6	8d 47 1a	 lea	 eax, DWORD PTR [edi+26]
  000a9	56		 push	 esi
  000aa	50		 push	 eax
  000ab	e8 00 00 00 00	 call	 _memcpy

; 76   : 	memcpy(rkTextConvTable.aacHan, pcData, dwHanSize);

  000b0	68 5c 12 00 00	 push	 4700			; 0000125cH
  000b5	83 c6 1a	 add	 esi, 26			; 0000001aH
  000b8	8d 47 34	 lea	 eax, DWORD PTR [edi+52]
  000bb	56		 push	 esi
  000bc	50		 push	 eax
  000bd	e8 00 00 00 00	 call	 _memcpy
  000c2	83 c4 24	 add	 esp, 36			; 00000024H

; 77   : 
; 78   : 	return true;

  000c5	b3 01		 mov	 bl, 1
  000c7	eb 02		 jmp	 SHORT $LN9@LoadConver
$LN8@LoadConver:
  000c9	32 db		 xor	 bl, bl
$LN9@LoadConver:
  000cb	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR _file$[ebp]
  000d1	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000d8	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  000dd	8a c3		 mov	 al, bl
  000df	eb 02		 jmp	 SHORT $LN5@LoadConver
$LN3@LoadConver:

; 56   : 		return false;

  000e1	32 c0		 xor	 al, al
$LN5@LoadConver:

; 79   : }

  000e3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000e6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ed	59		 pop	 ecx
  000ee	5f		 pop	 edi
  000ef	5e		 pop	 esi
  000f0	5b		 pop	 ebx
  000f1	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f4	33 cd		 xor	 ecx, ebp
  000f6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000fb	8b e5		 mov	 esp, ebp
  000fd	5d		 pop	 ebp
  000fe	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LoadConvertTable@CPythonNetworkStream@@QAE_NKPBD@Z$0:
  00000	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR _file$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
__ehhandler$?LoadConvertTable@CPythonNetworkStream@@QAE_NKPBD@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a a4 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-348]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?LoadConvertTable@CPythonNetworkStream@@QAE_NKPBD@Z
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?LoadConvertTable@CPythonNetworkStream@@QAE_NKPBD@Z ENDP ; CPythonNetworkStream::LoadConvertTable
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphaseloading.cpp
;	COMDAT ?LoadInsultList@CPythonNetworkStream@@QAE_NPBD@Z
_TEXT	SEGMENT
_pvData$ = -372						; size = 4
_kMemTextFileLoader$ = -368				; size = 16
_file$ = -352						; size = 324
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_c_szInsultListFileName$ = 8				; size = 4
?LoadInsultList@CPythonNetworkStream@@QAE_NPBD@Z PROC	; CPythonNetworkStream::LoadInsultList, COMDAT
; _this$ = ecx

; 35   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?LoadInsultList@CPythonNetworkStream@@QAE_NPBD@Z
  0000d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00013	50		 push	 eax
  00014	81 ec 68 01 00
	00		 sub	 esp, 360		; 00000168H
  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001f	33 c4		 xor	 eax, esp
  00021	89 84 24 60 01
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+372], eax
  00028	53		 push	 ebx
  00029	56		 push	 esi
  0002a	57		 push	 edi
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c4		 xor	 eax, esp
  00032	50		 push	 eax
  00033	8d 84 24 78 01
	00 00		 lea	 eax, DWORD PTR __$EHRec$[esp+388]
  0003a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00040	8b f9		 mov	 edi, ecx
  00042	8b 75 08	 mov	 esi, DWORD PTR _c_szInsultListFileName$[ebp]

; 36   : 	CMappedFile file;

  00045	8d 4c 24 24	 lea	 ecx, DWORD PTR _file$[esp+388]
  00049	e8 00 00 00 00	 call	 ??0CMappedFile@@QAE@XZ	; CMappedFile::CMappedFile

; 37   : 	const VOID* pvData;
; 38   : 	if (!CEterPackManager::Instance().Get(file, c_szInsultListFileName, &pvData))

  0004e	8d 44 24 10	 lea	 eax, DWORD PTR _pvData$[esp+388]
  00052	c7 84 24 80 01
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+396], 0
  0005d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A ; CSingleton<CEterPackManager>::ms_singleton
  00063	50		 push	 eax
  00064	56		 push	 esi
  00065	8d 44 24 2c	 lea	 eax, DWORD PTR _file$[esp+396]
  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 ?Get@CEterPackManager@@QAE_NAAVCMappedFile@@PBDPAPBX@Z ; CEterPackManager::Get
  0006f	84 c0		 test	 al, al
  00071	75 07		 jne	 SHORT $LN4@LoadInsult
  00073	32 db		 xor	 bl, bl
  00075	e9 7d 00 00 00	 jmp	 $LN9@LoadInsult
$LN4@LoadInsult:

; 39   : 		return false;
; 40   : 
; 41   : 	CMemoryTextFileLoader kMemTextFileLoader;

  0007a	8d 4c 24 14	 lea	 ecx, DWORD PTR _kMemTextFileLoader$[esp+388]
  0007e	e8 00 00 00 00	 call	 ??0CMemoryTextFileLoader@@QAE@XZ ; CMemoryTextFileLoader::CMemoryTextFileLoader
  00083	c6 84 24 80 01
	00 00 01	 mov	 BYTE PTR __$EHRec$[esp+396], 1

; 42   : 	kMemTextFileLoader.Bind(file.Size(), pvData);

  0008b	8d 4c 24 24	 lea	 ecx, DWORD PTR _file$[esp+388]
  0008f	ff 74 24 10	 push	 DWORD PTR _pvData$[esp+388]
  00093	e8 00 00 00 00	 call	 ?Size@CMappedFile@@QAEKXZ ; CMappedFile::Size
  00098	50		 push	 eax
  00099	8d 4c 24 1c	 lea	 ecx, DWORD PTR _kMemTextFileLoader$[esp+396]
  0009d	e8 00 00 00 00	 call	 ?Bind@CMemoryTextFileLoader@@QAEXHPBX@Z ; CMemoryTextFileLoader::Bind

; 43   : 
; 44   : 	m_kInsultChecker.Clear();

  000a2	8d 8f 14 79 00
	00		 lea	 ecx, DWORD PTR [edi+30996]
  000a8	e8 00 00 00 00	 call	 ?Clear@CInsultChecker@@QAEXXZ ; CInsultChecker::Clear

; 45   : 	for (DWORD dwLineIndex=0; dwLineIndex<kMemTextFileLoader.GetLineCount(); ++dwLineIndex)

  000ad	8d 4c 24 14	 lea	 ecx, DWORD PTR _kMemTextFileLoader$[esp+388]
  000b1	33 f6		 xor	 esi, esi
  000b3	e8 00 00 00 00	 call	 ?GetLineCount@CMemoryTextFileLoader@@QAEKXZ ; CMemoryTextFileLoader::GetLineCount
  000b8	85 c0		 test	 eax, eax
  000ba	74 28		 je	 SHORT $LN1@LoadInsult
  000bc	8d 64 24 00	 npad	 4
$LL3@LoadInsult:

; 46   : 	{
; 47   : 		const std::string& c_rstLine=kMemTextFileLoader.GetLineString(dwLineIndex);		

  000c0	56		 push	 esi
  000c1	8d 4c 24 18	 lea	 ecx, DWORD PTR _kMemTextFileLoader$[esp+392]
  000c5	e8 00 00 00 00	 call	 ?GetLineString@CMemoryTextFileLoader@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; CMemoryTextFileLoader::GetLineString

; 48   : 		m_kInsultChecker.AppendInsult(c_rstLine);

  000ca	50		 push	 eax
  000cb	8d 8f 14 79 00
	00		 lea	 ecx, DWORD PTR [edi+30996]
  000d1	e8 00 00 00 00	 call	 ?AppendInsult@CInsultChecker@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CInsultChecker::AppendInsult
  000d6	8d 4c 24 14	 lea	 ecx, DWORD PTR _kMemTextFileLoader$[esp+388]
  000da	46		 inc	 esi
  000db	e8 00 00 00 00	 call	 ?GetLineCount@CMemoryTextFileLoader@@QAEKXZ ; CMemoryTextFileLoader::GetLineCount
  000e0	3b f0		 cmp	 esi, eax
  000e2	72 dc		 jb	 SHORT $LL3@LoadInsult
$LN1@LoadInsult:

; 49   : 	}
; 50   : 	return true;

  000e4	8d 4c 24 14	 lea	 ecx, DWORD PTR _kMemTextFileLoader$[esp+388]
  000e8	c6 84 24 80 01
	00 00 00	 mov	 BYTE PTR __$EHRec$[esp+396], 0
  000f0	b3 01		 mov	 bl, 1
  000f2	e8 00 00 00 00	 call	 ??1CMemoryTextFileLoader@@UAE@XZ ; CMemoryTextFileLoader::~CMemoryTextFileLoader
$LN9@LoadInsult:
  000f7	8d 4c 24 24	 lea	 ecx, DWORD PTR _file$[esp+388]
  000fb	c7 84 24 80 01
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+396], -1
  00106	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  0010b	8a c3		 mov	 al, bl

; 51   : }

  0010d	8b 8c 24 78 01
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+388]
  00114	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0011b	59		 pop	 ecx
  0011c	5f		 pop	 edi
  0011d	5e		 pop	 esi
  0011e	5b		 pop	 ebx
  0011f	8b 8c 24 60 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+372]
  00126	33 cc		 xor	 ecx, esp
  00128	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0012d	8b e5		 mov	 esp, ebp
  0012f	5d		 pop	 ebp
  00130	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LoadInsultList@CPythonNetworkStream@@QAE_NPBD@Z$0:
  00000	8d 8d a0 fe ff
	ff		 lea	 ecx, DWORD PTR _file$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
__unwindfunclet$?LoadInsultList@CPythonNetworkStream@@QAE_NPBD@Z$1:
  0000b	8d 8d 90 fe ff
	ff		 lea	 ecx, DWORD PTR _kMemTextFileLoader$[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1CMemoryTextFileLoader@@UAE@XZ ; CMemoryTextFileLoader::~CMemoryTextFileLoader
__ehhandler$?LoadInsultList@CPythonNetworkStream@@QAE_NPBD@Z:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 82 8c fe ff
	ff		 lea	 eax, DWORD PTR [edx-372]
  00020	8b 8a 88 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-376]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	83 c0 0c	 add	 eax, 12			; 0000000cH
  00030	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00033	33 c8		 xor	 ecx, eax
  00035	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?LoadInsultList@CPythonNetworkStream@@QAE_NPBD@Z
  0003f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?LoadInsultList@CPythonNetworkStream@@QAE_NPBD@Z ENDP	; CPythonNetworkStream::LoadInsultList
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphaseloading.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphaseloading.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\funcobject.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphaseloading.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphaseloading.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\funcobject.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphaseloading.cpp
;	COMDAT ?SetLoadingPhase@CPythonNetworkStream@@QAEXXZ
_TEXT	SEGMENT
?SetLoadingPhase@CPythonNetworkStream@@QAEXXZ PROC	; CPythonNetworkStream::SetLoadingPhase, COMDAT
; _this$ = ecx

; 170  : {

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));

  00005	6a 07		 push	 7
  00007	68 00 00 00 00	 push	 OFFSET ??_C@_07BINAGFIJ@Loading?$AA@
  0000c	ff b6 1c 01 00
	00		 push	 DWORD PTR [esi+284]
  00012	8d 8e 0c 01 00
	00		 lea	 ecx, DWORD PTR [esi+268]
  00018	6a 00		 push	 0
  0001a	e8 00 00 00 00	 call	 ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare

; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());
; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;
; 2285 : 		_Eos(_Newsize);
; 2286 : 		}
; 2287 : 
; 2288 : 	__declspec(noreturn) void _Xlen() const
; 2289 : 		{	// report a length_error
; 2290 : 		_Xlength_error("string too long");
; 2291 : 		}
; 2292 : 
; 2293 : 	__declspec(noreturn) void _Xran() const
; 2294 : 		{	// report an out_of_range error
; 2295 : 		_Xout_of_range("invalid string position");
; 2296 : 		}
; 2297 : 	};
; 2298 : 
; 2299 : 		// STATIC npos OBJECT
; 2300 : template<class _Elem,
; 2301 : 	class _Traits,
; 2302 : 	class _Alloc>
; 2303 : 	_PGLOBAL const typename basic_string<_Elem, _Traits, _Alloc>::size_type
; 2304 : 		basic_string<_Elem, _Traits, _Alloc>::npos =
; 2305 : 			(typename basic_string<_Elem, _Traits, _Alloc>::size_type)(-1);
; 2306 : 
; 2307 : 		// basic_string TEMPLATE OPERATORS
; 2308 : 
; 2309 : template<class _Elem,
; 2310 : 	class _Traits,
; 2311 : 	class _Alloc> inline
; 2312 : 	void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2313 : 		basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2314 : 	{	// swap _Left and _Right strings
; 2315 : 	_Left.swap(_Right);
; 2316 : 	}
; 2317 : 
; 2318 : template<class _Elem,
; 2319 : 	class _Traits,
; 2320 : 	class _Alloc> inline
; 2321 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2322 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2323 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2324 : 	{	// return string + string
; 2325 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2326 : 	_Ans.reserve(_Left.size() + _Right.size());
; 2327 : 	_Ans += _Left;
; 2328 : 	_Ans += _Right;
; 2329 : 	return (_Ans);
; 2330 : 	}
; 2331 : 
; 2332 : template<class _Elem,
; 2333 : 	class _Traits,
; 2334 : 	class _Alloc> inline
; 2335 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2336 : 		const _Elem *_Left,
; 2337 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2338 : 	{	// return NTCS + string
; 2339 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2340 : 	_Ans.reserve(_Traits::length(_Left) + _Right.size());
; 2341 : 	_Ans += _Left;
; 2342 : 	_Ans += _Right;
; 2343 : 	return (_Ans);
; 2344 : 	}
; 2345 : 
; 2346 : template<class _Elem,
; 2347 : 	class _Traits,
; 2348 : 	class _Alloc> inline
; 2349 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2350 : 		const _Elem _Left,
; 2351 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2352 : 	{	// return character + string
; 2353 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2354 : 	_Ans.reserve(1 + _Right.size());
; 2355 : 	_Ans += _Left;
; 2356 : 	_Ans += _Right;
; 2357 : 	return (_Ans);
; 2358 : 	}
; 2359 : 
; 2360 : template<class _Elem,
; 2361 : 	class _Traits,
; 2362 : 	class _Alloc> inline
; 2363 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2364 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2365 : 		const _Elem *_Right)
; 2366 : 	{	// return string + NTCS
; 2367 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2368 : 	_Ans.reserve(_Left.size() + _Traits::length(_Right));
; 2369 : 	_Ans += _Left;
; 2370 : 	_Ans += _Right;
; 2371 : 	return (_Ans);
; 2372 : 	}
; 2373 : 
; 2374 : template<class _Elem,
; 2375 : 	class _Traits,
; 2376 : 	class _Alloc> inline
; 2377 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2378 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2379 : 		const _Elem _Right)
; 2380 : 	{	// return string + character
; 2381 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2382 : 	_Ans.reserve(_Left.size() + 1);
; 2383 : 	_Ans += _Left;
; 2384 : 	_Ans += _Right;
; 2385 : 	return (_Ans);
; 2386 : 	}
; 2387 : 
; 2388 : template<class _Elem,
; 2389 : 	class _Traits,
; 2390 : 	class _Alloc> inline
; 2391 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2392 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2393 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2394 : 	{	// return string + string
; 2395 : 	return (_STD move(_Right.insert(0, _Left)));
; 2396 : 	}
; 2397 : 
; 2398 : template<class _Elem,
; 2399 : 	class _Traits,
; 2400 : 	class _Alloc> inline
; 2401 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2402 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2403 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2404 : 	{	// return string + string
; 2405 : 	return (_STD move(_Left.append(_Right)));
; 2406 : 	}
; 2407 : 
; 2408 : template<class _Elem,
; 2409 : 	class _Traits,
; 2410 : 	class _Alloc> inline
; 2411 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2412 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2413 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2414 : 	{	// return string + string
; 2415 : 	if (_Right.size() <= _Left.capacity() - _Left.size()
; 2416 : 		|| _Right.capacity() - _Right.size() < _Left.size())
; 2417 : 		return (_STD move(_Left.append(_Right)));
; 2418 : 	else
; 2419 : 		return (_STD move(_Right.insert(0, _Left)));
; 2420 : 	}
; 2421 : 
; 2422 : template<class _Elem,
; 2423 : 	class _Traits,
; 2424 : 	class _Alloc> inline
; 2425 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2426 : 		const _Elem *_Left,
; 2427 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2428 : 	{	// return NTCS + string
; 2429 : 	return (_STD move(_Right.insert(0, _Left)));
; 2430 : 	}
; 2431 : 
; 2432 : template<class _Elem,
; 2433 : 	class _Traits,
; 2434 : 	class _Alloc> inline
; 2435 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2436 : 		const _Elem _Left,
; 2437 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2438 : 	{	// return character + string
; 2439 : 	return (_STD move(_Right.insert(0, 1, _Left)));
; 2440 : 	}
; 2441 : 
; 2442 : template<class _Elem,
; 2443 : 	class _Traits,
; 2444 : 	class _Alloc> inline
; 2445 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2446 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2447 : 		const _Elem *_Right)
; 2448 : 	{	// return string + NTCS
; 2449 : 	return (_STD move(_Left.append(_Right)));
; 2450 : 	}
; 2451 : 
; 2452 : template<class _Elem,
; 2453 : 	class _Traits,
; 2454 : 	class _Alloc> inline
; 2455 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2456 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2457 : 		const _Elem _Right)
; 2458 : 	{	// return string + character
; 2459 : 	return (_STD move(_Left.append(1, _Right)));
; 2460 : 	}
; 2461 : 
; 2462 : template<class _Elem,
; 2463 : 	class _Traits,
; 2464 : 	class _Alloc> inline
; 2465 : 	bool operator==(
; 2466 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2467 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2468 : 	{	// test for string equality
; 2469 : 	return (_Left.compare(_Right) == 0);
; 2470 : 	}
; 2471 : 
; 2472 : template<class _Elem,
; 2473 : 	class _Traits,
; 2474 : 	class _Alloc> inline
; 2475 : 	bool operator==(
; 2476 : 		const _Elem * _Left,
; 2477 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2478 : 	{	// test for NTCS vs. string equality
; 2479 : 	return (_Right.compare(_Left) == 0);

  0001f	85 c0		 test	 eax, eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphaseloading.cpp

; 171  : 	if ("Loading"!=m_strPhase)

  00021	74 1e		 je	 SHORT $LN14@SetLoading
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\funcobject.h

; 41   : 			if (m_pSelfObject)

  00023	8b 96 68 01 00
	00		 mov	 edx, DWORD PTR [esi+360]
  00029	85 d2		 test	 edx, edx
  0002b	74 14		 je	 SHORT $LN14@SetLoading

; 42   : 				if (m_pFuncObject)

  0002d	8b 86 70 01 00
	00		 mov	 eax, DWORD PTR [esi+368]
  00033	85 c0		 test	 eax, eax
  00035	74 0a		 je	 SHORT $LN14@SetLoading

; 43   : 					(m_pSelfObject->*m_pFuncObject)();

  00037	8b 8e 74 01 00
	00		 mov	 ecx, DWORD PTR [esi+372]
  0003d	03 ca		 add	 ecx, edx
  0003f	ff d0		 call	 eax
$LN14@SetLoading:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphaseloading.cpp

; 174  : 	Tracen("");

  00041	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00046	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  0004b	83 c4 04	 add	 esp, 4

; 175  : 	Tracen("## Network - Loading Phase ##");

  0004e	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@GPONOGFJ@?$CD?$CD?5Network?5?9?5Loading?5Phase?5?$CD?$CD?$AA@
  00053	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  00058	83 c4 04	 add	 esp, 4

; 176  : 	Tracen("");

  0005b	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00060	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  00065	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00068	8d 8e 0c 01 00
	00		 lea	 ecx, DWORD PTR [esi+268]
  0006e	6a 07		 push	 7
  00070	68 00 00 00 00	 push	 OFFSET ??_C@_07BINAGFIJ@Loading?$AA@
  00075	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphaseloading.cpp

; 180  : 	m_dwChangingPhaseTime = ELTimer_GetMSec();

  0007a	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec

; 185  : 	rkPlayer.Clear();

  0007f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  00085	89 86 90 00 00
	00		 mov	 DWORD PTR [esi+144], eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\funcobject.h

; 24   : 			m_pSelfObject = pSelfObject;

  0008b	89 b6 50 01 00
	00		 mov	 DWORD PTR [esi+336], esi

; 25   : 			m_pFuncObject = pFuncObject;

  00091	c7 86 58 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+344], OFFSET ?LoadingPhase@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::LoadingPhase
  0009b	c7 86 5c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+348], 0

; 24   : 			m_pSelfObject = pSelfObject;

  000a5	89 b6 68 01 00
	00		 mov	 DWORD PTR [esi+360], esi

; 25   : 			m_pFuncObject = pFuncObject;

  000ab	c7 86 70 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+368], OFFSET ?__LeaveLoadingPhase@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__LeaveLoadingPhase
  000b5	c7 86 74 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+372], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphaseloading.cpp

; 185  : 	rkPlayer.Clear();

  000bf	e8 00 00 00 00	 call	 ?Clear@CPythonPlayer@@QAEXXZ ; CPythonPlayer::Clear

; 186  : 
; 187  : 	CFlyingManager::Instance().DeleteAllInstances();

  000c4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCFlyingManager@@@@0PAVCFlyingManager@@A ; CSingleton<CFlyingManager>::ms_singleton
  000ca	e8 00 00 00 00	 call	 ?DeleteAllInstances@CFlyingManager@@QAEXXZ ; CFlyingManager::DeleteAllInstances

; 188  : 	CEffectManager::Instance().DeleteAllInstances();

  000cf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCEffectManager@@@@0PAVCEffectManager@@A ; CSingleton<CEffectManager>::ms_singleton
  000d5	e8 00 00 00 00	 call	 ?DeleteAllInstances@CEffectManager@@QAEXXZ ; CEffectManager::DeleteAllInstances

; 189  : 
; 190  : 	__DirectEnterMode_Initialize();

  000da	8b ce		 mov	 ecx, esi
  000dc	e8 00 00 00 00	 call	 ?__DirectEnterMode_Initialize@CPythonNetworkStream@@AAEXXZ ; CPythonNetworkStream::__DirectEnterMode_Initialize

; 191  : }

  000e1	5f		 pop	 edi
  000e2	5e		 pop	 esi
  000e3	59		 pop	 ecx
  000e4	c3		 ret	 0
?SetLoadingPhase@CPythonNetworkStream@@QAEXXZ ENDP	; CPythonNetworkStream::SetLoadingPhase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphaseloading.cpp
;	COMDAT ?SendEnterGame@CPythonNetworkStream@@QAE_NXZ
_TEXT	SEGMENT
_EnterFrontGamePacket$ = -1				; size = 1
?SendEnterGame@CPythonNetworkStream@@QAE_NXZ PROC	; CPythonNetworkStream::SendEnterGame, COMDAT
; _this$ = ecx

; 345  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 346  : 	TPacketCGEnterFrontGame EnterFrontGamePacket;
; 347  : 
; 348  : 	EnterFrontGamePacket.header = HEADER_CG_ENTERGAME;
; 349  : 
; 350  : 	if (!Send(sizeof(EnterFrontGamePacket), &EnterFrontGamePacket))

  00005	8d 45 ff	 lea	 eax, DWORD PTR _EnterFrontGamePacket$[ebp]
  00008	c6 45 ff 0a	 mov	 BYTE PTR _EnterFrontGamePacket$[ebp], 10 ; 0000000aH
  0000c	50		 push	 eax
  0000d	6a 01		 push	 1
  0000f	8b f1		 mov	 esi, ecx
  00011	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00016	84 c0		 test	 al, al
  00018	75 14		 jne	 SHORT $LN2@SendEnterG

; 351  : 	{
; 352  : 		Tracen("Send EnterFrontGamePacket");

  0001a	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@DINNAMGH@Send?5EnterFrontGamePacket?$AA@
  0001f	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  00024	83 c4 04	 add	 esp, 4
$LN5@SendEnterG:

; 353  : 		return false;

  00027	32 c0		 xor	 al, al
  00029	5e		 pop	 esi

; 361  : }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
$LN2@SendEnterG:

; 354  : 	}
; 355  : 
; 356  : 	if (!SendSequence())

  0002e	8b ce		 mov	 ecx, esi
  00030	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
  00035	84 c0		 test	 al, al
  00037	74 ee		 je	 SHORT $LN5@SendEnterG

; 357  : 		return false;
; 358  : 
; 359  : 	__SendInternalBuffer();

  00039	8b ce		 mov	 ecx, esi
  0003b	e8 00 00 00 00	 call	 ?__SendInternalBuffer@CNetworkStream@@IAE_NXZ ; CNetworkStream::__SendInternalBuffer

; 360  : 	return true;

  00040	b0 01		 mov	 al, 1
  00042	5e		 pop	 esi

; 361  : }

  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
?SendEnterGame@CPythonNetworkStream@@QAE_NXZ ENDP	; CPythonNetworkStream::SendEnterGame
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphaseloading.cpp
;	COMDAT ?IsInsultIn@CPythonNetworkStream@@QAE_NPBD@Z
_TEXT	SEGMENT
_c_szMsg$ = 8						; size = 4
?IsInsultIn@CPythonNetworkStream@@QAE_NPBD@Z PROC	; CPythonNetworkStream::IsInsultIn, COMDAT
; _this$ = ecx

; 30   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	return m_kInsultChecker.IsInsultIn(c_szMsg, strlen(c_szMsg));

  00003	8b 55 08	 mov	 edx, DWORD PTR _c_szMsg$[ebp]
  00006	8b c2		 mov	 eax, edx
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b f1		 mov	 esi, ecx
  0000c	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0000f	90		 npad	 1
$LL3@IsInsultIn:
  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 c9		 test	 cl, cl
  00015	75 f9		 jne	 SHORT $LL3@IsInsultIn
  00017	2b c7		 sub	 eax, edi
  00019	8d 8e 14 79 00
	00		 lea	 ecx, DWORD PTR [esi+30996]
  0001f	50		 push	 eax
  00020	52		 push	 edx
  00021	e8 00 00 00 00	 call	 ?IsInsultIn@CInsultChecker@@QAE_NPBDI@Z ; CInsultChecker::IsInsultIn
  00026	5f		 pop	 edi
  00027	5e		 pop	 esi

; 32   : }

  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
?IsInsultIn@CPythonNetworkStream@@QAE_NPBD@Z ENDP	; CPythonNetworkStream::IsInsultIn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphaseloading.cpp
;	COMDAT ?IsChatInsultIn@CPythonNetworkStream@@QAE_NPBD@Z
_TEXT	SEGMENT
_c_szMsg$ = 8						; size = 4
?IsChatInsultIn@CPythonNetworkStream@@QAE_NPBD@Z PROC	; CPythonNetworkStream::IsChatInsultIn, COMDAT
; _this$ = ecx

; 22   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 23   : 	if (m_isEnableChatInsultFilter)

  00003	80 b9 20 79 00
	00 00		 cmp	 BYTE PTR [ecx+31008], 0
  0000a	74 06		 je	 SHORT $LN1@IsChatInsu

; 24   : 		return false;

  0000c	32 c0		 xor	 al, al

; 27   : }

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
$LN1@IsChatInsu:
  00012	5d		 pop	 ebp

; 25   : 
; 26   : 	return IsInsultIn(c_szMsg);

  00013	e9 00 00 00 00	 jmp	 ?IsInsultIn@CPythonNetworkStream@@QAE_NPBD@Z ; CPythonNetworkStream::IsInsultIn
?IsChatInsultIn@CPythonNetworkStream@@QAE_NPBD@Z ENDP	; CPythonNetworkStream::IsChatInsultIn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphaseloading.cpp
;	COMDAT ?EnableChatInsultFilter@CPythonNetworkStream@@QAEX_N@Z
_TEXT	SEGMENT
_isEnable$ = 8						; size = 1
?EnableChatInsultFilter@CPythonNetworkStream@@QAEX_N@Z PROC ; CPythonNetworkStream::EnableChatInsultFilter, COMDAT
; _this$ = ecx

; 12   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 13   : 	m_isEnableChatInsultFilter=isEnable;

  00003	8a 45 08	 mov	 al, BYTE PTR _isEnable$[ebp]
  00006	88 81 20 79 00
	00		 mov	 BYTE PTR [ecx+31008], al

; 14   : }

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?EnableChatInsultFilter@CPythonNetworkStream@@QAEX_N@Z ENDP ; CPythonNetworkStream::EnableChatInsultFilter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphaseloading.cpp
;	COMDAT ?GetFieldMusicVolume@CPythonNetworkStream@@QAEMXZ
_TEXT	SEGMENT
?GetFieldMusicVolume@CPythonNetworkStream@@QAEMXZ PROC	; CPythonNetworkStream::GetFieldMusicVolume, COMDAT
; _this$dead$ = ecx

; 320  : 	return gs_fieldMusic_volume;

  00000	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR _gs_fieldMusic_volume

; 321  : }

  00008	c3		 ret	 0
?GetFieldMusicVolume@CPythonNetworkStream@@QAEMXZ ENDP	; CPythonNetworkStream::GetFieldMusicVolume
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphaseloading.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphaseloading.cpp
;	COMDAT ?GetFieldMusicFileName@CPythonNetworkStream@@QAEPBDXZ
_TEXT	SEGMENT
?GetFieldMusicFileName@CPythonNetworkStream@@QAEPBDXZ PROC ; CPythonNetworkStream::GetFieldMusicFileName, COMDAT
; _this$dead$ = ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00000	83 3d 14 00 00
	00 10		 cmp	 DWORD PTR _gs_fieldMusic_fileName+20, 16 ; 00000010H
  00007	b8 00 00 00 00	 mov	 eax, OFFSET _gs_fieldMusic_fileName
  0000c	0f 43 05 00 00
	00 00		 cmovae	 eax, DWORD PTR _gs_fieldMusic_fileName
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphaseloading.cpp

; 316  : }

  00013	c3		 ret	 0
?GetFieldMusicFileName@CPythonNetworkStream@@QAEPBDXZ ENDP ; CPythonNetworkStream::GetFieldMusicFileName
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphaseloading.cpp
;	COMDAT ?StartGame@CPythonNetworkStream@@QAEXXZ
_TEXT	SEGMENT
?StartGame@CPythonNetworkStream@@QAEXXZ PROC		; CPythonNetworkStream::StartGame, COMDAT
; _this$ = ecx

; 341  : 	m_isStartGame=TRUE;

  00000	c7 81 ac 00 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+172], 1

; 342  : }

  0000a	c3		 ret	 0
?StartGame@CPythonNetworkStream@@QAEXXZ ENDP		; CPythonNetworkStream::StartGame
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphaseloading.cpp
;	COMDAT ?__FilterInsult@CPythonNetworkStream@@IAEXPADI@Z
_TEXT	SEGMENT
_szLine$ = 8						; size = 4
_uLineLen$ = 12						; size = 4
?__FilterInsult@CPythonNetworkStream@@IAEXPADI@Z PROC	; CPythonNetworkStream::__FilterInsult, COMDAT
; _this$ = ecx

; 17   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 18   : 	m_kInsultChecker.FilterInsult(szLine, uLineLen);

  00003	81 c1 14 79 00
	00		 add	 ecx, 30996		; 00007914H

; 19   : }

  00009	5d		 pop	 ebp

; 18   : 	m_kInsultChecker.FilterInsult(szLine, uLineLen);

  0000a	e9 00 00 00 00	 jmp	 ?FilterInsult@CInsultChecker@@QAEXPADI@Z ; CInsultChecker::FilterInsult
?__FilterInsult@CPythonNetworkStream@@IAEXPADI@Z ENDP	; CPythonNetworkStream::__FilterInsult
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphaseloading.cpp
;	COMDAT ?__RecvPlayerPoints@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_PointsPacket$ = -1028					; size = 1021
__$ArrayPad$ = -4					; size = 4
?__RecvPlayerPoints@CPythonNetworkStream@@IAE_NXZ PROC	; CPythonNetworkStream::__RecvPlayerPoints, COMDAT
; _this$ = ecx

; 326  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 04 00
	00		 sub	 esp, 1028		; 00000404H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	57		 push	 edi

; 327  : 	TPacketGCPoints PointsPacket;
; 328  : 
; 329  : 	if (!Recv(sizeof(TPacketGCPoints), &PointsPacket))

  00014	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _PointsPacket$[ebp]
  0001a	8b f9		 mov	 edi, ecx
  0001c	50		 push	 eax
  0001d	68 fd 03 00 00	 push	 1021			; 000003fdH
  00022	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00027	84 c0		 test	 al, al
  00029	75 0f		 jne	 SHORT $LN4@RecvPlayer
  0002b	5f		 pop	 edi

; 336  : 	return true;
; 337  : }

  0002c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0002f	33 cd		 xor	 ecx, ebp
  00031	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN4@RecvPlayer:
  0003a	56		 push	 esi

; 330  : 		return false;
; 331  : 
; 332  : 	for (DWORD i = 0; i < POINT_MAX_NUM; ++i)

  0003b	33 f6		 xor	 esi, esi
  0003d	8d 49 00	 npad	 3
$LL3@RecvPlayer:

; 333  : 		CPythonPlayer::Instance().SetStatus(i, PointsPacket.points[i]);

  00040	ff b4 b5 fd fb
	ff ff		 push	 DWORD PTR _PointsPacket$[ebp+esi*4+1]
  00047	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  0004d	56		 push	 esi
  0004e	e8 00 00 00 00	 call	 ?SetStatus@CPythonPlayer@@QAEXKJ@Z ; CPythonPlayer::SetStatus
  00053	46		 inc	 esi
  00054	81 fe ff 00 00
	00		 cmp	 esi, 255		; 000000ffH
  0005a	72 e4		 jb	 SHORT $LL3@RecvPlayer

; 334  : 
; 335  : 	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "RefreshStatus", Py_BuildValue("()"));

  0005c	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00067	50		 push	 eax
  00068	68 00 00 00 00	 push	 OFFSET ??_C@_0O@PDJLBMPA@RefreshStatus?$AA@
  0006d	ff b7 90 01 00
	00		 push	 DWORD PTR [edi+400]
  00073	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc

; 336  : 	return true;
; 337  : }

  00078	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007b	83 c4 10	 add	 esp, 16			; 00000010H
  0007e	33 cd		 xor	 ecx, ebp
  00080	b0 01		 mov	 al, 1
  00082	5e		 pop	 esi
  00083	5f		 pop	 edi
  00084	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
?__RecvPlayerPoints@CPythonNetworkStream@@IAE_NXZ ENDP	; CPythonNetworkStream::__RecvPlayerPoints
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.h
;	COMDAT ?__LeaveLoadingPhase@CPythonNetworkStream@@IAEXXZ
_TEXT	SEGMENT
?__LeaveLoadingPhase@CPythonNetworkStream@@IAEXXZ PROC	; CPythonNetworkStream::__LeaveLoadingPhase, COMDAT
; _this$ = ecx

; 593  : 		void __LeaveLoadingPhase() {}

  00000	c3		 ret	 0
?__LeaveLoadingPhase@CPythonNetworkStream@@IAEXXZ ENDP	; CPythonNetworkStream::__LeaveLoadingPhase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphaseloading.cpp
;	COMDAT ?LoadingPhase@CPythonNetworkStream@@IAEXXZ
_TEXT	SEGMENT
_header$ = -1						; size = 1
?LoadingPhase@CPythonNetworkStream@@IAEXXZ PROC		; CPythonNetworkStream::LoadingPhase, COMDAT
; _this$ = ecx

; 83   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 84   : 	TPacketHeader header;
; 85   : 
; 86   : 	if (!CheckPacket(&header))

  00006	8d 45 ff	 lea	 eax, DWORD PTR _header$[ebp]
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	50		 push	 eax
  0000c	8b f1		 mov	 esi, ecx
  0000e	e8 00 00 00 00	 call	 ?CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z ; CPythonNetworkStream::CheckPacket
  00013	84 c0		 test	 al, al
  00015	0f 84 b4 00 00
	00		 je	 $LN29@LoadingPha

; 87   : 		return;
; 88   : 
; 89   : 	switch (header)

  0001b	0f b6 7d ff	 movzx	 edi, BYTE PTR _header$[ebp]
  0001f	8d 47 f1	 lea	 eax, DWORD PTR [edi-15]
  00022	3d ee 00 00 00	 cmp	 eax, 238		; 000000eeH
  00027	0f 87 9b 00 00
	00		 ja	 $LN1@LoadingPha
  0002d	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN31@LoadingPha[eax]
  00034	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN35@LoadingPha[eax*4]
$LN25@LoadingPha:

; 90   : 	{
; 91   : 		case HEADER_GC_PHASE:
; 92   : 			if (RecvPhasePacket())

  0003b	8b ce		 mov	 ecx, esi
  0003d	e8 00 00 00 00	 call	 ?RecvPhasePacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvPhasePacket

; 93   : 				return;
; 94   : 			break;

  00042	eb 58		 jmp	 SHORT $LN33@LoadingPha
$LN23@LoadingPha:

; 95   : 
; 96   : 		case HEADER_GC_MAIN_CHARACTER:
; 97   : 			if (RecvMainCharacter())

  00044	8b ce		 mov	 ecx, esi
  00046	e8 00 00 00 00	 call	 ?RecvMainCharacter@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvMainCharacter

; 98   : 				return;
; 99   : 			break;

  0004b	eb 4f		 jmp	 SHORT $LN33@LoadingPha
$LN21@LoadingPha:

; 100  : 
; 101  : 		// SUPPORT_BGM
; 102  : 		case HEADER_GC_MAIN_CHARACTER2_EMPIRE:
; 103  : 			if (RecvMainCharacter2_EMPIRE())

  0004d	8b ce		 mov	 ecx, esi
  0004f	e8 00 00 00 00	 call	 ?RecvMainCharacter2_EMPIRE@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvMainCharacter2_EMPIRE

; 104  : 				return;
; 105  : 			break;

  00054	eb 46		 jmp	 SHORT $LN33@LoadingPha
$LN19@LoadingPha:

; 106  : 
; 107  : 		case HEADER_GC_MAIN_CHARACTER3_BGM:
; 108  : 			if (RecvMainCharacter3_BGM())

  00056	8b ce		 mov	 ecx, esi
  00058	e8 00 00 00 00	 call	 ?RecvMainCharacter3_BGM@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvMainCharacter3_BGM

; 109  : 				return;
; 110  : 			break;

  0005d	eb 3d		 jmp	 SHORT $LN33@LoadingPha
$LN17@LoadingPha:

; 111  : 
; 112  : 		case HEADER_GC_MAIN_CHARACTER4_BGM_VOL:
; 113  : 			if (RecvMainCharacter4_BGM_VOL())

  0005f	8b ce		 mov	 ecx, esi
  00061	e8 00 00 00 00	 call	 ?RecvMainCharacter4_BGM_VOL@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvMainCharacter4_BGM_VOL

; 114  : 				return;
; 115  : 			break;

  00066	eb 34		 jmp	 SHORT $LN33@LoadingPha
$LN15@LoadingPha:

; 116  : 
; 117  : 		// END_OF_SUPPORT_BGM
; 118  : 
; 119  : 		case HEADER_GC_CHARACTER_UPDATE:
; 120  : 			if (RecvCharacterUpdatePacket())

  00068	8b ce		 mov	 ecx, esi
  0006a	e8 00 00 00 00	 call	 ?RecvCharacterUpdatePacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvCharacterUpdatePacket

; 121  : 				return;
; 122  : 			break;

  0006f	eb 2b		 jmp	 SHORT $LN33@LoadingPha
$LN13@LoadingPha:

; 123  : 
; 124  : 		case HEADER_GC_PLAYER_POINTS:
; 125  : 			if (__RecvPlayerPoints())

  00071	8b ce		 mov	 ecx, esi
  00073	e8 00 00 00 00	 call	 ?__RecvPlayerPoints@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::__RecvPlayerPoints

; 126  : 				return;
; 127  : 			break;

  00078	eb 22		 jmp	 SHORT $LN33@LoadingPha
$LN11@LoadingPha:

; 128  : 
; 129  : 		case HEADER_GC_PLAYER_POINT_CHANGE:
; 130  : 			if (RecvPointChange())

  0007a	8b ce		 mov	 ecx, esi
  0007c	e8 00 00 00 00	 call	 ?RecvPointChange@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvPointChange

; 131  : 				return;
; 132  : 			break;

  00081	eb 19		 jmp	 SHORT $LN33@LoadingPha
$LN9@LoadingPha:

; 133  : 
; 134  : 		case HEADER_GC_ITEM_SET:
; 135  : 			if (RecvItemSetPacket())

  00083	8b ce		 mov	 ecx, esi
  00085	e8 00 00 00 00	 call	 ?RecvItemSetPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvItemSetPacket

; 136  : 				return;
; 137  : 			break;

  0008a	eb 10		 jmp	 SHORT $LN33@LoadingPha
$LN7@LoadingPha:

; 138  : 
; 139  : 		case HEADER_GC_PING:
; 140  : 			if (RecvPingPacket())

  0008c	8b ce		 mov	 ecx, esi
  0008e	e8 00 00 00 00	 call	 ?RecvPingPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvPingPacket

; 141  : 				return;
; 142  : 			break;

  00093	eb 07		 jmp	 SHORT $LN33@LoadingPha
$LN5@LoadingPha:

; 143  : 
; 144  : 		case HEADER_GC_QUICKSLOT_ADD:
; 145  : 			if (RecvQuickSlotAddPacket())

  00095	8b ce		 mov	 ecx, esi
  00097	e8 00 00 00 00	 call	 ?RecvQuickSlotAddPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvQuickSlotAddPacket
$LN33@LoadingPha:
  0009c	84 c0		 test	 al, al
  0009e	75 2f		 jne	 SHORT $LN29@LoadingPha

; 162  : 			return;
; 163  : 			break;
; 164  : 	}
; 165  : 
; 166  : 	RecvErrorPacket(header);

  000a0	57		 push	 edi
  000a1	8b ce		 mov	 ecx, esi
  000a3	e8 00 00 00 00	 call	 ?RecvErrorPacket@CPythonNetworkStream@@IAE_NH@Z ; CPythonNetworkStream::RecvErrorPacket

; 167  : }

  000a8	5f		 pop	 edi
  000a9	5e		 pop	 esi
  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c3		 ret	 0
$LN3@LoadingPha:

; 146  : 				return;
; 147  : 			break;
; 148  : 
; 149  : 		case HEADER_GC_HYBRIDCRYPT_KEYS:
; 150  : 			RecvHybridCryptKeyPacket();

  000ae	8b ce		 mov	 ecx, esi
  000b0	e8 00 00 00 00	 call	 ?RecvHybridCryptKeyPacket@CPythonNetworkStream@@QAE_NXZ ; CPythonNetworkStream::RecvHybridCryptKeyPacket

; 167  : }

  000b5	5f		 pop	 edi
  000b6	5e		 pop	 esi
  000b7	8b e5		 mov	 esp, ebp
  000b9	5d		 pop	 ebp
  000ba	c3		 ret	 0
$LN2@LoadingPha:

; 151  : 			return;
; 152  : 			break;
; 153  : 
; 154  : 		case HEADER_GC_HYBRIDCRYPT_SDB:
; 155  : 			RecvHybridCryptSDBPacket();

  000bb	8b ce		 mov	 ecx, esi
  000bd	e8 00 00 00 00	 call	 ?RecvHybridCryptSDBPacket@CPythonNetworkStream@@QAE_NXZ ; CPythonNetworkStream::RecvHybridCryptSDBPacket

; 167  : }

  000c2	5f		 pop	 edi
  000c3	5e		 pop	 esi
  000c4	8b e5		 mov	 esp, ebp
  000c6	5d		 pop	 ebp
  000c7	c3		 ret	 0
$LN1@LoadingPha:

; 156  : 			return;
; 157  : 			break;
; 158  : 
; 159  : 
; 160  : 		default:
; 161  : 			GamePhase();

  000c8	8b ce		 mov	 ecx, esi
  000ca	e8 00 00 00 00	 call	 ?GamePhase@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::GamePhase
$LN29@LoadingPha:

; 167  : }

  000cf	5f		 pop	 edi
  000d0	5e		 pop	 esi
  000d1	8b e5		 mov	 esp, ebp
  000d3	5d		 pop	 ebp
  000d4	c3		 ret	 0
  000d5	8d 49 00	 npad	 3
$LN35@LoadingPha:
  000d8	00 00 00 00	 DD	 $LN23@LoadingPha
  000dc	00 00 00 00	 DD	 $LN13@LoadingPha
  000e0	00 00 00 00	 DD	 $LN11@LoadingPha
  000e4	00 00 00 00	 DD	 $LN15@LoadingPha
  000e8	00 00 00 00	 DD	 $LN9@LoadingPha
  000ec	00 00 00 00	 DD	 $LN5@LoadingPha
  000f0	00 00 00 00	 DD	 $LN7@LoadingPha
  000f4	00 00 00 00	 DD	 $LN21@LoadingPha
  000f8	00 00 00 00	 DD	 $LN19@LoadingPha
  000fc	00 00 00 00	 DD	 $LN17@LoadingPha
  00100	00 00 00 00	 DD	 $LN3@LoadingPha
  00104	00 00 00 00	 DD	 $LN2@LoadingPha
  00108	00 00 00 00	 DD	 $LN25@LoadingPha
  0010c	00 00 00 00	 DD	 $LN1@LoadingPha
$LN31@LoadingPha:
  00110	00		 DB	 0
  00111	01		 DB	 1
  00112	02		 DB	 2
  00113	0d		 DB	 13			; 0000000dH
  00114	03		 DB	 3
  00115	04		 DB	 4
  00116	0d		 DB	 13			; 0000000dH
  00117	0d		 DB	 13			; 0000000dH
  00118	0d		 DB	 13			; 0000000dH
  00119	0d		 DB	 13			; 0000000dH
  0011a	0d		 DB	 13			; 0000000dH
  0011b	0d		 DB	 13			; 0000000dH
  0011c	0d		 DB	 13			; 0000000dH
  0011d	05		 DB	 5
  0011e	0d		 DB	 13			; 0000000dH
  0011f	0d		 DB	 13			; 0000000dH
  00120	0d		 DB	 13			; 0000000dH
  00121	0d		 DB	 13			; 0000000dH
  00122	0d		 DB	 13			; 0000000dH
  00123	0d		 DB	 13			; 0000000dH
  00124	0d		 DB	 13			; 0000000dH
  00125	0d		 DB	 13			; 0000000dH
  00126	0d		 DB	 13			; 0000000dH
  00127	0d		 DB	 13			; 0000000dH
  00128	0d		 DB	 13			; 0000000dH
  00129	0d		 DB	 13			; 0000000dH
  0012a	0d		 DB	 13			; 0000000dH
  0012b	0d		 DB	 13			; 0000000dH
  0012c	0d		 DB	 13			; 0000000dH
  0012d	06		 DB	 6
  0012e	0d		 DB	 13			; 0000000dH
  0012f	0d		 DB	 13			; 0000000dH
  00130	0d		 DB	 13			; 0000000dH
  00131	0d		 DB	 13			; 0000000dH
  00132	0d		 DB	 13			; 0000000dH
  00133	0d		 DB	 13			; 0000000dH
  00134	0d		 DB	 13			; 0000000dH
  00135	0d		 DB	 13			; 0000000dH
  00136	0d		 DB	 13			; 0000000dH
  00137	0d		 DB	 13			; 0000000dH
  00138	0d		 DB	 13			; 0000000dH
  00139	0d		 DB	 13			; 0000000dH
  0013a	0d		 DB	 13			; 0000000dH
  0013b	0d		 DB	 13			; 0000000dH
  0013c	0d		 DB	 13			; 0000000dH
  0013d	0d		 DB	 13			; 0000000dH
  0013e	0d		 DB	 13			; 0000000dH
  0013f	0d		 DB	 13			; 0000000dH
  00140	0d		 DB	 13			; 0000000dH
  00141	0d		 DB	 13			; 0000000dH
  00142	0d		 DB	 13			; 0000000dH
  00143	0d		 DB	 13			; 0000000dH
  00144	0d		 DB	 13			; 0000000dH
  00145	0d		 DB	 13			; 0000000dH
  00146	0d		 DB	 13			; 0000000dH
  00147	0d		 DB	 13			; 0000000dH
  00148	0d		 DB	 13			; 0000000dH
  00149	0d		 DB	 13			; 0000000dH
  0014a	0d		 DB	 13			; 0000000dH
  0014b	0d		 DB	 13			; 0000000dH
  0014c	0d		 DB	 13			; 0000000dH
  0014d	0d		 DB	 13			; 0000000dH
  0014e	0d		 DB	 13			; 0000000dH
  0014f	0d		 DB	 13			; 0000000dH
  00150	0d		 DB	 13			; 0000000dH
  00151	0d		 DB	 13			; 0000000dH
  00152	0d		 DB	 13			; 0000000dH
  00153	0d		 DB	 13			; 0000000dH
  00154	0d		 DB	 13			; 0000000dH
  00155	0d		 DB	 13			; 0000000dH
  00156	0d		 DB	 13			; 0000000dH
  00157	0d		 DB	 13			; 0000000dH
  00158	0d		 DB	 13			; 0000000dH
  00159	0d		 DB	 13			; 0000000dH
  0015a	0d		 DB	 13			; 0000000dH
  0015b	0d		 DB	 13			; 0000000dH
  0015c	0d		 DB	 13			; 0000000dH
  0015d	0d		 DB	 13			; 0000000dH
  0015e	0d		 DB	 13			; 0000000dH
  0015f	0d		 DB	 13			; 0000000dH
  00160	0d		 DB	 13			; 0000000dH
  00161	0d		 DB	 13			; 0000000dH
  00162	0d		 DB	 13			; 0000000dH
  00163	0d		 DB	 13			; 0000000dH
  00164	0d		 DB	 13			; 0000000dH
  00165	0d		 DB	 13			; 0000000dH
  00166	0d		 DB	 13			; 0000000dH
  00167	0d		 DB	 13			; 0000000dH
  00168	0d		 DB	 13			; 0000000dH
  00169	0d		 DB	 13			; 0000000dH
  0016a	0d		 DB	 13			; 0000000dH
  0016b	0d		 DB	 13			; 0000000dH
  0016c	0d		 DB	 13			; 0000000dH
  0016d	0d		 DB	 13			; 0000000dH
  0016e	0d		 DB	 13			; 0000000dH
  0016f	0d		 DB	 13			; 0000000dH
  00170	0d		 DB	 13			; 0000000dH
  00171	0d		 DB	 13			; 0000000dH
  00172	07		 DB	 7
  00173	0d		 DB	 13			; 0000000dH
  00174	0d		 DB	 13			; 0000000dH
  00175	0d		 DB	 13			; 0000000dH
  00176	0d		 DB	 13			; 0000000dH
  00177	0d		 DB	 13			; 0000000dH
  00178	0d		 DB	 13			; 0000000dH
  00179	0d		 DB	 13			; 0000000dH
  0017a	0d		 DB	 13			; 0000000dH
  0017b	0d		 DB	 13			; 0000000dH
  0017c	0d		 DB	 13			; 0000000dH
  0017d	0d		 DB	 13			; 0000000dH
  0017e	0d		 DB	 13			; 0000000dH
  0017f	0d		 DB	 13			; 0000000dH
  00180	0d		 DB	 13			; 0000000dH
  00181	0d		 DB	 13			; 0000000dH
  00182	0d		 DB	 13			; 0000000dH
  00183	0d		 DB	 13			; 0000000dH
  00184	0d		 DB	 13			; 0000000dH
  00185	0d		 DB	 13			; 0000000dH
  00186	0d		 DB	 13			; 0000000dH
  00187	0d		 DB	 13			; 0000000dH
  00188	0d		 DB	 13			; 0000000dH
  00189	0d		 DB	 13			; 0000000dH
  0018a	08		 DB	 8
  0018b	09		 DB	 9
  0018c	0d		 DB	 13			; 0000000dH
  0018d	0d		 DB	 13			; 0000000dH
  0018e	0d		 DB	 13			; 0000000dH
  0018f	0d		 DB	 13			; 0000000dH
  00190	0d		 DB	 13			; 0000000dH
  00191	0d		 DB	 13			; 0000000dH
  00192	0d		 DB	 13			; 0000000dH
  00193	0d		 DB	 13			; 0000000dH
  00194	0d		 DB	 13			; 0000000dH
  00195	0d		 DB	 13			; 0000000dH
  00196	0d		 DB	 13			; 0000000dH
  00197	0d		 DB	 13			; 0000000dH
  00198	0d		 DB	 13			; 0000000dH
  00199	0a		 DB	 10			; 0000000aH
  0019a	0b		 DB	 11			; 0000000bH
  0019b	0d		 DB	 13			; 0000000dH
  0019c	0d		 DB	 13			; 0000000dH
  0019d	0d		 DB	 13			; 0000000dH
  0019e	0d		 DB	 13			; 0000000dH
  0019f	0d		 DB	 13			; 0000000dH
  001a0	0d		 DB	 13			; 0000000dH
  001a1	0d		 DB	 13			; 0000000dH
  001a2	0d		 DB	 13			; 0000000dH
  001a3	0d		 DB	 13			; 0000000dH
  001a4	0d		 DB	 13			; 0000000dH
  001a5	0d		 DB	 13			; 0000000dH
  001a6	0d		 DB	 13			; 0000000dH
  001a7	0d		 DB	 13			; 0000000dH
  001a8	0d		 DB	 13			; 0000000dH
  001a9	0d		 DB	 13			; 0000000dH
  001aa	0d		 DB	 13			; 0000000dH
  001ab	0d		 DB	 13			; 0000000dH
  001ac	0d		 DB	 13			; 0000000dH
  001ad	0d		 DB	 13			; 0000000dH
  001ae	0d		 DB	 13			; 0000000dH
  001af	0d		 DB	 13			; 0000000dH
  001b0	0d		 DB	 13			; 0000000dH
  001b1	0d		 DB	 13			; 0000000dH
  001b2	0d		 DB	 13			; 0000000dH
  001b3	0d		 DB	 13			; 0000000dH
  001b4	0d		 DB	 13			; 0000000dH
  001b5	0d		 DB	 13			; 0000000dH
  001b6	0d		 DB	 13			; 0000000dH
  001b7	0d		 DB	 13			; 0000000dH
  001b8	0d		 DB	 13			; 0000000dH
  001b9	0d		 DB	 13			; 0000000dH
  001ba	0d		 DB	 13			; 0000000dH
  001bb	0d		 DB	 13			; 0000000dH
  001bc	0d		 DB	 13			; 0000000dH
  001bd	0d		 DB	 13			; 0000000dH
  001be	0d		 DB	 13			; 0000000dH
  001bf	0d		 DB	 13			; 0000000dH
  001c0	0d		 DB	 13			; 0000000dH
  001c1	0d		 DB	 13			; 0000000dH
  001c2	0d		 DB	 13			; 0000000dH
  001c3	0d		 DB	 13			; 0000000dH
  001c4	0d		 DB	 13			; 0000000dH
  001c5	0d		 DB	 13			; 0000000dH
  001c6	0d		 DB	 13			; 0000000dH
  001c7	0d		 DB	 13			; 0000000dH
  001c8	0d		 DB	 13			; 0000000dH
  001c9	0d		 DB	 13			; 0000000dH
  001ca	0d		 DB	 13			; 0000000dH
  001cb	0d		 DB	 13			; 0000000dH
  001cc	0d		 DB	 13			; 0000000dH
  001cd	0d		 DB	 13			; 0000000dH
  001ce	0d		 DB	 13			; 0000000dH
  001cf	0d		 DB	 13			; 0000000dH
  001d0	0d		 DB	 13			; 0000000dH
  001d1	0d		 DB	 13			; 0000000dH
  001d2	0d		 DB	 13			; 0000000dH
  001d3	0d		 DB	 13			; 0000000dH
  001d4	0d		 DB	 13			; 0000000dH
  001d5	0d		 DB	 13			; 0000000dH
  001d6	0d		 DB	 13			; 0000000dH
  001d7	0d		 DB	 13			; 0000000dH
  001d8	0d		 DB	 13			; 0000000dH
  001d9	0d		 DB	 13			; 0000000dH
  001da	0d		 DB	 13			; 0000000dH
  001db	0d		 DB	 13			; 0000000dH
  001dc	0d		 DB	 13			; 0000000dH
  001dd	0d		 DB	 13			; 0000000dH
  001de	0d		 DB	 13			; 0000000dH
  001df	0d		 DB	 13			; 0000000dH
  001e0	0d		 DB	 13			; 0000000dH
  001e1	0d		 DB	 13			; 0000000dH
  001e2	0d		 DB	 13			; 0000000dH
  001e3	0d		 DB	 13			; 0000000dH
  001e4	0d		 DB	 13			; 0000000dH
  001e5	0d		 DB	 13			; 0000000dH
  001e6	0d		 DB	 13			; 0000000dH
  001e7	0d		 DB	 13			; 0000000dH
  001e8	0d		 DB	 13			; 0000000dH
  001e9	0d		 DB	 13			; 0000000dH
  001ea	0d		 DB	 13			; 0000000dH
  001eb	0d		 DB	 13			; 0000000dH
  001ec	0d		 DB	 13			; 0000000dH
  001ed	0d		 DB	 13			; 0000000dH
  001ee	0d		 DB	 13			; 0000000dH
  001ef	0d		 DB	 13			; 0000000dH
  001f0	0d		 DB	 13			; 0000000dH
  001f1	0d		 DB	 13			; 0000000dH
  001f2	0d		 DB	 13			; 0000000dH
  001f3	0d		 DB	 13			; 0000000dH
  001f4	0d		 DB	 13			; 0000000dH
  001f5	0d		 DB	 13			; 0000000dH
  001f6	0d		 DB	 13			; 0000000dH
  001f7	0d		 DB	 13			; 0000000dH
  001f8	0d		 DB	 13			; 0000000dH
  001f9	0d		 DB	 13			; 0000000dH
  001fa	0d		 DB	 13			; 0000000dH
  001fb	0d		 DB	 13			; 0000000dH
  001fc	0d		 DB	 13			; 0000000dH
  001fd	0d		 DB	 13			; 0000000dH
  001fe	0c		 DB	 12			; 0000000cH
?LoadingPhase@CPythonNetworkStream@@IAEXXZ ENDP		; CPythonNetworkStream::LoadingPhase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphaseloading.cpp
;	COMDAT ?RecvMainCharacter@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_MainChrPacket$ = -52					; size = 45
__$ArrayPad$ = -4					; size = 4
?RecvMainCharacter@CPythonNetworkStream@@IAE_NXZ PROC	; CPythonNetworkStream::RecvMainCharacter, COMDAT
; _this$ = ecx

; 194  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi

; 195  : 	TPacketGCMainCharacter MainChrPacket;
; 196  : 	if (!Recv(sizeof(TPacketGCMainCharacter), &MainChrPacket))

  00012	8d 45 cc	 lea	 eax, DWORD PTR _MainChrPacket$[ebp]
  00015	8b f9		 mov	 edi, ecx
  00017	50		 push	 eax
  00018	6a 2d		 push	 45			; 0000002dH
  0001a	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0001f	84 c0		 test	 al, al
  00021	75 10		 jne	 SHORT $LN1@RecvMainCh

; 215  : 	return true;
; 216  : }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00028	33 cd		 xor	 ecx, ebp
  0002a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
$LN1@RecvMainCh:

; 197  : 		return false;
; 198  : 
; 199  : 	m_dwMainActorVID = MainChrPacket.dwVID;
; 200  : 	m_dwMainActorRace = MainChrPacket.wRaceNum;

  00033	0f b7 45 d1	 movzx	 eax, WORD PTR _MainChrPacket$[ebp+5]
  00037	8b 4d cd	 mov	 ecx, DWORD PTR _MainChrPacket$[ebp+1]
  0003a	89 87 9c 00 00
	00		 mov	 DWORD PTR [edi+156], eax

; 201  : 	m_dwMainActorEmpire = 0;
; 202  : 	m_dwMainActorSkillGroup = MainChrPacket.bySkillGroup;

  00040	0f b6 45 f8	 movzx	 eax, BYTE PTR _MainChrPacket$[ebp+44]
  00044	89 8f 98 00 00
	00		 mov	 DWORD PTR [edi+152], ecx

; 203  : 
; 204  : 	m_rokNetActorMgr->SetMainActorVID(m_dwMainActorVID);

  0004a	51		 push	 ecx
  0004b	8b 8f 0c 03 00
	00		 mov	 ecx, DWORD PTR [edi+780]
  00051	c7 87 a0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+160], 0
  0005b	89 87 a4 00 00
	00		 mov	 DWORD PTR [edi+164], eax
  00061	e8 00 00 00 00	 call	 ?SetMainActorVID@CNetworkActorManager@@QAEXK@Z ; CNetworkActorManager::SetMainActorVID

; 205  : 
; 206  : 	CPythonPlayer& rkPlayer=CPythonPlayer::Instance();

  00066	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton

; 207  : 	rkPlayer.SetName(MainChrPacket.szName);

  0006c	8d 45 d3	 lea	 eax, DWORD PTR _MainChrPacket$[ebp+7]
  0006f	50		 push	 eax
  00070	8b ce		 mov	 ecx, esi
  00072	e8 00 00 00 00	 call	 ?SetName@CPythonPlayer@@QAEXPBD@Z ; CPythonPlayer::SetName

; 208  : 	rkPlayer.SetMainCharacterIndex(GetMainActorVID());

  00077	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0007a	8b cf		 mov	 ecx, edi
  0007c	e8 00 00 00 00	 call	 ?GetMainActorVID@CPythonNetworkStream@@QAEKXZ ; CPythonNetworkStream::GetMainActorVID
  00081	50		 push	 eax
  00082	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00085	ff 52 08	 call	 DWORD PTR [edx+8]

; 209  : 
; 210  : 	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_LOAD], "LoadData", Py_BuildValue("(ii)", MainChrPacket.lX, MainChrPacket.lY));

  00088	ff 75 f0	 push	 DWORD PTR _MainChrPacket$[ebp+36]
  0008b	ff 75 ec	 push	 DWORD PTR _MainChrPacket$[ebp+32]
  0008e	68 00 00 00 00	 push	 OFFSET ??_C@_04INACLLOK@?$CIii?$CJ?$AA@
  00093	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00099	50		 push	 eax
  0009a	68 00 00 00 00	 push	 OFFSET ??_C@_08JHMIFHMN@LoadData?$AA@
  0009f	ff b7 8c 01 00
	00		 push	 DWORD PTR [edi+396]
  000a5	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  000aa	83 c4 18	 add	 esp, 24			; 00000018H

; 211  : 
; 212  : 	//Tracef(" >> RecvMainCharacter\n");
; 213  : 
; 214  : 	SendClientVersionPacket();

  000ad	8b cf		 mov	 ecx, edi
  000af	e8 00 00 00 00	 call	 ?SendClientVersionPacket@CPythonNetworkStream@@QAE_NXZ ; CPythonNetworkStream::SendClientVersionPacket

; 215  : 	return true;
; 216  : }

  000b4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b7	b0 01		 mov	 al, 1
  000b9	5f		 pop	 edi
  000ba	33 cd		 xor	 ecx, ebp
  000bc	5e		 pop	 esi
  000bd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c2	8b e5		 mov	 esp, ebp
  000c4	5d		 pop	 ebp
  000c5	c3		 ret	 0
?RecvMainCharacter@CPythonNetworkStream@@IAE_NXZ ENDP	; CPythonNetworkStream::RecvMainCharacter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphaseloading.cpp
;	COMDAT ?RecvMainCharacter2_EMPIRE@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_mainChrPacket$ = -52					; size = 46
__$ArrayPad$ = -4					; size = 4
?RecvMainCharacter2_EMPIRE@CPythonNetworkStream@@IAE_NXZ PROC ; CPythonNetworkStream::RecvMainCharacter2_EMPIRE, COMDAT
; _this$ = ecx

; 220  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi

; 221  : 	TPacketGCMainCharacter2_EMPIRE mainChrPacket;
; 222  : 	if (!Recv(sizeof(mainChrPacket), &mainChrPacket))

  00012	8d 45 cc	 lea	 eax, DWORD PTR _mainChrPacket$[ebp]
  00015	8b f9		 mov	 edi, ecx
  00017	50		 push	 eax
  00018	6a 2e		 push	 46			; 0000002eH
  0001a	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0001f	84 c0		 test	 al, al
  00021	75 10		 jne	 SHORT $LN1@RecvMainCh

; 241  : 	return true;
; 242  : }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00028	33 cd		 xor	 ecx, ebp
  0002a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
$LN1@RecvMainCh:

; 223  : 		return false;
; 224  : 
; 225  : 	m_dwMainActorVID = mainChrPacket.dwVID;
; 226  : 	m_dwMainActorRace = mainChrPacket.wRaceNum;

  00033	0f b7 45 d1	 movzx	 eax, WORD PTR _mainChrPacket$[ebp+5]
  00037	8b 4d cd	 mov	 ecx, DWORD PTR _mainChrPacket$[ebp+1]
  0003a	89 87 9c 00 00
	00		 mov	 DWORD PTR [edi+156], eax

; 227  : 	m_dwMainActorEmpire = mainChrPacket.byEmpire;

  00040	0f b6 45 f8	 movzx	 eax, BYTE PTR _mainChrPacket$[ebp+44]
  00044	89 87 a0 00 00
	00		 mov	 DWORD PTR [edi+160], eax

; 228  : 	m_dwMainActorSkillGroup = mainChrPacket.bySkillGroup;

  0004a	0f b6 45 f9	 movzx	 eax, BYTE PTR _mainChrPacket$[ebp+45]
  0004e	89 8f 98 00 00
	00		 mov	 DWORD PTR [edi+152], ecx

; 229  : 
; 230  : 	m_rokNetActorMgr->SetMainActorVID(m_dwMainActorVID);

  00054	51		 push	 ecx
  00055	8b 8f 0c 03 00
	00		 mov	 ecx, DWORD PTR [edi+780]
  0005b	89 87 a4 00 00
	00		 mov	 DWORD PTR [edi+164], eax
  00061	e8 00 00 00 00	 call	 ?SetMainActorVID@CNetworkActorManager@@QAEXK@Z ; CNetworkActorManager::SetMainActorVID

; 231  : 
; 232  : 	CPythonPlayer& rkPlayer=CPythonPlayer::Instance();

  00066	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton

; 233  : 	rkPlayer.SetName(mainChrPacket.szName);

  0006c	8d 45 d3	 lea	 eax, DWORD PTR _mainChrPacket$[ebp+7]
  0006f	50		 push	 eax
  00070	8b ce		 mov	 ecx, esi
  00072	e8 00 00 00 00	 call	 ?SetName@CPythonPlayer@@QAEXPBD@Z ; CPythonPlayer::SetName

; 234  : 	rkPlayer.SetMainCharacterIndex(GetMainActorVID());

  00077	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0007a	8b cf		 mov	 ecx, edi
  0007c	e8 00 00 00 00	 call	 ?GetMainActorVID@CPythonNetworkStream@@QAEKXZ ; CPythonNetworkStream::GetMainActorVID
  00081	50		 push	 eax
  00082	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00085	ff 52 08	 call	 DWORD PTR [edx+8]

; 235  : 
; 236  : 	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_LOAD], "LoadData", Py_BuildValue("(ii)", mainChrPacket.lX, mainChrPacket.lY));

  00088	ff 75 f0	 push	 DWORD PTR _mainChrPacket$[ebp+36]
  0008b	ff 75 ec	 push	 DWORD PTR _mainChrPacket$[ebp+32]
  0008e	68 00 00 00 00	 push	 OFFSET ??_C@_04INACLLOK@?$CIii?$CJ?$AA@
  00093	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00099	50		 push	 eax
  0009a	68 00 00 00 00	 push	 OFFSET ??_C@_08JHMIFHMN@LoadData?$AA@
  0009f	ff b7 8c 01 00
	00		 push	 DWORD PTR [edi+396]
  000a5	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  000aa	83 c4 18	 add	 esp, 24			; 00000018H

; 237  : 
; 238  : 	//Tracef(" >> RecvMainCharacterNew : %d\n", m_dwMainActorEmpire);
; 239  : 
; 240  : 	SendClientVersionPacket();

  000ad	8b cf		 mov	 ecx, edi
  000af	e8 00 00 00 00	 call	 ?SendClientVersionPacket@CPythonNetworkStream@@QAE_NXZ ; CPythonNetworkStream::SendClientVersionPacket

; 241  : 	return true;
; 242  : }

  000b4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b7	b0 01		 mov	 al, 1
  000b9	5f		 pop	 edi
  000ba	33 cd		 xor	 ecx, ebp
  000bc	5e		 pop	 esi
  000bd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c2	8b e5		 mov	 esp, ebp
  000c4	5d		 pop	 ebp
  000c5	c3		 ret	 0
?RecvMainCharacter2_EMPIRE@CPythonNetworkStream@@IAE_NXZ ENDP ; CPythonNetworkStream::RecvMainCharacter2_EMPIRE
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphaseloading.cpp
;	COMDAT ?RecvMainCharacter3_BGM@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_mainChrPacket$ = -80					; size = 71
__$ArrayPad$ = -4					; size = 4
?RecvMainCharacter3_BGM@CPythonNetworkStream@@IAE_NXZ PROC ; CPythonNetworkStream::RecvMainCharacter3_BGM, COMDAT
; _this$ = ecx

; 245  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi

; 246  : 	TPacketGCMainCharacter3_BGM mainChrPacket;
; 247  : 	if (!Recv(sizeof(mainChrPacket), &mainChrPacket))

  00012	8d 45 b0	 lea	 eax, DWORD PTR _mainChrPacket$[ebp]
  00015	8b f9		 mov	 edi, ecx
  00017	50		 push	 eax
  00018	6a 47		 push	 71			; 00000047H
  0001a	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0001f	84 c0		 test	 al, al
  00021	75 10		 jne	 SHORT $LN1@RecvMainCh

; 268  : 	return true;
; 269  : }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00028	33 cd		 xor	 ecx, ebp
  0002a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
$LN1@RecvMainCh:

; 248  : 		return false;
; 249  : 
; 250  : 	m_dwMainActorVID = mainChrPacket.dwVID;
; 251  : 	m_dwMainActorRace = mainChrPacket.wRaceNum;

  00033	0f b7 45 b5	 movzx	 eax, WORD PTR _mainChrPacket$[ebp+5]
  00037	8b 4d b1	 mov	 ecx, DWORD PTR _mainChrPacket$[ebp+1]
  0003a	89 87 9c 00 00
	00		 mov	 DWORD PTR [edi+156], eax

; 252  : 	m_dwMainActorEmpire = mainChrPacket.byEmpire;

  00040	0f b6 45 f5	 movzx	 eax, BYTE PTR _mainChrPacket$[ebp+69]
  00044	89 87 a0 00 00
	00		 mov	 DWORD PTR [edi+160], eax

; 253  : 	m_dwMainActorSkillGroup = mainChrPacket.bySkillGroup;

  0004a	0f b6 45 f6	 movzx	 eax, BYTE PTR _mainChrPacket$[ebp+70]
  0004e	89 8f 98 00 00
	00		 mov	 DWORD PTR [edi+152], ecx

; 254  : 
; 255  : 	m_rokNetActorMgr->SetMainActorVID(m_dwMainActorVID);

  00054	51		 push	 ecx
  00055	8b 8f 0c 03 00
	00		 mov	 ecx, DWORD PTR [edi+780]
  0005b	89 87 a4 00 00
	00		 mov	 DWORD PTR [edi+164], eax
  00061	e8 00 00 00 00	 call	 ?SetMainActorVID@CNetworkActorManager@@QAEXK@Z ; CNetworkActorManager::SetMainActorVID

; 256  : 
; 257  : 	CPythonPlayer& rkPlayer=CPythonPlayer::Instance();

  00066	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton

; 258  : 	rkPlayer.SetName(mainChrPacket.szUserName);

  0006c	8d 45 b7	 lea	 eax, DWORD PTR _mainChrPacket$[ebp+7]
  0006f	50		 push	 eax
  00070	8b ce		 mov	 ecx, esi
  00072	e8 00 00 00 00	 call	 ?SetName@CPythonPlayer@@QAEXPBD@Z ; CPythonPlayer::SetName

; 259  : 	rkPlayer.SetMainCharacterIndex(GetMainActorVID());

  00077	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0007a	8b cf		 mov	 ecx, edi
  0007c	e8 00 00 00 00	 call	 ?GetMainActorVID@CPythonNetworkStream@@QAEKXZ ; CPythonNetworkStream::GetMainActorVID
  00081	50		 push	 eax
  00082	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00085	ff 52 08	 call	 DWORD PTR [edx+8]

; 260  : 
; 261  : 	__SetFieldMusicFileName(mainChrPacket.szBGMName);

  00088	8d 45 d0	 lea	 eax, DWORD PTR _mainChrPacket$[ebp+32]
  0008b	50		 push	 eax
  0008c	e8 00 00 00 00	 call	 ?__SetFieldMusicFileName@CPythonNetworkStream@@IAEXPBD@Z ; CPythonNetworkStream::__SetFieldMusicFileName

; 262  : 
; 263  : 	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_LOAD], "LoadData", Py_BuildValue("(ii)", mainChrPacket.lX, mainChrPacket.lY));

  00091	ff 75 ed	 push	 DWORD PTR _mainChrPacket$[ebp+61]
  00094	ff 75 e9	 push	 DWORD PTR _mainChrPacket$[ebp+57]
  00097	68 00 00 00 00	 push	 OFFSET ??_C@_04INACLLOK@?$CIii?$CJ?$AA@
  0009c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  000a2	50		 push	 eax
  000a3	68 00 00 00 00	 push	 OFFSET ??_C@_08JHMIFHMN@LoadData?$AA@
  000a8	ff b7 8c 01 00
	00		 push	 DWORD PTR [edi+396]
  000ae	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  000b3	83 c4 18	 add	 esp, 24			; 00000018H

; 264  : 
; 265  : 	//Tracef(" >> RecvMainCharacterNew : %d\n", m_dwMainActorEmpire);
; 266  : 
; 267  : 	SendClientVersionPacket();

  000b6	8b cf		 mov	 ecx, edi
  000b8	e8 00 00 00 00	 call	 ?SendClientVersionPacket@CPythonNetworkStream@@QAE_NXZ ; CPythonNetworkStream::SendClientVersionPacket

; 268  : 	return true;
; 269  : }

  000bd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c0	b0 01		 mov	 al, 1
  000c2	5f		 pop	 edi
  000c3	33 cd		 xor	 ecx, ebp
  000c5	5e		 pop	 esi
  000c6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000cb	8b e5		 mov	 esp, ebp
  000cd	5d		 pop	 ebp
  000ce	c3		 ret	 0
?RecvMainCharacter3_BGM@CPythonNetworkStream@@IAE_NXZ ENDP ; CPythonNetworkStream::RecvMainCharacter3_BGM
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphaseloading.cpp
;	COMDAT ?RecvMainCharacter4_BGM_VOL@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_mainChrPacket$ = -88					; size = 75
__$ArrayPad$ = -4					; size = 4
?RecvMainCharacter4_BGM_VOL@CPythonNetworkStream@@IAE_NXZ PROC ; CPythonNetworkStream::RecvMainCharacter4_BGM_VOL, COMDAT
; _this$ = ecx

; 272  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi

; 273  : 	TPacketGCMainCharacter4_BGM_VOL mainChrPacket;
; 274  : 	if (!Recv(sizeof(mainChrPacket), &mainChrPacket))

  00012	8d 45 a8	 lea	 eax, DWORD PTR _mainChrPacket$[ebp]
  00015	8b f9		 mov	 edi, ecx
  00017	50		 push	 eax
  00018	6a 4b		 push	 75			; 0000004bH
  0001a	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0001f	84 c0		 test	 al, al
  00021	75 10		 jne	 SHORT $LN1@RecvMainCh

; 295  : 	return true;
; 296  : }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00028	33 cd		 xor	 ecx, ebp
  0002a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
$LN1@RecvMainCh:

; 275  : 		return false;
; 276  : 
; 277  : 	m_dwMainActorVID = mainChrPacket.dwVID;
; 278  : 	m_dwMainActorRace = mainChrPacket.wRaceNum;

  00033	0f b7 45 ad	 movzx	 eax, WORD PTR _mainChrPacket$[ebp+5]
  00037	8b 4d a9	 mov	 ecx, DWORD PTR _mainChrPacket$[ebp+1]
  0003a	89 87 9c 00 00
	00		 mov	 DWORD PTR [edi+156], eax

; 279  : 	m_dwMainActorEmpire = mainChrPacket.byEmpire;

  00040	0f b6 45 f1	 movzx	 eax, BYTE PTR _mainChrPacket$[ebp+73]
  00044	89 87 a0 00 00
	00		 mov	 DWORD PTR [edi+160], eax

; 280  : 	m_dwMainActorSkillGroup = mainChrPacket.bySkillGroup;

  0004a	0f b6 45 f2	 movzx	 eax, BYTE PTR _mainChrPacket$[ebp+74]
  0004e	89 8f 98 00 00
	00		 mov	 DWORD PTR [edi+152], ecx

; 281  : 
; 282  : 	m_rokNetActorMgr->SetMainActorVID(m_dwMainActorVID);

  00054	51		 push	 ecx
  00055	8b 8f 0c 03 00
	00		 mov	 ecx, DWORD PTR [edi+780]
  0005b	89 87 a4 00 00
	00		 mov	 DWORD PTR [edi+164], eax
  00061	e8 00 00 00 00	 call	 ?SetMainActorVID@CNetworkActorManager@@QAEXK@Z ; CNetworkActorManager::SetMainActorVID

; 283  : 
; 284  : 	CPythonPlayer& rkPlayer=CPythonPlayer::Instance();

  00066	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton

; 285  : 	rkPlayer.SetName(mainChrPacket.szUserName);

  0006c	8d 45 af	 lea	 eax, DWORD PTR _mainChrPacket$[ebp+7]
  0006f	50		 push	 eax
  00070	8b ce		 mov	 ecx, esi
  00072	e8 00 00 00 00	 call	 ?SetName@CPythonPlayer@@QAEXPBD@Z ; CPythonPlayer::SetName

; 286  : 	rkPlayer.SetMainCharacterIndex(GetMainActorVID());

  00077	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0007a	8b cf		 mov	 ecx, edi
  0007c	e8 00 00 00 00	 call	 ?GetMainActorVID@CPythonNetworkStream@@QAEKXZ ; CPythonNetworkStream::GetMainActorVID
  00081	50		 push	 eax
  00082	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00085	ff 52 08	 call	 DWORD PTR [edx+8]

; 287  : 
; 288  : 	__SetFieldMusicFileInfo(mainChrPacket.szBGMName, mainChrPacket.fBGMVol);

  00088	f3 0f 10 55 e1	 movss	 xmm2, DWORD PTR _mainChrPacket$[ebp+57]
  0008d	8d 45 c8	 lea	 eax, DWORD PTR _mainChrPacket$[ebp+32]
  00090	50		 push	 eax
  00091	e8 00 00 00 00	 call	 ?__SetFieldMusicFileInfo@CPythonNetworkStream@@IAEXPBDM@Z ; CPythonNetworkStream::__SetFieldMusicFileInfo

; 289  : 
; 290  : 	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_LOAD], "LoadData", Py_BuildValue("(ii)", mainChrPacket.lX, mainChrPacket.lY));

  00096	ff 75 e9	 push	 DWORD PTR _mainChrPacket$[ebp+65]
  00099	ff 75 e5	 push	 DWORD PTR _mainChrPacket$[ebp+61]
  0009c	68 00 00 00 00	 push	 OFFSET ??_C@_04INACLLOK@?$CIii?$CJ?$AA@
  000a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  000a7	50		 push	 eax
  000a8	68 00 00 00 00	 push	 OFFSET ??_C@_08JHMIFHMN@LoadData?$AA@
  000ad	ff b7 8c 01 00
	00		 push	 DWORD PTR [edi+396]
  000b3	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  000b8	83 c4 18	 add	 esp, 24			; 00000018H

; 291  : 
; 292  : 	//Tracef(" >> RecvMainCharacterNew : %d\n", m_dwMainActorEmpire);
; 293  : 
; 294  : 	SendClientVersionPacket();

  000bb	8b cf		 mov	 ecx, edi
  000bd	e8 00 00 00 00	 call	 ?SendClientVersionPacket@CPythonNetworkStream@@QAE_NXZ ; CPythonNetworkStream::SendClientVersionPacket

; 295  : 	return true;
; 296  : }

  000c2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c5	b0 01		 mov	 al, 1
  000c7	5f		 pop	 edi
  000c8	33 cd		 xor	 ecx, ebp
  000ca	5e		 pop	 esi
  000cb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d0	8b e5		 mov	 esp, ebp
  000d2	5d		 pop	 ebp
  000d3	c3		 ret	 0
?RecvMainCharacter4_BGM_VOL@CPythonNetworkStream@@IAE_NXZ ENDP ; CPythonNetworkStream::RecvMainCharacter4_BGM_VOL
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphaseloading.cpp
;	COMDAT ??__Egs_fieldMusic_fileName@@YAXXZ
text$di	SEGMENT
??__Egs_fieldMusic_fileName@@YAXXZ PROC			; `dynamic initializer for 'gs_fieldMusic_fileName'', COMDAT

; 299  : static std::string	gs_fieldMusic_fileName;

  00000	68 00 00 00 00	 push	 OFFSET ??__Fgs_fieldMusic_fileName@@YAXXZ ; `dynamic atexit destructor for 'gs_fieldMusic_fileName''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__Egs_fieldMusic_fileName@@YAXXZ ENDP			; `dynamic initializer for 'gs_fieldMusic_fileName''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ??__Fgs_fieldMusic_fileName@@YAXXZ
text$yd	SEGMENT
$T1 = -1						; size = 1
$T2 = -1						; size = 1
??__Fgs_fieldMusic_fileName@@YAXXZ PROC			; `dynamic atexit destructor for 'gs_fieldMusic_fileName'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00004	83 3d 14 00 00
	00 10		 cmp	 DWORD PTR _gs_fieldMusic_fileName+20, 16 ; 00000010H
  0000b	72 2e		 jb	 SHORT $LN23@dynamic
  0000d	56		 push	 esi

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;

  0000e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _gs_fieldMusic_fileName

; 684  : 		return (_Alty());

  00014	8d 4d ff	 lea	 ecx, DWORD PTR $T2[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >

; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);

  0001c	68 00 00 00 00	 push	 OFFSET _gs_fieldMusic_fileName
  00021	8d 4d ff	 lea	 ecx, DWORD PTR $T2[ebp]
  00024	e8 00 00 00 00	 call	 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 684  : 		return (_Alty());

  00029	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  0002c	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00031	56		 push	 esi
  00032	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00037	83 c4 04	 add	 esp, 4
  0003a	5e		 pop	 esi
$LN23@dynamic:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  0003b	c7 05 14 00 00
	00 0f 00 00 00	 mov	 DWORD PTR _gs_fieldMusic_fileName+20, 15 ; 0000000fH

; 685  : 		}
; 686  : 	};
; 687  : 
; 688  : 		// TEMPLATE CLASS basic_string
; 689  : template<class _Elem,
; 690  : 	class _Traits,
; 691  : 	class _Alloc>
; 692  : 	class basic_string
; 693  : 		: public _String_alloc<!is_empty<_Alloc>::value,
; 694  : 			_String_base_types<_Elem, _Alloc> >
; 695  : 	{	// null-terminated transparent array of elements
; 696  : public:
; 697  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
; 698  : 	typedef _String_alloc<!is_empty<_Alloc>::value,
; 699  : 		_String_base_types<_Elem, _Alloc> > _Mybase;
; 700  : 	typedef _Traits traits_type;
; 701  : 	typedef _Alloc allocator_type;
; 702  : 
; 703  : 	typedef typename _Mybase::_Alty _Alty;
; 704  : 
; 705  : 	typedef typename _Mybase::value_type value_type;
; 706  : 	typedef typename _Mybase::size_type size_type;
; 707  : 	typedef typename _Mybase::difference_type difference_type;
; 708  : 	typedef typename _Mybase::pointer pointer;
; 709  : 	typedef typename _Mybase::const_pointer const_pointer;
; 710  : 	typedef typename _Mybase::reference reference;
; 711  : 	typedef typename _Mybase::const_reference const_reference;
; 712  : 
; 713  : 	typedef typename _Mybase::iterator iterator;
; 714  : 	typedef typename _Mybase::const_iterator const_iterator;
; 715  : 
; 716  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 717  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 718  : 
; 719  : 	basic_string(const _Myt& _Right)
; 720  : 
; 721  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 722  : 
; 723  : 
; 724  : 		{	// construct by copying _Right
; 725  : 		_Tidy();
; 726  : 		assign(_Right, 0, npos);
; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00045	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR _gs_fieldMusic_fileName+16, 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0004f	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _gs_fieldMusic_fileName, 0
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
??__Fgs_fieldMusic_fileName@@YAXXZ ENDP			; `dynamic atexit destructor for 'gs_fieldMusic_fileName''
text$yd	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphaseloading.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphaseloading.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphaseloading.cpp
;	COMDAT ?__SetFieldMusicFileName@CPythonNetworkStream@@IAEXPBD@Z
_TEXT	SEGMENT
_musicName$ = 8						; size = 4
?__SetFieldMusicFileName@CPythonNetworkStream@@IAEXPBD@Z PROC ; CPythonNetworkStream::__SetFieldMusicFileName, COMDAT
; _this$dead$ = ecx

; 303  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

  00003	8b 55 08	 mov	 edx, DWORD PTR _musicName$[ebp]
  00006	80 3a 00	 cmp	 BYTE PTR [edx], 0
  00009	75 12		 jne	 SHORT $LN9@SetFieldMu
  0000b	33 c0		 xor	 eax, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  0000d	b9 00 00 00 00	 mov	 ecx, OFFSET _gs_fieldMusic_fileName
  00012	50		 push	 eax
  00013	52		 push	 edx
  00014	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphaseloading.cpp

; 305  : }

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
$LN9@SetFieldMu:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

  0001d	8b c2		 mov	 eax, edx
  0001f	56		 push	 esi
  00020	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
$LL11@SetFieldMu:
  00023	8a 08		 mov	 cl, BYTE PTR [eax]
  00025	40		 inc	 eax
  00026	84 c9		 test	 cl, cl
  00028	75 f9		 jne	 SHORT $LL11@SetFieldMu
  0002a	2b c6		 sub	 eax, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  0002c	b9 00 00 00 00	 mov	 ecx, OFFSET _gs_fieldMusic_fileName
  00031	5e		 pop	 esi
  00032	50		 push	 eax
  00033	52		 push	 edx
  00034	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphaseloading.cpp

; 305  : }

  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?__SetFieldMusicFileName@CPythonNetworkStream@@IAEXPBD@Z ENDP ; CPythonNetworkStream::__SetFieldMusicFileName
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphaseloading.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphaseloading.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphaseloading.cpp
;	COMDAT ?__SetFieldMusicFileInfo@CPythonNetworkStream@@IAEXPBDM@Z
_TEXT	SEGMENT
_vol$1$ = -4						; size = 4
_musicName$ = 8						; size = 4
?__SetFieldMusicFileInfo@CPythonNetworkStream@@IAEXPBDM@Z PROC ; CPythonNetworkStream::__SetFieldMusicFileInfo, COMDAT
; _this$dead$ = ecx
; _vol$ = xmm2s

; 308  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

  00004	8b 55 08	 mov	 edx, DWORD PTR _musicName$[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphaseloading.cpp

; 308  : {

  00007	f3 0f 11 55 fc	 movss	 DWORD PTR _vol$1$[ebp], xmm2
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

  0000c	80 3a 00	 cmp	 BYTE PTR [edx], 0
  0000f	75 04		 jne	 SHORT $LN9@SetFieldMu
  00011	33 c9		 xor	 ecx, ecx
  00013	eb 15		 jmp	 SHORT $LN10@SetFieldMu
$LN9@SetFieldMu:
  00015	8b ca		 mov	 ecx, edx
  00017	56		 push	 esi
  00018	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
  0001b	eb 03 8d 49 00	 npad	 5
$LL11@SetFieldMu:
  00020	8a 01		 mov	 al, BYTE PTR [ecx]
  00022	41		 inc	 ecx
  00023	84 c0		 test	 al, al
  00025	75 f9		 jne	 SHORT $LL11@SetFieldMu
  00027	2b ce		 sub	 ecx, esi
  00029	5e		 pop	 esi
$LN10@SetFieldMu:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  0002a	51		 push	 ecx
  0002b	52		 push	 edx
  0002c	b9 00 00 00 00	 mov	 ecx, OFFSET _gs_fieldMusic_fileName
  00031	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamphaseloading.cpp

; 310  : 	gs_fieldMusic_volume = vol;

  00036	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _vol$1$[ebp]
  0003b	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR _gs_fieldMusic_volume, xmm0

; 311  : }

  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
?__SetFieldMusicFileInfo@CPythonNetworkStream@@IAEXPBDM@Z ENDP ; CPythonNetworkStream::__SetFieldMusicFileInfo
_TEXT	ENDS
END
