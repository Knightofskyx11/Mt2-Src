; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	D:\Metin2\Metin2\client_source_clean\client_source_clean\source\UserInterface\InsultChecker.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_R2CInsultChecker@@8				; CInsultChecker::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CInsultChecker@@8			; CInsultChecker::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3CInsultChecker@@8				; CInsultChecker::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVCInsultChecker@@@8			; CInsultChecker `RTTI Type Descriptor'
PUBLIC	??_R4CInsultChecker@@6B@			; CInsultChecker::`RTTI Complete Object Locator'
PUBLIC	??_7CInsultChecker@@6B@				; CInsultChecker::`vftable'
;	COMDAT ??_7CInsultChecker@@6B@
CONST	SEGMENT
??_7CInsultChecker@@6B@ DD FLAT:??_R4CInsultChecker@@6B@ ; CInsultChecker::`vftable'
	DD	FLAT:??_ECInsultChecker@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4CInsultChecker@@6B@
rdata$r	SEGMENT
??_R4CInsultChecker@@6B@ DD 00H				; CInsultChecker::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCInsultChecker@@@8
	DD	FLAT:??_R3CInsultChecker@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCInsultChecker@@@8
data$r	SEGMENT
??_R0?AVCInsultChecker@@@8 DD FLAT:??_7type_info@@6B@	; CInsultChecker `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCInsultChecker@@', 00H
data$r	ENDS
;	COMDAT ??_R3CInsultChecker@@8
rdata$r	SEGMENT
??_R3CInsultChecker@@8 DD 00H				; CInsultChecker::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CInsultChecker@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CInsultChecker@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CInsultChecker@@8 DD FLAT:??_R0?AVCInsultChecker@@@8 ; CInsultChecker::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CInsultChecker@@8
rdata$r	ENDS
;	COMDAT ??_R2CInsultChecker@@8
rdata$r	SEGMENT
??_R2CInsultChecker@@8 DD FLAT:??_R1A@?0A@EA@CInsultChecker@@8 ; CInsultChecker::`RTTI Base Class Array'
PUBLIC	??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z ; std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
PUBLIC	??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator_traits@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV31@@Z ; std::allocator_traits<std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
PUBLIC	??$construct@PAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@AAPAU21@@Z ; std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> >::construct<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> *,std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> * &>
PUBLIC	??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$destroy@PAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@@Z ; std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> >::destroy<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> *>
PUBLIC	??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
PUBLIC	??$construct@PAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@1@PAPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@AAPAU31@@Z ; std::allocator_traits<std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> > >::construct<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> *,std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> * &>
PUBLIC	??$forward@AAPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@YAAAPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> * &>
PUBLIC	??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator_traits@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::allocator_traits<std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$destroy@PAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@1@PAPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@@Z ; std::allocator_traits<std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> > >::destroy<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> *>
PUBLIC	??$_Buynode@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_buy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@PAU21@0ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_List_buy<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Buynode<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
PUBLIC	?max_size@?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@QBEIXZ ; std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> >::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@2@@Z ; std::allocator_traits<std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> > >::max_size
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> > >::max_size
PUBLIC	?max_size@?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::list<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
PUBLIC	?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Iterator_base0>::_Mynode
PUBLIC	?_Incsize@?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z ; std::list<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Incsize
PUBLIC	??$_Allocate@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@YAPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@0@IPAU10@@Z ; std::_Allocate<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> >
PUBLIC	??$construct@PAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@AAPAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> > >::construct<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> *,std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> * &>
PUBLIC	??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$destroy@PAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> > >::destroy<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> *>
PUBLIC	??$addressof@PAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@YAPAPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> *>
PUBLIC	??$_Insert@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U_Iterator_base0@2@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::list<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Insert<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
PUBLIC	?allocate@?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@QAEPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@I@Z ; std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> >::allocate
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> > >::allocate
PUBLIC	??0?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@QAE@XZ ; std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> >::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> >
PUBLIC	?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@PAU32@0@Z ; std::_List_alloc<0,std::_List_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Buynode0
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Iterator_base0>
PUBLIC	??0?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ ; std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	?deallocate@?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@QAEXPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@I@Z ; std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> >::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> > >::_Wrap_alloc<std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> > >
PUBLIC	?_Buyheadnode@?$_List_alloc@$0A@U?$_List_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@XZ ; std::_List_alloc<0,std::_List_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Buyheadnode
PUBLIC	??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Iterator_base0>
PUBLIC	??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	?_Myval@?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@@Z ; std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Myval
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> > >::deallocate
PUBLIC	?_Getal@?$_List_alloc@$0A@U?$_List_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@2@XZ ; std::_List_alloc<0,std::_List_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
PUBLIC	?_Freeheadnode@?$_List_alloc@$0A@U?$_List_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEXPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@@Z ; std::_List_alloc<0,std::_List_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Freeheadnode
PUBLIC	??0?$_List_alloc@$0A@U?$_List_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_List_alloc<0,std::_List_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_List_alloc<0,std::_List_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator==
PUBLIC	??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator++
PUBLIC	??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator*
PUBLIC	??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	?_Prevnode@?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAAAPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Prevnode
PUBLIC	?_Nextnode@?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAAAPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Nextnode
PUBLIC	??1?$_List_alloc@$0A@U?$_List_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@XZ ; std::_List_alloc<0,std::_List_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~_List_alloc<0,std::_List_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	?_Freenode@?$_List_buy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@@Z ; std::_List_buy<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Freenode
PUBLIC	??0?$_List_buy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_List_buy<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_List_buy<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	?_Tidy@?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ ; std::list<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
PUBLIC	?_Unchecked_end@?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@XZ ; std::list<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Unchecked_end
PUBLIC	??1?$_List_buy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::_List_buy<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_List_buy<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator!=
PUBLIC	??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator++
PUBLIC	??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator*
PUBLIC	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	?clear@?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ ; std::list<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::clear
PUBLIC	?push_back@?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::list<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
PUBLIC	?end@?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@XZ ; std::list<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::end
PUBLIC	?begin@?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@XZ ; std::list<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin
PUBLIC	??1?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::list<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~list<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??0?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::list<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::list<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	?IsInsultIn@CInsultChecker@@QAE_NPBDI@Z		; CInsultChecker::IsInsultIn
PUBLIC	?FilterInsult@CInsultChecker@@QAEXPADI@Z	; CInsultChecker::FilterInsult
PUBLIC	?__IsInsult@CInsultChecker@@AAE_NPBD@Z		; CInsultChecker::__IsInsult
PUBLIC	?__GetInsultLength@CInsultChecker@@AAE_NPBDPAI@Z ; CInsultChecker::__GetInsultLength
PUBLIC	?AppendInsult@CInsultChecker@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CInsultChecker::AppendInsult
PUBLIC	?Clear@CInsultChecker@@QAEXXZ			; CInsultChecker::Clear
PUBLIC	??1CInsultChecker@@UAE@XZ			; CInsultChecker::~CInsultChecker
PUBLIC	??_GCInsultChecker@@UAEPAXI@Z			; CInsultChecker::`scalar deleting destructor'
PUBLIC	??0CInsultChecker@@QAE@XZ			; CInsultChecker::CInsultChecker
EXTRN	??_ECInsultChecker@@UAEPAXI@Z:PROC		; CInsultChecker::`vector deleting destructor'
;	COMDAT ?s_kInsultChecker@?1??GetSingleton@CInsultChecker@@QAEAAV2@XZ@4V2@A
_BSS	SEGMENT
?s_kInsultChecker@?1??GetSingleton@CInsultChecker@@QAEAAV2@XZ@4V2@A DB 0cH DUP (?) ; `CInsultChecker::GetSingleton'::`2'::s_kInsultChecker
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Buynode@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_buy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@PAU21@0ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Buynode@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_buy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@PAU21@0ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Buynode@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_buy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@PAU21@0ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Buynode@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_buy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@PAU21@0ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Buynode@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_buy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@PAU21@0ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$2
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Buynode@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_buy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@PAU21@0ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Buynode@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_buy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@PAU21@0ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$3
__catchsym$??$_Buynode@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_buy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@PAU21@0ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Buynode@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_buy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@PAU21@0ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator_traits@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV31@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator_traits@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV31@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator_traits@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV31@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator_traits@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV31@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z$0
; Function compile flags: /Ogtp
;	COMDAT ??__Fs_kInsultChecker@?1??GetSingleton@CInsultChecker@@QAEAAV1@XZ@YAXXZ
text$yd	SEGMENT
??__Fs_kInsultChecker@?1??GetSingleton@CInsultChecker@@QAEAAV1@XZ@YAXXZ PROC ; `CInsultChecker::GetSingleton'::`2'::`dynamic atexit destructor for 's_kInsultChecker'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kInsultChecker@?1??GetSingleton@CInsultChecker@@QAEAAV2@XZ@4V2@A
  00005	e9 00 00 00 00	 jmp	 ??1CInsultChecker@@UAE@XZ ; CInsultChecker::~CInsultChecker
??__Fs_kInsultChecker@?1??GetSingleton@CInsultChecker@@QAEAAV1@XZ@YAXXZ ENDP ; `CInsultChecker::GetSingleton'::`2'::`dynamic atexit destructor for 's_kInsultChecker''
text$yd	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\insultchecker.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\insultchecker.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\insultchecker.cpp
;	COMDAT ??0CInsultChecker@@QAE@XZ
_TEXT	SEGMENT
??0CInsultChecker@@QAE@XZ PROC				; CInsultChecker::CInsultChecker, COMDAT
; _this$ = ecx

; 11   : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 767  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  00004	6a 00		 push	 0
  00006	6a 00		 push	 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\insultchecker.cpp

; 11   : {

  00008	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7CInsultChecker@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 767  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  0000e	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]

; 527  : 		this->_Myhead = 0;

  00011	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 528  : 		this->_Mysize = 0;

  00018	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0

; 767  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  0001f	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@PAU32@0@Z ; std::_List_alloc<0,std::_List_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Buynode0

; 529  : 		}
; 530  : 
; 531  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 532  : 		{	// return reference to successor pointer in node
; 533  : 		return ((_Nodepref)_Pnode->_Next);
; 534  : 		}
; 535  : 
; 536  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 537  : 		{	// return reference to predecessor pointer in node
; 538  : 		return ((_Nodepref)_Pnode->_Prev);
; 539  : 		}
; 540  : 
; 541  : 	static reference _Myval(_Nodeptr _Pnode)
; 542  : 		{	// return reference to value in node
; 543  : 		return ((reference)_Pnode->_Myval);
; 544  : 		}
; 545  : 
; 546  : 	_Nodeptr _Myhead;	// pointer to head node
; 547  : 	size_type _Mysize;	// number of elements
; 548  : 	};
; 549  : 
; 550  : 		// TEMPLATE CLASS _List_alloc
; 551  : template<bool _Al_has_storage,
; 552  : 	class _Alloc_types>
; 553  : 	class _List_alloc
; 554  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 555  : 	{	// base class for list to hold allocator with storage
; 556  : public:
; 557  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 558  : 
; 559  : 	typedef _List_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 560  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 561  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 562  : 	typedef typename _Alloc_types::_Node _Node;
; 563  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 564  : 
; 565  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 566  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 567  : 		: _Alnod(_Al)
; 568  : 		{	// construct head node, allocator from _Al
; 569  : 		this->_Myhead = _Buyheadnode();
; 570  : 		}
; 571  : 
; 572  : 	~_List_alloc() _NOEXCEPT
; 573  : 		{	// destroy head node
; 574  : 		_Freeheadnode(this->_Myhead);
; 575  : 		}
; 576  : 
; 577  : 	void _Change_alloc(const _Alty& _Al)
; 578  : 		{	// replace old allocator
; 579  : 		this->_Alnod = _Al;
; 580  : 		}
; 581  : 
; 582  : 	void _Swap_alloc(_Myt& _Right)
; 583  : 		{	// swap allocators
; 584  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 585  : 		}
; 586  : 
; 587  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 588  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 589  : 		: _Alnod(_Al)
; 590  : 		{	// construct head node, allocator from _Al
; 591  : 		this->_Myhead = _Buyheadnode();
; 592  : 		_TRY_BEGIN
; 593  : 		_Alloc_proxy();
; 594  : 		_CATCH_ALL
; 595  : 		_Freeheadnode(this->_Myhead);
; 596  : 		_RERAISE;
; 597  : 		_CATCH_END
; 598  : 		}
; 599  : 
; 600  : 	~_List_alloc() _NOEXCEPT
; 601  : 		{	// destroy proxy
; 602  : 		_Freeheadnode(this->_Myhead);
; 603  : 		_Free_proxy();
; 604  : 		}
; 605  : 
; 606  : 	void _Change_alloc(const _Alty& _Al)
; 607  : 		{	// replace old allocator
; 608  : 		_Free_proxy();
; 609  : 		this->_Alnod = _Al;
; 610  : 		_Alloc_proxy();
; 611  : 		}
; 612  : 
; 613  : 	void _Swap_alloc(_Myt& _Right)
; 614  : 		{	// swap allocators
; 615  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 616  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 617  : 		}
; 618  : 
; 619  : 	void _Alloc_proxy()
; 620  : 		{	// construct proxy from _Alnod
; 621  : 		typename _Alty::template rebind<_Container_proxy>::other
; 622  : 			_Alproxy(this->_Alnod);
; 623  : 		this->_Myproxy = _Alproxy.allocate(1);
; 624  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 625  : 		this->_Myproxy->_Mycont = this;
; 626  : 		}
; 627  : 
; 628  : 	void _Free_proxy()
; 629  : 		{	// destroy proxy
; 630  : 		typename _Alty::template rebind<_Container_proxy>::other
; 631  : 			_Alproxy(this->_Alnod);
; 632  : 		this->_Orphan_all();
; 633  : 		_Alproxy.destroy(this->_Myproxy);
; 634  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 635  : 		this->_Myproxy = 0;
; 636  : 		}
; 637  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 638  : 
; 639  : 	_Nodeptr _Buyheadnode()
; 640  : 		{	// get head node using current allocator
; 641  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));
; 642  : 		}
; 643  : 
; 644  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 645  : 		{	// free head node using current allocator
; 646  : 		this->_Alnod.destroy(
; 647  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 648  : 		this->_Alnod.destroy(
; 649  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 650  : 		this->_Alnod.deallocate(_Pnode, 1);
; 651  : 		}
; 652  : 
; 653  : 	_Nodeptr _Buynode0(_Nodeptr _Next,
; 654  : 		_Nodeptr _Prev)
; 655  : 		{	// allocate a node and set links
; 656  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 657  : 
; 658  : 		if (_Next == _Nodeptr())
; 659  : 			{	// point at self
; 660  : 			_Next = _Pnode;
; 661  : 			_Prev = _Pnode;
; 662  : 			}
; 663  : 		_TRY_BEGIN
; 664  : 		this->_Alnod.construct(
; 665  : 			_STD addressof(this->_Nextnode(_Pnode)), _Next);
; 666  : 		this->_Alnod.construct(
; 667  : 			_STD addressof(this->_Prevnode(_Pnode)), _Prev);
; 668  : 		_CATCH_ALL
; 669  : 		this->_Alnod.deallocate(_Pnode, 1);
; 670  : 		_RERAISE;
; 671  : 		_CATCH_END
; 672  : 
; 673  : 		return (_Pnode);
; 674  : 		}
; 675  : 
; 676  : 	_Alty& _Getal()
; 677  : 		{	// get reference to allocator
; 678  : 		return (this->_Alnod);
; 679  : 		}
; 680  : 
; 681  : 	const _Alty& _Getal() const
; 682  : 		{	// get reference to allocator
; 683  : 		return (this->_Alnod);
; 684  : 		}
; 685  : 	};
; 686  : 
; 687  : 		// TEMPLATE CLASS _List_alloc
; 688  : template<class _Alloc_types>
; 689  : 	class _List_alloc<false, _Alloc_types>
; 690  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 691  : 	{	// base class for list to hold allocator with no storage
; 692  : public:
; 693  : 	typedef _List_alloc<false, _Alloc_types> _Myt;
; 694  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 695  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 696  : 	typedef typename _Alloc_types::_Node _Node;
; 697  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 698  : 
; 699  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 700  : 	_List_alloc(const _Alloc& = _Alloc())
; 701  : 		{	// construct head node, allocator from _Al
; 702  : 		this->_Myhead = _Buyheadnode();

  00024	89 47 04	 mov	 DWORD PTR [edi+4], eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\insultchecker.cpp

; 12   : }

  00027	8b c7		 mov	 eax, edi
  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi
  0002b	c3		 ret	 0
??0CInsultChecker@@QAE@XZ ENDP				; CInsultChecker::CInsultChecker
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCInsultChecker@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCInsultChecker@@UAEPAXI@Z PROC			; CInsultChecker::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CInsultChecker@@UAE@XZ ; CInsultChecker::~CInsultChecker
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GCInsultChecker@@UAEPAXI@Z ENDP			; CInsultChecker::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\insultchecker.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\insultchecker.cpp
;	COMDAT ??1CInsultChecker@@UAE@XZ
_TEXT	SEGMENT
??1CInsultChecker@@UAE@XZ PROC				; CInsultChecker::~CInsultChecker, COMDAT
; _this$ = ecx

; 15   : {

  00000	56		 push	 esi

; 16   : }

  00001	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
  00004	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CInsultChecker@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 1883 : 		clear();

  0000a	8b ce		 mov	 ecx, esi
  0000c	e8 00 00 00 00	 call	 ?clear@?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ ; std::list<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::clear
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00011	ff 36		 push	 DWORD PTR [esi]
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	83 c4 04	 add	 esp, 4
  0001b	5e		 pop	 esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\insultchecker.cpp

; 16   : }

  0001c	c3		 ret	 0
??1CInsultChecker@@UAE@XZ ENDP				; CInsultChecker::~CInsultChecker
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\insultchecker.cpp
;	COMDAT ?Clear@CInsultChecker@@QAEXXZ
_TEXT	SEGMENT
?Clear@CInsultChecker@@QAEXXZ PROC			; CInsultChecker::Clear, COMDAT
; _this$ = ecx

; 20   : 	m_kList_stInsult.clear();

  00000	83 c1 04	 add	 ecx, 4
  00003	e9 00 00 00 00	 jmp	 ?clear@?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ ; std::list<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::clear
?Clear@CInsultChecker@@QAEXXZ ENDP			; CInsultChecker::Clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\insultchecker.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\insultchecker.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\insultchecker.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\insultchecker.cpp
;	COMDAT ?AppendInsult@CInsultChecker@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_c_rstInsult$ = 8					; size = 4
?AppendInsult@CInsultChecker@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CInsultChecker::AppendInsult, COMDAT
; _this$ = ecx

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (c_rstInsult.length()>0)

  00003	8b 45 08	 mov	 eax, DWORD PTR _c_rstInsult$[ebp]
  00006	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0000a	76 33		 jbe	 SHORT $LN16@AppendInsu
  0000c	56		 push	 esi
  0000d	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 96   : 		return (_Ptr);

  0000e	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\insultchecker.cpp

; 26   : 		m_kList_stInsult.push_back(c_rstInsult);

  00011	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 1062 : 				_STD forward<_Valty>(_Val)...);

  00014	50		 push	 eax
  00015	8b ce		 mov	 ecx, esi
  00017	ff 77 04	 push	 DWORD PTR [edi+4]
  0001a	57		 push	 edi
  0001b	e8 00 00 00 00	 call	 ??$_Buynode@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_buy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@PAU21@0ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_List_buy<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Buynode<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
  00020	8b d0		 mov	 edx, eax

; 1066 : 		}
; 1067 : 
; 1068 : 
; 1069 : 	list(_XSTD initializer_list<_Ty> _Ilist,
; 1070 : 		const _Alloc& _Al = allocator_type())
; 1071 : 		: _Mybase(_Al)
; 1072 : 		{	// construct from initializer_list
; 1073 : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 1074 : 		}
; 1075 : 
; 1076 : 	_Myt& operator=(_XSTD initializer_list<_Ty> _Ilist)
; 1077 : 		{	// assign initializer_list
; 1078 : 		assign(_Ilist.begin(), _Ilist.end());
; 1079 : 		return (*this);
; 1080 : 		}
; 1081 : 
; 1082 : 	void assign(_XSTD initializer_list<_Ty> _Ilist)
; 1083 : 		{	// assign initializer_list
; 1084 : 		assign(_Ilist.begin(), _Ilist.end());
; 1085 : 		}
; 1086 : 
; 1087 : 	iterator insert(const_iterator _Where,
; 1088 : 		_XSTD initializer_list<_Ty> _Ilist)
; 1089 : 		{	// insert initializer_list
; 1090 : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 1091 : 		}
; 1092 : 
; 1093 : 	~list() _NOEXCEPT
; 1094 : 		{	// destroy the object
; 1095 : 		_Tidy();
; 1096 : 		}
; 1097 : 
; 1098 : 	_Myt& operator=(const _Myt& _Right)
; 1099 : 		{	// assign _Right
; 1100 : 		if (this != &_Right)
; 1101 : 			{	// different, assign it
; 1102 : 			if (this->_Getal() != _Right._Getal()
; 1103 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1104 : 				{	// change allocator before copying
; 1105 : 				clear();
; 1106 : 				this->_Change_alloc(_Right._Getal());
; 1107 : 				}
; 1108 : 
; 1109 : 			assign(_Right.begin(), _Right.end());
; 1110 : 			}
; 1111 : 		return (*this);
; 1112 : 		}
; 1113 : 
; 1114 : 	iterator begin() _NOEXCEPT
; 1115 : 		{	// return iterator for beginning of mutable sequence
; 1116 : 		return (iterator(this->_Nextnode(this->_Myhead), this));
; 1117 : 		}
; 1118 : 
; 1119 : 	const_iterator begin() const _NOEXCEPT
; 1120 : 		{	// return iterator for beginning of nonmutable sequence
; 1121 : 		return (const_iterator(this->_Nextnode(this->_Myhead), this));
; 1122 : 		}
; 1123 : 
; 1124 : 	iterator end() _NOEXCEPT
; 1125 : 		{	// return iterator for end of mutable sequence
; 1126 : 		return (iterator(this->_Myhead, this));
; 1127 : 		}
; 1128 : 
; 1129 : 	const_iterator end() const _NOEXCEPT
; 1130 : 		{	// return iterator for end of nonmutable sequence
; 1131 : 		return (const_iterator(this->_Myhead, this));
; 1132 : 		}
; 1133 : 
; 1134 : 	_Unchecked_iterator _Unchecked_begin()
; 1135 : 		{	// return iterator for beginning of mutable sequence
; 1136 : 		return (_Unchecked_iterator(this->_Nextnode(this->_Myhead),
; 1137 : 			this));
; 1138 : 		}
; 1139 : 
; 1140 : 	_Unchecked_const_iterator _Unchecked_begin() const
; 1141 : 		{	// return iterator for beginning of nonmutable sequence
; 1142 : 		return (_Unchecked_const_iterator(this->_Nextnode(this->_Myhead),
; 1143 : 			this));
; 1144 : 		}
; 1145 : 
; 1146 : 	_Unchecked_iterator _Unchecked_end()
; 1147 : 		{	// return unchecked iterator for end of mutable sequence
; 1148 : 		return (_Unchecked_iterator(this->_Myhead, this));
; 1149 : 		}
; 1150 : 
; 1151 : 	_Unchecked_const_iterator _Unchecked_end() const
; 1152 : 		{	// return unchecked iterator for end of nonmutable sequence
; 1153 : 		return (_Unchecked_const_iterator(this->_Myhead, this));
; 1154 : 		}
; 1155 : 
; 1156 : 	iterator _Make_iter(const_iterator _Where) const _NOEXCEPT
; 1157 : 		{	// make iterator from const_iterator
; 1158 : 		return (iterator(_Where._Ptr, this));
; 1159 : 		}
; 1160 : 
; 1161 : 	iterator _Make_iter(_Unchecked_const_iterator _Where) const
; 1162 : 		{	// make iterator from _Unchecked_const_iterator
; 1163 : 		return (iterator(_Where._Ptr, this));
; 1164 : 		}
; 1165 : 
; 1166 : 	reverse_iterator rbegin() _NOEXCEPT
; 1167 : 		{	// return iterator for beginning of reversed mutable sequence
; 1168 : 		return (reverse_iterator(end()));
; 1169 : 		}
; 1170 : 
; 1171 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1172 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1173 : 		return (const_reverse_iterator(end()));
; 1174 : 		}
; 1175 : 
; 1176 : 	reverse_iterator rend() _NOEXCEPT
; 1177 : 		{	// return iterator for end of reversed mutable sequence
; 1178 : 		return (reverse_iterator(begin()));
; 1179 : 		}
; 1180 : 
; 1181 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1182 : 		{	// return iterator for end of reversed nonmutable sequence
; 1183 : 		return (const_reverse_iterator(begin()));
; 1184 : 		}
; 1185 : 
; 1186 : 	const_iterator cbegin() const _NOEXCEPT
; 1187 : 		{	// return iterator for beginning of nonmutable sequence
; 1188 : 		return (((const _Myt *)this)->begin());
; 1189 : 		}
; 1190 : 
; 1191 : 	const_iterator cend() const _NOEXCEPT
; 1192 : 		{	// return iterator for end of nonmutable sequence
; 1193 : 		return (((const _Myt *)this)->end());
; 1194 : 		}
; 1195 : 
; 1196 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1197 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1198 : 		return (((const _Myt *)this)->rbegin());
; 1199 : 		}
; 1200 : 
; 1201 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1202 : 		{	// return iterator for end of reversed nonmutable sequence
; 1203 : 		return (((const _Myt *)this)->rend());
; 1204 : 		}
; 1205 : 
; 1206 : 	void resize(size_type _Newsize)
; 1207 : 		{	// determine new length, padding with _Ty() elements as needed
; 1208 : 		if (this->_Mysize < _Newsize)
; 1209 : 			{	// pad to make larger
; 1210 : 			size_type _Count = 0;
; 1211 : 			_TRY_BEGIN
; 1212 : 			for (; this->_Mysize < _Newsize; ++_Count)
; 1213 : 				_Insert(_Unchecked_end());
; 1214 : 			_CATCH_ALL
; 1215 : 			for (; 0 < _Count; --_Count)
; 1216 : 				pop_back();	// undo inserts
; 1217 : 			_RERAISE;
; 1218 : 			_CATCH_END
; 1219 : 			}
; 1220 : 		else
; 1221 : 			while (_Newsize < this->_Mysize)
; 1222 : 				pop_back();
; 1223 : 		}
; 1224 : 
; 1225 : 	void resize(size_type _Newsize, const _Ty& _Val)
; 1226 : 		{	// determine new length, padding with _Val elements as needed
; 1227 : 		if (this->_Mysize < _Newsize)
; 1228 : 			_Insert_n(_Unchecked_end(), _Newsize - this->_Mysize, _Val);
; 1229 : 		else
; 1230 : 			while (_Newsize < this->_Mysize)
; 1231 : 				pop_back();
; 1232 : 		}
; 1233 : 
; 1234 : 	size_type size() const _NOEXCEPT
; 1235 : 		{	// return length of sequence
; 1236 : 		return (this->_Mysize);
; 1237 : 		}
; 1238 : 
; 1239 : 	size_type max_size() const _NOEXCEPT
; 1240 : 		{	// return maximum possible length of sequence
; 1241 : 		return (this->_Getal().max_size());
; 1242 : 		}
; 1243 : 
; 1244 : 	bool empty() const _NOEXCEPT
; 1245 : 		{	// test if sequence is empty
; 1246 : 		return (this->_Mysize == 0);
; 1247 : 		}
; 1248 : 
; 1249 : 	allocator_type get_allocator() const _NOEXCEPT
; 1250 : 		{	// return allocator object for values
; 1251 : 		return (this->_Getal());
; 1252 : 		}
; 1253 : 
; 1254 : 	reference front()
; 1255 : 		{	// return first element of mutable sequence
; 1256 : 		return (*begin());
; 1257 : 		}
; 1258 : 
; 1259 : 	const_reference front() const
; 1260 : 		{	// return first element of nonmutable sequence
; 1261 : 		return (*begin());
; 1262 : 		}
; 1263 : 
; 1264 : 	reference back()
; 1265 : 		{	// return last element of mutable sequence
; 1266 : 		return (*(--end()));
; 1267 : 		}
; 1268 : 
; 1269 : 	const_reference back() const
; 1270 : 		{	// return last element of nonmutable sequence
; 1271 : 		return (*(--end()));
; 1272 : 		}
; 1273 : 
; 1274 : 	void push_front(const _Ty& _Val)
; 1275 : 		{	// insert element at beginning
; 1276 : 		_Insert(_Unchecked_begin(), _Val);
; 1277 : 		}
; 1278 : 
; 1279 : 	void pop_front()
; 1280 : 		{	// erase element at beginning
; 1281 : 		erase(begin());
; 1282 : 		}
; 1283 : 
; 1284 : 	void push_back(const _Ty& _Val)
; 1285 : 		{	// insert element at end
; 1286 : 		_Insert(_Unchecked_end(), _Val);
; 1287 : 		}
; 1288 : 
; 1289 : 	void pop_back()
; 1290 : 		{	// erase element at end
; 1291 : 		erase(--end());
; 1292 : 		}
; 1293 : 
; 1294 : 	template<class _Iter>
; 1295 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1296 : 			void>::type
; 1297 : 		assign(_Iter _First, _Iter _Last)
; 1298 : 		{	// assign [_First, _Last), input iterators
; 1299 : 		iterator _Old = begin();
; 1300 : 		_TRY_BEGIN
; 1301 : 		for (; _First != _Last && _Old != end(); ++_First, ++_Old)
; 1302 : 			_Reusenode(_Old, *_First);
; 1303 : 		for (; _First != _Last; ++_First)
; 1304 : 			_Insert(_Unchecked_end(), *_First);
; 1305 : 		_CATCH_ALL
; 1306 : 		clear();
; 1307 : 		_RERAISE;
; 1308 : 		_CATCH_END
; 1309 : 		erase(_Old, end());
; 1310 : 		}
; 1311 : 
; 1312 : 	template<class _TArg>
; 1313 : 		void _Reusenode(iterator _Where, _TArg&& _Arg)
; 1314 : 		{	// destroy the element at _Where and reconstruct from _Arg
; 1315 : 		_TRY_BEGIN
; 1316 : 		this->_Getal().destroy(
; 1317 : 			_STD addressof(this->_Myval(_Where._Ptr)));
; 1318 : 		this->_Getal().construct(
; 1319 : 			_STD addressof(this->_Myval(_Where._Ptr)),
; 1320 : 			_STD forward<_TArg>(_Arg));
; 1321 : 		_CATCH_ALL
; 1322 : 		_Unlinknode(_Where);
; 1323 : 		this->_Getal().destroy(
; 1324 : 			_STD addressof(this->_Nextnode(_Where._Ptr)));
; 1325 : 		this->_Getal().destroy(
; 1326 : 			_STD addressof(this->_Prevnode(_Where._Ptr)));
; 1327 : 		this->_Getal().deallocate(_Where._Ptr, 1);
; 1328 : 		_RERAISE;
; 1329 : 		_CATCH_END
; 1330 : 		}
; 1331 : 
; 1332 : 	void assign(size_type _Count, const _Ty& _Val)
; 1333 : 		{	// assign _Count * _Val
; 1334 : 		clear();
; 1335 : 		_Insert_n(_Unchecked_begin(), _Count, _Val);
; 1336 : 		}
; 1337 : 
; 1338 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1339 : 		{	// insert _Val at _Where
; 1340 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1341 : 		if (_Where._Getcont() != this)
; 1342 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1343 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1344 : 
; 1345 : 		_Insert(_Where._Unchecked(), _Val);
; 1346 : 		return (_Make_iter(--_Where));
; 1347 : 		}
; 1348 : 
; 1349 : 	iterator insert(const_iterator _Where, size_type _Count, const _Ty& _Val)
; 1350 : 		{	// insert _Count * _Val at _Where
; 1351 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1352 : 		if (_Where._Getcont() != this)
; 1353 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1354 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1355 : 
; 1356 : 		iterator _Prev = _Make_iter(_Where);
; 1357 : 		if (_Prev == begin())
; 1358 : 			{	// insert sequence at beginning
; 1359 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1360 : 			return (begin());
; 1361 : 			}
; 1362 : 		else
; 1363 : 			{	// insert sequence not at beginning
; 1364 : 			--_Prev;
; 1365 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1366 : 			return (++_Prev);
; 1367 : 			}
; 1368 : 		}
; 1369 : 
; 1370 : 	template<class _Iter>
; 1371 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1372 : 			iterator>::type
; 1373 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1374 : 		{	// insert [_First, _Last) at _Where
; 1375 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1376 : 		if (_Where._Getcont() != this)
; 1377 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1378 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1379 : 
; 1380 : 		iterator _Prev = _Make_iter(_Where);
; 1381 : 		if (_Prev == begin())
; 1382 : 			{	// insert sequence at beginning
; 1383 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1384 : 				_Iter_cat(_First));
; 1385 : 			return (begin());
; 1386 : 			}
; 1387 : 		else
; 1388 : 			{	// insert sequence not at beginning
; 1389 : 			--_Prev;
; 1390 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1391 : 				_Iter_cat(_First));
; 1392 : 			return (++_Prev);
; 1393 : 			}
; 1394 : 		}
; 1395 : 
; 1396 : 	template<class _Iter>
; 1397 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1398 : 			_Iter _First, _Iter _Last, input_iterator_tag)
; 1399 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1400 : 		size_type _Num = 0;
; 1401 : 
; 1402 : 		_TRY_BEGIN
; 1403 : 		for (; _First != _Last; ++_First, ++_Num)
; 1404 : 			_Insert(_Where, *_First);
; 1405 : 		_CATCH_ALL
; 1406 : 		for (; 0 < _Num; --_Num)
; 1407 : 			{	// undo inserts
; 1408 : 			_Unchecked_const_iterator _Before = _Where;
; 1409 : 			_Unchecked_erase(--_Before);
; 1410 : 			}
; 1411 : 		_RERAISE;
; 1412 : 		_CATCH_END
; 1413 : 		}
; 1414 : 
; 1415 : 	template<class _Iter>
; 1416 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1417 : 			_Iter _First, _Iter _Last, forward_iterator_tag)
; 1418 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1419 : 		_DEBUG_RANGE(_First, _Last);
; 1420 : 		_Iter _Next = _First;
; 1421 : 
; 1422 : 		_TRY_BEGIN
; 1423 : 		for (; _First != _Last; ++_First)
; 1424 : 			_Insert(_Where, *_First);
; 1425 : 		_CATCH_ALL
; 1426 : 		for (; _Next != _First; ++_Next)
; 1427 : 			{	// undo inserts
; 1428 : 			_Unchecked_const_iterator _Before = _Where;
; 1429 : 			_Unchecked_erase(--_Before);
; 1430 : 			}
; 1431 : 		_RERAISE;
; 1432 : 		_CATCH_END
; 1433 : 		}
; 1434 : 
; 1435 : 	_Nodeptr _Unlinknode(const_iterator _Where)
; 1436 : 		{	// unlink node at _Where from the list
; 1437 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1438 : 		if (_Where._Getcont() != this || _Where._Ptr == this->_Myhead)
; 1439 : 			_DEBUG_ERROR("list erase iterator outside range");
; 1440 : 		_Nodeptr _Pnode = (_Where)._Mynode();
; 1441 : 		_Orphan_ptr(*this, _Pnode);
; 1442 : 
; 1443 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1444 : 		_Nodeptr _Pnode = (_Where)._Mynode();
; 1445 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1446 : 
; 1447 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1448 : 			this->_Nextnode(_Pnode);
; 1449 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1450 : 			this->_Prevnode(_Pnode);
; 1451 : 
; 1452 : 		--this->_Mysize;
; 1453 : 		return (_Pnode);
; 1454 : 		}
; 1455 : 
; 1456 : 	iterator erase(const_iterator _Where)
; 1457 : 		{	// erase element at _Where
; 1458 : 		_Nodeptr _Pnode = _Unlinknode(_Where++);
; 1459 : 		this->_Freenode(_Pnode);
; 1460 : 		return (_Make_iter(_Where));
; 1461 : 		}
; 1462 : 
; 1463 : 	void _Unchecked_erase(_Unchecked_const_iterator _Where)
; 1464 : 		{	// erase element at _Where
; 1465 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1466 : 
; 1467 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1468 : 			this->_Nextnode(_Pnode);
; 1469 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1470 : 			this->_Prevnode(_Pnode);
; 1471 : 		this->_Freenode(_Pnode);
; 1472 : 		--this->_Mysize;
; 1473 : 		}
; 1474 : 
; 1475 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1476 : 		{	// erase [_First, _Last)
; 1477 : 		if (_First == begin() && _Last == end())
; 1478 : 			{	// erase all and return fresh iterator
; 1479 : 			clear();
; 1480 : 			return (end());
; 1481 : 			}
; 1482 : 		else
; 1483 : 			{	// erase subrange
; 1484 : 			while (_First != _Last)
; 1485 : 				_First = erase(_First);
; 1486 : 			return (_Make_iter(_Last));
; 1487 : 			}
; 1488 : 		}
; 1489 : 
; 1490 : 	void clear() _NOEXCEPT
; 1491 : 		{	// erase all
; 1492 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1493 : 		this->_Orphan_ptr(*this, nullptr);
; 1494 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1495 : 
; 1496 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead);
; 1497 : 		this->_Nextnode(this->_Myhead) = this->_Myhead;
; 1498 : 		this->_Prevnode(this->_Myhead) = this->_Myhead;
; 1499 : 		this->_Mysize = 0;
; 1500 : 
; 1501 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead; _Pnode = _Pnext)
; 1502 : 			{	// delete an element
; 1503 : 			_Pnext = this->_Nextnode(_Pnode);
; 1504 : 			this->_Freenode(_Pnode);
; 1505 : 			}
; 1506 : 		}
; 1507 : 
; 1508 : 	void swap(_Myt& _Right)
; 1509 : 		{	// exchange contents with _Right
; 1510 : 		if (this == &_Right)
; 1511 : 			;	// same object, do nothing
; 1512 : 		else if (this->_Getal() == _Right._Getal())
; 1513 : 			{	// same allocator, swap control information
; 1514 : 			this->_Swap_all(_Right);
; 1515 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1516 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1517 : 			}
; 1518 : 
; 1519 : 		else if (_Alty::propagate_on_container_swap::value)
; 1520 : 			{	// swap allocators and control information
; 1521 : 			this->_Swap_alloc(_Right);
; 1522 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1523 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1524 : 			}
; 1525 : 
; 1526 : 		else	// containers are incompatible
; 1527 : 
; 1528 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1529 : 			_DEBUG_ERROR("list containers incompatible for swap");
; 1530 : 
; 1531 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1532 : 			_XSTD terminate();
; 1533 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1534 : 		}
; 1535 : 
; 1536 : 	void splice(const_iterator _Where, _Myt& _Right)
; 1537 : 		{	// splice all of _Right at _Where
; 1538 : 		if (this != &_Right && !_Right.empty())
; 1539 : 			{	// worth splicing, do it
; 1540 : 			_Splice(_Where, _Right, _Right.begin(), _Right.end(),
; 1541 : 				_Right._Mysize);
; 1542 : 			}
; 1543 : 		}
; 1544 : 
; 1545 : 	void splice(const_iterator _Where, _Myt&& _Right)
; 1546 : 		{	// splice all of _Right at _Where
; 1547 : 		splice(_Where, (_Myt&)_Right);
; 1548 : 		}
; 1549 : 
; 1550 : 	void splice(const_iterator _Where, _Myt& _Right,
; 1551 : 		const_iterator _First)
; 1552 : 		{	// splice _Right [_First, _First + 1) at _Where
; 1553 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1554 : 		if (_First == _Right.end())
; 1555 : 			_DEBUG_ERROR("list splice iterator outside range");
; 1556 : 		else
; 1557 : 
; 1558 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1559 : 		if (_First != _Right.end())
; 1560 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1561 : 
; 1562 : 			{	// element exists, try splice
; 1563 : 			const_iterator _Last = _First;
; 1564 : 			++_Last;
; 1565 : 			if (this != &_Right
; 1566 : 				|| (_Where != _First && _Where != _Last))
; 1567 : 				_Splice(_Where, _Right, _First, _Last, 1);
; 1568 : 			}
; 1569 : 		}
; 1570 : 
; 1571 : 	void splice(const_iterator _Where, _Myt&& _Right,
; 1572 : 		const_iterator _First)
; 1573 : 		{	// splice _Right [_First, _First + 1) at _Where
; 1574 : 		splice(_Where, (_Myt&)_Right, _First);
; 1575 : 		}
; 1576 : 
; 1577 : 	void splice(const_iterator _Where,
; 1578 : 		_Myt& _Right, const_iterator _First, const_iterator _Last)
; 1579 : 		{	// splice _Right [_First, _Last) at _Where
; 1580 : 		if (_First != _Last && (this != &_Right || _Where != _Last))
; 1581 : 			{	// worth splicing, do it
; 1582 : 			size_type _Count = 0;
; 1583 : 
; 1584 : 			if (this == &_Right)
; 1585 : 				;	// just rearrange this list
; 1586 : 			else if (_First == _Right.begin() && _Last == _Right.end())
; 1587 : 				_Count = _Right._Mysize;	// splice in whole list
; 1588 : 			else
; 1589 : 				{	// count nodes and check for knot
; 1590 : 				const_iterator _Next = _First;
; 1591 : 
; 1592 : 				for (; _Next != _Last; ++_Next, ++_Count)
; 1593 : 					if (_Next == _Right.end())
; 1594 : 						_Xlength_error("list<T> bad splice");
; 1595 : 				}
; 1596 : 			_Splice(_Where, _Right, _First, _Last, _Count);
; 1597 : 			}
; 1598 : 		}
; 1599 : 
; 1600 : 	void splice(const_iterator _Where,
; 1601 : 		_Myt&& _Right, const_iterator _First, const_iterator _Last)
; 1602 : 		{	// splice _Right [_First, _Last) at _Where
; 1603 : 		splice(_Where, (_Myt&)_Right, _First, _Last);
; 1604 : 		}
; 1605 : 
; 1606 : 	void remove(const _Ty& _Val)
; 1607 : 		{	// erase each element matching _Val
; 1608 : 		iterator _Val_it = end();
; 1609 : 
; 1610 : 		for (iterator _First = begin(); _First != end(); )
; 1611 : 			if (*_First == _Val)
; 1612 : 				if (_STD addressof(*_First) == _STD addressof(_Val))
; 1613 : 					_Val_it = _First++;
; 1614 : 				else
; 1615 : 					_First = erase(_First);
; 1616 : 			else
; 1617 : 				++_First;
; 1618 : 
; 1619 : 		if (_Val_it != end())
; 1620 : 			erase(_Val_it);
; 1621 : 		}
; 1622 : 
; 1623 : 	template<class _Pr1>
; 1624 : 		void remove_if(_Pr1 _Pred)
; 1625 : 		{	// erase each element satisfying _Pred
; 1626 : 		for (iterator _First = begin(); _First != end(); )
; 1627 : 			if (_Pred(*_First))
; 1628 : 				_First = erase(_First);
; 1629 : 			else
; 1630 : 				++_First;
; 1631 : 		}
; 1632 : 
; 1633 : 	void unique()
; 1634 : 		{	// erase each element matching previous
; 1635 : 		unique(equal_to<>());
; 1636 : 		}
; 1637 : 
; 1638 : 	template<class _Pr2>
; 1639 : 		void unique(_Pr2 _Pred)
; 1640 : 		{	// erase each element satisfying _Pred with previous
; 1641 : 		const _Nodeptr _Phead = this->_Myhead;
; 1642 : 		_Nodeptr _Pprev = this->_Nextnode(_Phead);
; 1643 : 		_Nodeptr _Pnode = this->_Nextnode(_Pprev);
; 1644 : 
; 1645 : 		while (_Pnode != _Phead)
; 1646 : 			if (_Pred(_Pprev->_Myval, _Pnode->_Myval))
; 1647 : 				{	// match, remove it
; 1648 : 				const _Nodeptr _Perase = _Pnode;
; 1649 : 				_Pnode = this->_Nextnode(_Pnode);
; 1650 : 
; 1651 : 				this->_Nextnode(_Pprev) = _Pnode;
; 1652 : 				this->_Prevnode(_Pnode) = _Pprev;
; 1653 : 				this->_Freenode(_Perase);
; 1654 : 
; 1655 : 				--this->_Mysize;
; 1656 : 				}
; 1657 : 			else
; 1658 : 				{	// no match, advance
; 1659 : 				_Pprev = _Pnode;
; 1660 : 				_Pnode = this->_Nextnode(_Pnode);
; 1661 : 				}
; 1662 : 		}
; 1663 : 
; 1664 : 	void merge(_Myt& _Right)
; 1665 : 		{	// merge in elements from _Right, both ordered by operator<
; 1666 : 		merge(_Right, less<>());
; 1667 : 		}
; 1668 : 
; 1669 : 	void merge(_Myt&& _Right)
; 1670 : 		{	// merge in elements from _Right, both ordered by operator<
; 1671 : 		merge((_Myt&)_Right);
; 1672 : 		}
; 1673 : 
; 1674 : 	template<class _Pr2>
; 1675 : 		void merge(_Myt& _Right, _Pr2 _Pred)
; 1676 : 		{	// merge in elements from _Right, both ordered by _Pred
; 1677 : 		if (&_Right != this)
; 1678 : 			{	// safe to merge, do it
; 1679 : 			iterator _First1 = begin(), _Last1 = end();
; 1680 : 			iterator _First2 = _Right.begin(), _Last2 = _Right.end();
; 1681 : 			_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 1682 : 			_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 1683 : 
; 1684 : 			while (_First1 != _Last1 && _First2 != _Last2)
; 1685 : 				if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))
; 1686 : 					{	// splice in an element from _Right
; 1687 : 					iterator _Mid2 = _First2;
; 1688 : 					_Splice(_First1, _Right, _First2, ++_Mid2, 1);
; 1689 : 					_First2 = _Mid2;
; 1690 : 					}
; 1691 : 				else
; 1692 : 					++_First1;
; 1693 : 
; 1694 : 			if (_First2 != _Last2)
; 1695 : 				_Splice(_Last1, _Right, _First2, _Last2,
; 1696 : 					_Right._Mysize);	// splice remainder of _Right
; 1697 : 			}
; 1698 : 		}
; 1699 : 
; 1700 : 	template<class _Pr2>
; 1701 : 		void merge(_Myt&& _Right, _Pr2 _Pred)
; 1702 : 		{	// merge in elements from _Right, both ordered by _Pred
; 1703 : 		merge((_Myt&)_Right, _Pred);
; 1704 : 		}
; 1705 : 
; 1706 : 	void sort()
; 1707 : 		{	// order sequence, using operator<
; 1708 : 		sort(less<>());
; 1709 : 		}
; 1710 : 
; 1711 : 	template<class _Pr2>
; 1712 : 		void sort(_Pr2 _Pred)
; 1713 : 		{	// order sequence, using _Pred
; 1714 : 		if (2 <= this->_Mysize)
; 1715 : 			{	// worth sorting, do it
; 1716 : 			const size_t _MAXBINS = 25;
; 1717 : 			_Myt _Templist(this->_Getal()), _Binlist[_MAXBINS + 1];
; 1718 : 			size_t _Maxbin = 0;
; 1719 : 
; 1720 : 			while (!empty())
; 1721 : 				{	// sort another element, using bins
; 1722 : 				_Templist._Splice_same(_Templist.begin(), *this, begin(),
; 1723 : 					++begin(), 1);
; 1724 : 
; 1725 : 				size_t _Bin;
; 1726 : 				for (_Bin = 0; _Bin < _Maxbin && !_Binlist[_Bin].empty();
; 1727 : 					++_Bin)
; 1728 : 					{	// merge into ever larger bins
; 1729 : 					_Binlist[_Bin].merge(_Templist, _Pred);
; 1730 : 					_Binlist[_Bin].swap(_Templist);
; 1731 : 					}
; 1732 : 
; 1733 : 				if (_Bin == _MAXBINS)
; 1734 : 					_Binlist[_Bin - 1].merge(_Templist, _Pred);
; 1735 : 				else
; 1736 : 					{	// spill to new bin, while they last
; 1737 : 					_Binlist[_Bin].swap(_Templist);
; 1738 : 					if (_Bin == _Maxbin)
; 1739 : 						++_Maxbin;
; 1740 : 					}
; 1741 : 				}
; 1742 : 
; 1743 : 			for (size_t _Bin = 1; _Bin < _Maxbin; ++_Bin)
; 1744 : 				_Binlist[_Bin].merge(_Binlist[_Bin - 1],
; 1745 : 					_Pred);	// merge up
; 1746 : 
; 1747 : 			_Analysis_assume_(0 < _Maxbin);
; 1748 : 
; 1749 : 			splice(begin(), _Binlist[_Maxbin - 1]);	// result in last bin
; 1750 : 			}
; 1751 : 		}
; 1752 : 
; 1753 : 	void reverse() _NOEXCEPT
; 1754 : 		{	// reverse sequence
; 1755 : 		const _Nodeptr _Phead = this->_Myhead;
; 1756 : 		_Nodeptr _Pnode = _Phead;
; 1757 : 
; 1758 : 		for (; ; )
; 1759 : 			{	// flip pointers in a node
; 1760 : 			const _Nodeptr _Pnext = this->_Nextnode(_Pnode);
; 1761 : 			this->_Nextnode(_Pnode) = this->_Prevnode(_Pnode);
; 1762 : 			this->_Prevnode(_Pnode) = _Pnext;
; 1763 : 
; 1764 : 			if (_Pnext == _Phead)
; 1765 : 				break;
; 1766 : 			_Pnode = _Pnext;
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	void _Splice(const_iterator _Where,
; 1771 : 		_Myt& _Right, const_iterator _First, const_iterator _Last,
; 1772 : 		size_type _Count)
; 1773 : 		{	// splice _Right [_First, _Last) before _Where
; 1774 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1775 : 		if (_Where._Getcont() != this)
; 1776 : 			_DEBUG_ERROR("list splice iterator outside range");
; 1777 : 		if (this->_Getal() != _Right._Getal())
; 1778 : 			_DEBUG_ERROR("list containers incompatible for splice");
; 1779 : 
; 1780 : 		if (this != &_Right)
; 1781 : 			{	// transfer ownership
; 1782 : 			_Lockit _Lock(_LOCK_DEBUG);
; 1783 : 
; 1784 : 			const bool _One = _Count == 1;
; 1785 : 			const bool _All = _Count == _Right.size();
; 1786 : 			const bool _Some = !_One && !_All;
; 1787 : 
; 1788 : 			_Nodeptr _Oldprev = _First._Ptr->_Prev;
; 1789 : 
; 1790 : 			if (_Some)
; 1791 : 				for (_Nodeptr _Ptr = _First._Ptr; _Ptr != _Last._Ptr;
; 1792 : 					_Ptr = _Ptr->_Next)
; 1793 : 					{	// mark _Prev pointers
; 1794 : 					_Ptr->_Prev = 0;
; 1795 : 					}
; 1796 : 
; 1797 : 			const_iterator **_Pnext = (const_iterator **)_Right._Getpfirst();
; 1798 : 
; 1799 : 			if (_Pnext == 0)
; 1800 : 				_DEBUG_ERROR("list container corrupted");
; 1801 : 
; 1802 : 			while (*_Pnext != 0)
; 1803 : 				{	// check the iterator
; 1804 : 				const_iterator& _Iter = **_Pnext;
; 1805 : 
; 1806 : 				if ((_One && _Iter._Ptr == _First._Ptr)
; 1807 : 					|| (_All && _Iter._Ptr != _Right._Myhead)
; 1808 : 					|| (_Some && _Iter._Ptr->_Prev == 0))
; 1809 : 					{	// adopt the iterator
; 1810 : 					*_Pnext = (const_iterator *)_Iter._Mynextiter;
; 1811 : 					_Iter._Myproxy = this->_Myproxy;
; 1812 : 					_Iter._Mynextiter = this->_Myproxy->_Myfirstiter;
; 1813 : 					this->_Myproxy->_Myfirstiter = &_Iter;
; 1814 : 					}
; 1815 : 				else
; 1816 : 					{	// skip the iterator
; 1817 : 					_Pnext = (const_iterator **)_Iter._Getpnext();
; 1818 : 					}
; 1819 : 				}
; 1820 : 
; 1821 : 			if (_Some)
; 1822 : 				for (_Nodeptr _Ptr = _First._Ptr; _Ptr != _Last._Ptr;
; 1823 : 					_Ptr = _Ptr->_Next)
; 1824 : 					{	// restore _Prev pointers
; 1825 : 					_Ptr->_Prev = _Oldprev;
; 1826 : 					_Oldprev = _Ptr;
; 1827 : 					}
; 1828 : 			}
; 1829 : 
; 1830 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1831 : 		if (this->_Getal() != _Right._Getal())
; 1832 : 			_XSTD terminate();
; 1833 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1834 : 
; 1835 : 		_Splice_same(_Where, _Right, _First, _Last, _Count);
; 1836 : 		}
; 1837 : 
; 1838 : 	void _Splice_same(const_iterator _Where,
; 1839 : 		_Myt& _Right, const_iterator _First, const_iterator _Last,
; 1840 : 		size_type _Count)
; 1841 : 		{	// splice _Right [_First, _Last) before _Where
; 1842 : 		if (this != &_Right)
; 1843 : 			{	// splicing from another list, adjust counts
; 1844 : 			_Incsize(_Count);
; 1845 : 			_Right._Mysize -= _Count;
; 1846 : 			}
; 1847 : 		this->_Nextnode(this->_Prevnode(_First._Mynode())) =
; 1848 : 			_Last._Mynode();
; 1849 : 		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
; 1850 : 			_Where._Mynode();
; 1851 : 		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
; 1852 : 			_First._Mynode();
; 1853 : 
; 1854 : 		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
; 1855 : 		this->_Prevnode(_Where._Mynode()) =
; 1856 : 			this->_Prevnode(_Last._Mynode());
; 1857 : 		this->_Prevnode(_Last._Mynode()) =
; 1858 : 			this->_Prevnode(_First._Mynode());
; 1859 : 		this->_Prevnode(_First._Mynode()) = _Pnode;
; 1860 : 		}
; 1861 : 
; 1862 : 	void _Unchecked_splice(_Unchecked_const_iterator _Where,
; 1863 : 		_Unchecked_const_iterator _First,
; 1864 : 		_Unchecked_const_iterator _Last)
; 1865 : 		{	// splice [_First, _Last) before _Where
; 1866 : 		this->_Nextnode(this->_Prevnode(_First._Mynode())) =
; 1867 : 			_Last._Mynode();
; 1868 : 		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
; 1869 : 			_Where._Mynode();
; 1870 : 		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
; 1871 : 			_First._Mynode();
; 1872 : 
; 1873 : 		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
; 1874 : 		this->_Prevnode(_Where._Mynode()) =
; 1875 : 			this->_Prevnode(_Last._Mynode());
; 1876 : 		this->_Prevnode(_Last._Mynode()) =
; 1877 : 			this->_Prevnode(_First._Mynode());
; 1878 : 		this->_Prevnode(_First._Mynode()) = _Pnode;
; 1879 : 		}
; 1880 : 
; 1881 : 	void _Tidy()
; 1882 : 		{	// free all storage
; 1883 : 		clear();
; 1884 : 		}
; 1885 : 
; 1886 : 	void _Insert_n(_Unchecked_const_iterator _Where,
; 1887 : 		size_type _Count, const _Ty& _Val)
; 1888 : 		{	// insert _Count * _Val at _Where
; 1889 : 		size_type _Countsave = _Count;
; 1890 : 
; 1891 : 		_TRY_BEGIN
; 1892 : 		for (; 0 < _Count; --_Count)
; 1893 : 			_Insert(_Where, _Val);
; 1894 : 		_CATCH_ALL
; 1895 : 		for (; _Count < _Countsave; ++_Count)
; 1896 : 			{	// undo inserts
; 1897 : 			_Unchecked_const_iterator _Before = _Where;
; 1898 : 			_Unchecked_erase(--_Before);
; 1899 : 			}
; 1900 : 		_RERAISE;
; 1901 : 		_CATCH_END
; 1902 : 		}
; 1903 : 
; 1904 : 	void _Incsize(size_type _Count)
; 1905 : 		{	// alter element count, with checking
; 1906 : 		if (max_size() - this->_Mysize - 1 < _Count)

  00022	b9 fe ff ff 07	 mov	 ecx, 134217726		; 07fffffeH
  00027	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002a	2b c8		 sub	 ecx, eax
  0002c	83 f9 01	 cmp	 ecx, 1
  0002f	72 12		 jb	 SHORT $LN47@AppendInsu

; 1908 : 		this->_Mysize += _Count;

  00031	40		 inc	 eax
  00032	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1063 : 		_Incsize(1);
; 1064 : 		this->_Prevnode(_Pnode) = _Newnode;

  00035	89 57 04	 mov	 DWORD PTR [edi+4], edx

; 97   : 		}
; 98   : 
; 99   : 	_Nodeptr _Ptr;	// pointer to node
; 100  : 	};
; 101  : 
; 102  : 	// TEMPLATE CLASS _List_unchecked_iterator
; 103  : template<class _Mylist>
; 104  : 	class _List_unchecked_iterator
; 105  : 		: public _List_unchecked_const_iterator<_Mylist>
; 106  : 	{	// unchecked iterator for mutable list
; 107  : public:
; 108  : 	typedef _List_unchecked_iterator<_Mylist> _Myiter;
; 109  : 	typedef _List_unchecked_const_iterator<_Mylist> _Mybase;
; 110  : 	typedef bidirectional_iterator_tag iterator_category;
; 111  : 
; 112  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 113  : 	typedef typename _Mylist::value_type value_type;
; 114  : 	typedef typename _Mylist::difference_type difference_type;
; 115  : 	typedef typename _Mylist::pointer pointer;
; 116  : 	typedef typename _Mylist::reference reference;
; 117  : 
; 118  : 	_List_unchecked_iterator()
; 119  : 		{	// construct with null node
; 120  : 		}
; 121  : 
; 122  : 	_List_unchecked_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 123  : 		: _Mybase(_Pnode, _Plist)
; 124  : 		{	// construct with node pointer _Pnode
; 125  : 		}
; 126  : 
; 127  : 	reference operator*() const
; 128  : 		{	// return designated value
; 129  : 		return ((reference)**(_Mybase *)this);
; 130  : 		}
; 131  : 
; 132  : 	pointer operator->() const
; 133  : 		{	// return pointer to class object
; 134  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 135  : 		}
; 136  : 
; 137  : 	_Myiter& operator++()
; 138  : 		{	// preincrement
; 139  : 		++(*(_Mybase *)this);
; 140  : 		return (*this);
; 141  : 		}
; 142  : 
; 143  : 	_Myiter operator++(int)
; 144  : 		{	// postincrement
; 145  : 		_Myiter _Tmp = *this;
; 146  : 		++*this;
; 147  : 		return (_Tmp);
; 148  : 		}
; 149  : 
; 150  : 	_Myiter& operator--()
; 151  : 		{	// predecrement
; 152  : 		--(*(_Mybase *)this);
; 153  : 		return (*this);
; 154  : 		}
; 155  : 
; 156  : 	_Myiter operator--(int)
; 157  : 		{	// postdecrement
; 158  : 		_Myiter _Tmp = *this;
; 159  : 		--*this;
; 160  : 		return (_Tmp);
; 161  : 		}
; 162  : 	};
; 163  : 
; 164  : 	// TEMPLATE CLASS _List_const_iterator
; 165  : template<class _Mylist>
; 166  : 	class _List_const_iterator
; 167  : 		: public _List_unchecked_const_iterator<_Mylist, _Iterator_base>
; 168  : 	{	// iterator for nonmutable list
; 169  : public:
; 170  : 	typedef _List_const_iterator<_Mylist> _Myiter;
; 171  : 	typedef _List_unchecked_const_iterator<_Mylist, _Iterator_base> _Mybase;
; 172  : 	typedef bidirectional_iterator_tag iterator_category;
; 173  : 
; 174  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 175  : 	typedef typename _Mylist::value_type value_type;
; 176  : 	typedef typename _Mylist::difference_type difference_type;
; 177  : 	typedef typename _Mylist::const_pointer pointer;
; 178  : 	typedef typename _Mylist::const_reference reference;
; 179  : 
; 180  : 	_List_const_iterator()
; 181  : 		: _Mybase()
; 182  : 		{	// construct with null node pointer
; 183  : 		}
; 184  : 
; 185  : 	_List_const_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 186  : 		: _Mybase(_Pnode, _Plist)
; 187  : 		{	// construct with node pointer _Pnode
; 188  : 		}
; 189  : 
; 190  : 	typedef _List_unchecked_const_iterator<_Mylist> _Unchecked_type;
; 191  : 
; 192  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 193  : 		{	// reset from unchecked iterator
; 194  : 		this->_Ptr = _Right._Ptr;
; 195  : 		return (*this);
; 196  : 		}
; 197  : 
; 198  : 	_Unchecked_type _Unchecked() const
; 199  : 		{	// make an unchecked iterator
; 200  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 201  : 		}
; 202  : 
; 203  : 	reference operator*() const
; 204  : 		{	// return designated value
; 205  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 206  : 		if (this->_Getcont() == 0
; 207  : 			|| this->_Ptr == 0
; 208  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 209  : 			{	// report error
; 210  : 			_DEBUG_ERROR("list iterator not dereferencable");
; 211  : 			_SCL_SECURE_OUT_OF_RANGE;
; 212  : 			}
; 213  : 
; 214  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 215  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 216  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 217  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 218  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 219  : 
; 220  : 		return (_Mylist::_Myval(this->_Ptr));
; 221  : 		}
; 222  : 
; 223  : 	_Myiter& operator++()
; 224  : 		{	// preincrement
; 225  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 226  : 		if (this->_Getcont() == 0
; 227  : 			|| this->_Ptr == 0
; 228  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 229  : 			{	// report error
; 230  : 			_DEBUG_ERROR("list iterator not incrementable");
; 231  : 			_SCL_SECURE_OUT_OF_RANGE;
; 232  : 			}
; 233  : 
; 234  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 235  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 236  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 237  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 238  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 239  : 
; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);
; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);
; 299  : 		}
; 300  : 
; 301  : 	bool operator!=(const _Myiter& _Right) const
; 302  : 		{	// test for iterator inequality
; 303  : 		return (!(*this == _Right));
; 304  : 		}
; 305  : 	};
; 306  : 
; 307  : template<class _Mylist> inline
; 308  : 	typename _List_const_iterator<_Mylist>::_Unchecked_type
; 309  : 		_Unchecked(_List_const_iterator<_Mylist> _Iter)
; 310  : 	{	// convert to unchecked
; 311  : 	return (_Iter._Unchecked());
; 312  : 	}
; 313  : 
; 314  : template<class _Mylist> inline
; 315  : 	_List_const_iterator<_Mylist>&
; 316  : 		_Rechecked(_List_const_iterator<_Mylist>& _Iter,
; 317  : 			typename _List_const_iterator<_Mylist>
; 318  : 				::_Unchecked_type _Right)
; 319  : 	{	// convert to checked
; 320  : 	return (_Iter._Rechecked(_Right));
; 321  : 	}
; 322  : 
; 323  : 	// TEMPLATE CLASS _List_iterator
; 324  : template<class _Mylist>
; 325  : 	class _List_iterator
; 326  : 		: public _List_const_iterator<_Mylist>
; 327  : 	{	// iterator for mutable list
; 328  : public:
; 329  : 	typedef _List_iterator<_Mylist> _Myiter;
; 330  : 	typedef _List_const_iterator<_Mylist> _Mybase;
; 331  : 	typedef bidirectional_iterator_tag iterator_category;
; 332  : 
; 333  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 334  : 	typedef typename _Mylist::value_type value_type;
; 335  : 	typedef typename _Mylist::difference_type difference_type;
; 336  : 	typedef typename _Mylist::pointer pointer;
; 337  : 	typedef typename _Mylist::reference reference;
; 338  : 
; 339  : 	_List_iterator()
; 340  : 		{	// construct with null node
; 341  : 		}
; 342  : 
; 343  : 	_List_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 344  : 		: _Mybase(_Pnode, _Plist)
; 345  : 		{	// construct with node pointer _Pnode
; 346  : 		}
; 347  : 
; 348  : 	typedef _List_unchecked_iterator<_Mylist> _Unchecked_type;
; 349  : 
; 350  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 351  : 		{	// reset from unchecked iterator
; 352  : 		this->_Ptr = _Right._Ptr;
; 353  : 		return (*this);
; 354  : 		}
; 355  : 
; 356  : 	_Unchecked_type _Unchecked() const
; 357  : 		{	// make an unchecked iterator
; 358  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 359  : 		}
; 360  : 
; 361  : 	reference operator*() const
; 362  : 		{	// return designated value
; 363  : 		return ((reference)**(_Mybase *)this);
; 364  : 		}
; 365  : 
; 366  : 	pointer operator->() const
; 367  : 		{	// return pointer to class object
; 368  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 369  : 		}
; 370  : 
; 371  : 	_Myiter& operator++()
; 372  : 		{	// preincrement
; 373  : 		++(*(_Mybase *)this);
; 374  : 		return (*this);
; 375  : 		}
; 376  : 
; 377  : 	_Myiter operator++(int)
; 378  : 		{	// postincrement
; 379  : 		_Myiter _Tmp = *this;
; 380  : 		++*this;
; 381  : 		return (_Tmp);
; 382  : 		}
; 383  : 
; 384  : 	_Myiter& operator--()
; 385  : 		{	// predecrement
; 386  : 		--(*(_Mybase *)this);
; 387  : 		return (*this);
; 388  : 		}
; 389  : 
; 390  : 	_Myiter operator--(int)
; 391  : 		{	// postdecrement
; 392  : 		_Myiter _Tmp = *this;
; 393  : 		--*this;
; 394  : 		return (_Tmp);
; 395  : 		}
; 396  : 	};
; 397  : 
; 398  : template<class _Mylist> inline
; 399  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 400  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 401  : 	{	// convert to unchecked
; 402  : 	return (_Iter._Unchecked());
; 403  : 	}
; 404  : 
; 405  : template<class _Mylist> inline
; 406  : 	_List_iterator<_Mylist>&
; 407  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 408  : 			typename _List_iterator<_Mylist>
; 409  : 				::_Unchecked_type _Right)
; 410  : 	{	// convert to checked
; 411  : 	return (_Iter._Rechecked(_Right));
; 412  : 	}
; 413  : 
; 414  : 		// list TYPE WRAPPERS
; 415  : template<class _Value_type,
; 416  : 	class _Size_type,
; 417  : 	class _Difference_type,
; 418  : 	class _Pointer,
; 419  : 	class _Const_pointer,
; 420  : 	class _Reference,
; 421  : 	class _Const_reference,
; 422  : 	class _Nodeptr_type>
; 423  : 	struct _List_iter_types
; 424  : 	{	// wraps types needed by iterators
; 425  : 	typedef _Value_type value_type;
; 426  : 	typedef _Size_type size_type;
; 427  : 	typedef _Difference_type difference_type;
; 428  : 	typedef _Pointer pointer;
; 429  : 	typedef _Const_pointer const_pointer;
; 430  : 	typedef _Reference reference;
; 431  : 	typedef _Const_reference const_reference;
; 432  : 	typedef _Nodeptr_type _Nodeptr;
; 433  : 	};
; 434  : 
; 435  : template<class _Value_type,
; 436  : 	class _Voidptr>
; 437  : 	struct _List_node
; 438  : 		{	// list node
; 439  : 		_Voidptr _Next;	// successor node, or first element if head
; 440  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 441  : 		_Value_type _Myval;	// the stored value, unused if head
; 442  : 
; 443  : 	private:
; 444  : 		_List_node& operator=(const _List_node&);
; 445  : 		};
; 446  : 
; 447  : template<class _Value_type>
; 448  : 	struct _List_node<_Value_type, void *>
; 449  : 		{	// list node
; 450  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 451  : 		_Nodeptr _Next;	// successor node, or first element if head
; 452  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 453  : 		_Value_type _Myval;	// the stored value, unused if head
; 454  : 
; 455  : 	private:
; 456  : 		_List_node& operator=(const _List_node&);
; 457  : 		};
; 458  : 
; 459  : template<class _Ty>
; 460  : 	struct _List_simple_types
; 461  : 		: public _Simple_types<_Ty>
; 462  : 	{	// wraps types needed by iterators
; 463  : 	typedef _List_node<_Ty, void *> _Node;
; 464  : 	typedef _Node *_Nodeptr;
; 465  : 	};
; 466  : 
; 467  : template<class _Ty,
; 468  : 	class _Alloc0>
; 469  : 	struct _List_base_types
; 470  : 	{	// types needed for a container base
; 471  : 	typedef _Alloc0 _Alloc;
; 472  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 473  : 
; 474  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 475  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 476  : 
; 477  : 
; 478  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 479  : 		_Voidptr;
; 480  : 	typedef _List_node<typename _Alty::value_type,
; 481  : 		_Voidptr> _Node;
; 482  : 
; 483  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 484  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 485  : 	typedef _Nodeptr& _Nodepref;
; 486  : 
; 487  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 488  : 		_List_simple_types<typename _Alty::value_type>,
; 489  : 		_List_iter_types<typename _Alty::value_type,
; 490  : 			typename _Alty::size_type,
; 491  : 			typename _Alty::difference_type,
; 492  : 			typename _Alty::pointer,
; 493  : 			typename _Alty::const_pointer,
; 494  : 			typename _Alty::reference,
; 495  : 			typename _Alty::const_reference,
; 496  : 			_Nodeptr> >::type
; 497  : 		_Val_types;
; 498  : 	};
; 499  : 
; 500  : 		// TEMPLATE CLASS _List_val
; 501  : template<class _Val_types>
; 502  : 	class _List_val
; 503  : 		: public _Container_base
; 504  : 	{	// base class for list to hold data
; 505  : public:
; 506  : 	typedef _List_val<_Val_types> _Myt;
; 507  : 
; 508  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 509  : 	typedef _Nodeptr& _Nodepref;
; 510  : 
; 511  : 	typedef typename _Val_types::value_type value_type;
; 512  : 	typedef typename _Val_types::size_type size_type;
; 513  : 	typedef typename _Val_types::difference_type difference_type;
; 514  : 	typedef typename _Val_types::pointer pointer;
; 515  : 	typedef typename _Val_types::const_pointer const_pointer;
; 516  : 	typedef typename _Val_types::reference reference;
; 517  : 	typedef typename _Val_types::const_reference const_reference;
; 518  : 
; 519  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 520  : 	typedef _List_iterator<_Myt> iterator;
; 521  : 
; 522  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 523  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 524  : 
; 525  : 	_List_val()
; 526  : 		{	// initialize data
; 527  : 		this->_Myhead = 0;
; 528  : 		this->_Mysize = 0;
; 529  : 		}
; 530  : 
; 531  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 532  : 		{	// return reference to successor pointer in node
; 533  : 		return ((_Nodepref)_Pnode->_Next);

  00038	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi

; 1065 : 		this->_Nextnode(this->_Prevnode(_Newnode)) = _Newnode;

  0003d	89 10		 mov	 DWORD PTR [eax], edx
$LN16@AppendInsu:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\insultchecker.cpp

; 27   : }

  0003f	5d		 pop	 ebp
  00040	c2 04 00	 ret	 4
$LN47@AppendInsu:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 1907 : 			_Xlength_error("list<T> too long");

  00043	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  00048	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN49@AppendInsu:
$LN46@AppendInsu:
  0004d	cc		 int	 3
?AppendInsult@CInsultChecker@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CInsultChecker::AppendInsult
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\insultchecker.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\insultchecker.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\insultchecker.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\insultchecker.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\insultchecker.cpp
;	COMDAT ?__GetInsultLength@CInsultChecker@@AAE_NPBDPAI@Z
_TEXT	SEGMENT
_c_szWord$ = 8						; size = 4
_puInsultLen$ = 12					; size = 4
?__GetInsultLength@CInsultChecker@@AAE_NPBDPAI@Z PROC	; CInsultChecker::__GetInsultLength, COMDAT
; _this$ = ecx

; 30   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b d9		 mov	 ebx, ecx
  00006	56		 push	 esi
  00007	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 533  : 		return ((_Nodepref)_Pnode->_Next);

  00008	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\insultchecker.cpp

; 32   : 	for (i=m_kList_stInsult.begin(); i!=m_kList_stInsult.end(); ++i)

  0000b	8b 30		 mov	 esi, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 298  : 		return (this->_Ptr == _Right._Ptr);

  0000d	3b f0		 cmp	 esi, eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\insultchecker.cpp

; 32   : 	for (i=m_kList_stInsult.begin(); i!=m_kList_stInsult.end(); ++i)

  0000f	74 27		 je	 SHORT $LN2@GetInsultL
$LL27@GetInsultL:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00011	83 7e 1c 10	 cmp	 DWORD PTR [esi+28], 16	; 00000010H
  00015	72 05		 jb	 SHORT $LN57@GetInsultL
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00017	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  0001a	eb 03		 jmp	 SHORT $LN58@GetInsultL
$LN57@GetInsultL:
  0001c	8d 56 08	 lea	 edx, DWORD PTR [esi+8]
$LN58@GetInsultL:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\insultchecker.cpp

; 36   : 		int ret=LocaleService_StringCompareCI(c_szWord, rstInsult.c_str(), rstInsult.length());		

  0001f	ff 76 18	 push	 DWORD PTR [esi+24]
  00022	8b 4d 08	 mov	 ecx, DWORD PTR _c_szWord$[ebp]
  00025	e8 00 00 00 00	 call	 ?LocaleService_StringCompareCI@@YAHPBD0I@Z ; LocaleService_StringCompareCI
  0002a	83 c4 04	 add	 esp, 4

; 37   : 		if (0==ret)

  0002d	85 c0		 test	 eax, eax
  0002f	74 10		 je	 SHORT $LN64@GetInsultL
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  00031	8b 36		 mov	 esi, DWORD PTR [esi]

; 298  : 		return (this->_Ptr == _Right._Ptr);

  00033	3b 73 04	 cmp	 esi, DWORD PTR [ebx+4]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\insultchecker.cpp

; 32   : 	for (i=m_kList_stInsult.begin(); i!=m_kList_stInsult.end(); ++i)

  00036	75 d9		 jne	 SHORT $LL27@GetInsultL
$LN2@GetInsultL:
  00038	5f		 pop	 edi
  00039	5e		 pop	 esi

; 41   : 		}
; 42   : 	}
; 43   : 
; 44   : 	return false;

  0003a	32 c0		 xor	 al, al
  0003c	5b		 pop	 ebx

; 45   : }

  0003d	5d		 pop	 ebp
  0003e	c2 08 00	 ret	 8
$LN64@GetInsultL:

; 38   : 		{
; 39   : 			*puInsultLen=rstInsult.length();

  00041	8b 45 0c	 mov	 eax, DWORD PTR _puInsultLen$[ebp]
  00044	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
  00049	89 08		 mov	 DWORD PTR [eax], ecx

; 40   : 			return true;

  0004b	b0 01		 mov	 al, 1
  0004d	5b		 pop	 ebx

; 45   : }

  0004e	5d		 pop	 ebp
  0004f	c2 08 00	 ret	 8
?__GetInsultLength@CInsultChecker@@AAE_NPBDPAI@Z ENDP	; CInsultChecker::__GetInsultLength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\insultchecker.cpp
;	COMDAT ?__IsInsult@CInsultChecker@@AAE_NPBD@Z
_TEXT	SEGMENT
_uInsultLen$ = -4					; size = 4
_c_szWord$ = 8						; size = 4
?__IsInsult@CInsultChecker@@AAE_NPBD@Z PROC		; CInsultChecker::__IsInsult, COMDAT
; _this$ = ecx

; 48   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 49   : 	UINT uInsultLen;
; 50   : 	return __GetInsultLength(c_szWord, &uInsultLen);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _uInsultLen$[ebp]
  00007	50		 push	 eax
  00008	ff 75 08	 push	 DWORD PTR _c_szWord$[ebp]
  0000b	e8 00 00 00 00	 call	 ?__GetInsultLength@CInsultChecker@@AAE_NPBDPAI@Z ; CInsultChecker::__GetInsultLength

; 51   : }

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?__IsInsult@CInsultChecker@@AAE_NPBD@Z ENDP		; CInsultChecker::__IsInsult
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\insultchecker.cpp
;	COMDAT ?FilterInsult@CInsultChecker@@QAEXPADI@Z
_TEXT	SEGMENT
_this$1$ = -12						; size = 4
_uInsultLen$1 = -8					; size = 4
_bChr$1$ = -1						; size = 1
_szLine$ = 8						; size = 4
_uLineLen$ = 12						; size = 4
?FilterInsult@CInsultChecker@@QAEXPADI@Z PROC		; CInsultChecker::FilterInsult, COMDAT
; _this$ = ecx

; 54   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi

; 55   : 	const char INSULT_FILTER_CHAR = '*'; 
; 56   : 	for (UINT uPos=0; uPos<uLineLen;)

  00007	33 f6		 xor	 esi, esi
  00009	89 4d f4	 mov	 DWORD PTR _this$1$[ebp], ecx
  0000c	39 75 0c	 cmp	 DWORD PTR _uLineLen$[ebp], esi
  0000f	76 49		 jbe	 SHORT $LN5@FilterInsu
  00011	53		 push	 ebx
  00012	57		 push	 edi
$LL6@FilterInsu:

; 57   : 	{
; 58   : 		BYTE bChr=szLine[uPos];

  00013	8b 5d 08	 mov	 ebx, DWORD PTR _szLine$[ebp]
  00016	03 de		 add	 ebx, esi
  00018	8a 03		 mov	 al, BYTE PTR [ebx]
  0001a	88 45 ff	 mov	 BYTE PTR _bChr$1$[ebp], al

; 59   : 		UINT uInsultLen;
; 60   : 		if (__GetInsultLength(szLine+uPos, &uInsultLen))

  0001d	8d 45 f8	 lea	 eax, DWORD PTR _uInsultLen$1[ebp]
  00020	50		 push	 eax
  00021	53		 push	 ebx
  00022	e8 00 00 00 00	 call	 ?__GetInsultLength@CInsultChecker@@AAE_NPBDPAI@Z ; CInsultChecker::__GetInsultLength
  00027	84 c0		 test	 al, al
  00029	74 13		 je	 SHORT $LN4@FilterInsu

; 61   : 		{
; 62   : 			memset(szLine+uPos, INSULT_FILTER_CHAR, uInsultLen);

  0002b	8b 7d f8	 mov	 edi, DWORD PTR _uInsultLen$1[ebp]
  0002e	57		 push	 edi
  0002f	6a 2a		 push	 42			; 0000002aH
  00031	53		 push	 ebx
  00032	e8 00 00 00 00	 call	 _memset
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH

; 63   : 			uPos += uInsultLen;

  0003a	03 f7		 add	 esi, edi

; 64   : 		}
; 65   : 		else

  0003c	eb 12		 jmp	 SHORT $LN1@FilterInsu
$LN4@FilterInsu:

; 66   : 		{
; 67   : 			if ( LocaleService_IsLeadByte( bChr ) )

  0003e	8a 4d ff	 mov	 cl, BYTE PTR _bChr$1$[ebp]
  00041	e8 00 00 00 00	 call	 ?LocaleService_IsLeadByte@@YAHD@Z ; LocaleService_IsLeadByte
  00046	85 c0		 test	 eax, eax
  00048	74 05		 je	 SHORT $LN2@FilterInsu

; 68   : 				uPos += 2;

  0004a	83 c6 02	 add	 esi, 2

; 69   : 			else

  0004d	eb 01		 jmp	 SHORT $LN1@FilterInsu
$LN2@FilterInsu:

; 70   : 				uPos++;

  0004f	46		 inc	 esi
$LN1@FilterInsu:

; 55   : 	const char INSULT_FILTER_CHAR = '*'; 
; 56   : 	for (UINT uPos=0; uPos<uLineLen;)

  00050	8b 4d f4	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00053	3b 75 0c	 cmp	 esi, DWORD PTR _uLineLen$[ebp]
  00056	72 bb		 jb	 SHORT $LL6@FilterInsu
  00058	5f		 pop	 edi
  00059	5b		 pop	 ebx
$LN5@FilterInsu:
  0005a	5e		 pop	 esi

; 71   : 		}
; 72   : 	}
; 73   : }

  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c2 08 00	 ret	 8
?FilterInsult@CInsultChecker@@QAEXPADI@Z ENDP		; CInsultChecker::FilterInsult
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\insultchecker.cpp
;	COMDAT ?IsInsultIn@CInsultChecker@@QAE_NPBDI@Z
_TEXT	SEGMENT
_c_szLine$ = 8						; size = 4
_uLineLen$ = 12						; size = 4
?IsInsultIn@CInsultChecker@@QAE_NPBDI@Z PROC		; CInsultChecker::IsInsultIn, COMDAT
; _this$ = ecx

; 76   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 77   : 	for (UINT uPos=0; uPos<uLineLen;)

  00006	33 ff		 xor	 edi, edi
  00008	8b d9		 mov	 ebx, ecx
  0000a	39 7d 0c	 cmp	 DWORD PTR _uLineLen$[ebp], edi
  0000d	76 2c		 jbe	 SHORT $LN5@IsInsultIn
  0000f	8b 75 08	 mov	 esi, DWORD PTR _c_szLine$[ebp]
$LL6@IsInsultIn:

; 78   : 	{
; 79   : 		BYTE bChr=c_szLine[uPos];
; 80   : 		if (bChr & 0x80)

  00012	f6 06 80	 test	 BYTE PTR [esi], 128	; 00000080H

; 81   : 		{
; 82   : 			if (__IsInsult(c_szLine+uPos))

  00015	8b cb		 mov	 ecx, ebx
  00017	56		 push	 esi
  00018	74 11		 je	 SHORT $LN4@IsInsultIn
  0001a	e8 00 00 00 00	 call	 ?__IsInsult@CInsultChecker@@AAE_NPBD@Z ; CInsultChecker::__IsInsult
  0001f	84 c0		 test	 al, al
  00021	75 21		 jne	 SHORT $LN10@IsInsultIn

; 84   : 
; 85   : 			uPos+=2;

  00023	83 c7 02	 add	 edi, 2
  00026	83 c6 02	 add	 esi, 2

; 86   : 		}
; 87   : 		else

  00029	eb 0b		 jmp	 SHORT $LN2@IsInsultIn
$LN4@IsInsultIn:

; 88   : 		{
; 89   : 			if (__IsInsult(c_szLine+uPos))

  0002b	e8 00 00 00 00	 call	 ?__IsInsult@CInsultChecker@@AAE_NPBD@Z ; CInsultChecker::__IsInsult
  00030	84 c0		 test	 al, al
  00032	75 10		 jne	 SHORT $LN10@IsInsultIn

; 90   : 				return true;
; 91   : 
; 92   : 			uPos++;

  00034	47		 inc	 edi
  00035	46		 inc	 esi
$LN2@IsInsultIn:

; 77   : 	for (UINT uPos=0; uPos<uLineLen;)

  00036	3b 7d 0c	 cmp	 edi, DWORD PTR _uLineLen$[ebp]
  00039	72 d7		 jb	 SHORT $LL6@IsInsultIn
$LN5@IsInsultIn:
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi

; 93   : 		}
; 94   : 	}
; 95   : 
; 96   : 	return false;

  0003d	32 c0		 xor	 al, al
  0003f	5b		 pop	 ebx

; 97   : }

  00040	5d		 pop	 ebp
  00041	c2 08 00	 ret	 8
$LN10@IsInsultIn:
  00044	5f		 pop	 edi
  00045	5e		 pop	 esi

; 83   : 				return true;

  00046	b0 01		 mov	 al, 1
  00048	5b		 pop	 ebx

; 97   : }

  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
?IsInsultIn@CInsultChecker@@QAE_NPBDI@Z ENDP		; CInsultChecker::IsInsultIn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??0?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ PROC ; std::list<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::list<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 891  : 		{	// construct empty list

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 703  : 		}
; 704  : 
; 705  : 	~_List_alloc() _NOEXCEPT
; 706  : 		{	// destroy head node
; 707  : 		_Freeheadnode(this->_Myhead);
; 708  : 		}
; 709  : 
; 710  : 	void _Change_alloc(const _Alty&)
; 711  : 		{	// replace old allocator
; 712  : 		}
; 713  : 
; 714  : 	void _Swap_alloc(_Myt&)
; 715  : 		{	// swap allocators
; 716  : 		}
; 717  : 
; 718  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 719  : 	_List_alloc(const _Alloc& = _Alloc())
; 720  : 		{	// construct allocators from _Al
; 721  : 		this->_Myhead = _Buyheadnode();
; 722  : 		_TRY_BEGIN
; 723  : 		_Alloc_proxy();
; 724  : 		_CATCH_ALL
; 725  : 		_Freeheadnode(this->_Myhead);
; 726  : 		_RERAISE;
; 727  : 		_CATCH_END
; 728  : 		}
; 729  : 
; 730  : 	~_List_alloc() _NOEXCEPT
; 731  : 		{	// destroy proxy
; 732  : 		_Freeheadnode(this->_Myhead);
; 733  : 		_Free_proxy();
; 734  : 		}
; 735  : 
; 736  : 	void _Change_alloc(const _Alty&)
; 737  : 		{	// replace old allocator
; 738  : 		}
; 739  : 
; 740  : 	void _Swap_alloc(_Myt& _Right)
; 741  : 		{	// swap allocators
; 742  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 743  : 		}
; 744  : 
; 745  : 	void _Alloc_proxy()
; 746  : 		{	// construct proxy from _Alnod
; 747  : 		typename _Alty::template rebind<_Container_proxy>::other
; 748  : 			_Alproxy;
; 749  : 		this->_Myproxy = _Alproxy.allocate(1);
; 750  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 751  : 		this->_Myproxy->_Mycont = this;
; 752  : 		}
; 753  : 
; 754  : 	void _Free_proxy()
; 755  : 		{	// destroy proxy
; 756  : 		typename _Alty::template rebind<_Container_proxy>::other
; 757  : 			_Alproxy;
; 758  : 		this->_Orphan_all();
; 759  : 		_Alproxy.destroy(this->_Myproxy);
; 760  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 761  : 		this->_Myproxy = 0;
; 762  : 		}
; 763  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 764  : 
; 765  : 	_Nodeptr _Buyheadnode()
; 766  : 		{	// get head node using current allocator
; 767  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  00003	6a 00		 push	 0
  00005	6a 00		 push	 0

; 527  : 		this->_Myhead = 0;

  00007	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 528  : 		this->_Mysize = 0;

  0000d	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 703  : 		}
; 704  : 
; 705  : 	~_List_alloc() _NOEXCEPT
; 706  : 		{	// destroy head node
; 707  : 		_Freeheadnode(this->_Myhead);
; 708  : 		}
; 709  : 
; 710  : 	void _Change_alloc(const _Alty&)
; 711  : 		{	// replace old allocator
; 712  : 		}
; 713  : 
; 714  : 	void _Swap_alloc(_Myt&)
; 715  : 		{	// swap allocators
; 716  : 		}
; 717  : 
; 718  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 719  : 	_List_alloc(const _Alloc& = _Alloc())
; 720  : 		{	// construct allocators from _Al
; 721  : 		this->_Myhead = _Buyheadnode();
; 722  : 		_TRY_BEGIN
; 723  : 		_Alloc_proxy();
; 724  : 		_CATCH_ALL
; 725  : 		_Freeheadnode(this->_Myhead);
; 726  : 		_RERAISE;
; 727  : 		_CATCH_END
; 728  : 		}
; 729  : 
; 730  : 	~_List_alloc() _NOEXCEPT
; 731  : 		{	// destroy proxy
; 732  : 		_Freeheadnode(this->_Myhead);
; 733  : 		_Free_proxy();
; 734  : 		}
; 735  : 
; 736  : 	void _Change_alloc(const _Alty&)
; 737  : 		{	// replace old allocator
; 738  : 		}
; 739  : 
; 740  : 	void _Swap_alloc(_Myt& _Right)
; 741  : 		{	// swap allocators
; 742  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 743  : 		}
; 744  : 
; 745  : 	void _Alloc_proxy()
; 746  : 		{	// construct proxy from _Alnod
; 747  : 		typename _Alty::template rebind<_Container_proxy>::other
; 748  : 			_Alproxy;
; 749  : 		this->_Myproxy = _Alproxy.allocate(1);
; 750  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 751  : 		this->_Myproxy->_Mycont = this;
; 752  : 		}
; 753  : 
; 754  : 	void _Free_proxy()
; 755  : 		{	// destroy proxy
; 756  : 		typename _Alty::template rebind<_Container_proxy>::other
; 757  : 			_Alproxy;
; 758  : 		this->_Orphan_all();
; 759  : 		_Alproxy.destroy(this->_Myproxy);
; 760  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 761  : 		this->_Myproxy = 0;
; 762  : 		}
; 763  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 764  : 
; 765  : 	_Nodeptr _Buyheadnode()
; 766  : 		{	// get head node using current allocator
; 767  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  00014	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@PAU32@0@Z ; std::_List_alloc<0,std::_List_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Buynode0

; 529  : 		}
; 530  : 
; 531  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 532  : 		{	// return reference to successor pointer in node
; 533  : 		return ((_Nodepref)_Pnode->_Next);
; 534  : 		}
; 535  : 
; 536  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 537  : 		{	// return reference to predecessor pointer in node
; 538  : 		return ((_Nodepref)_Pnode->_Prev);
; 539  : 		}
; 540  : 
; 541  : 	static reference _Myval(_Nodeptr _Pnode)
; 542  : 		{	// return reference to value in node
; 543  : 		return ((reference)_Pnode->_Myval);
; 544  : 		}
; 545  : 
; 546  : 	_Nodeptr _Myhead;	// pointer to head node
; 547  : 	size_type _Mysize;	// number of elements
; 548  : 	};
; 549  : 
; 550  : 		// TEMPLATE CLASS _List_alloc
; 551  : template<bool _Al_has_storage,
; 552  : 	class _Alloc_types>
; 553  : 	class _List_alloc
; 554  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 555  : 	{	// base class for list to hold allocator with storage
; 556  : public:
; 557  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 558  : 
; 559  : 	typedef _List_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 560  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 561  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 562  : 	typedef typename _Alloc_types::_Node _Node;
; 563  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 564  : 
; 565  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 566  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 567  : 		: _Alnod(_Al)
; 568  : 		{	// construct head node, allocator from _Al
; 569  : 		this->_Myhead = _Buyheadnode();
; 570  : 		}
; 571  : 
; 572  : 	~_List_alloc() _NOEXCEPT
; 573  : 		{	// destroy head node
; 574  : 		_Freeheadnode(this->_Myhead);
; 575  : 		}
; 576  : 
; 577  : 	void _Change_alloc(const _Alty& _Al)
; 578  : 		{	// replace old allocator
; 579  : 		this->_Alnod = _Al;
; 580  : 		}
; 581  : 
; 582  : 	void _Swap_alloc(_Myt& _Right)
; 583  : 		{	// swap allocators
; 584  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 585  : 		}
; 586  : 
; 587  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 588  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 589  : 		: _Alnod(_Al)
; 590  : 		{	// construct head node, allocator from _Al
; 591  : 		this->_Myhead = _Buyheadnode();
; 592  : 		_TRY_BEGIN
; 593  : 		_Alloc_proxy();
; 594  : 		_CATCH_ALL
; 595  : 		_Freeheadnode(this->_Myhead);
; 596  : 		_RERAISE;
; 597  : 		_CATCH_END
; 598  : 		}
; 599  : 
; 600  : 	~_List_alloc() _NOEXCEPT
; 601  : 		{	// destroy proxy
; 602  : 		_Freeheadnode(this->_Myhead);
; 603  : 		_Free_proxy();
; 604  : 		}
; 605  : 
; 606  : 	void _Change_alloc(const _Alty& _Al)
; 607  : 		{	// replace old allocator
; 608  : 		_Free_proxy();
; 609  : 		this->_Alnod = _Al;
; 610  : 		_Alloc_proxy();
; 611  : 		}
; 612  : 
; 613  : 	void _Swap_alloc(_Myt& _Right)
; 614  : 		{	// swap allocators
; 615  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 616  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 617  : 		}
; 618  : 
; 619  : 	void _Alloc_proxy()
; 620  : 		{	// construct proxy from _Alnod
; 621  : 		typename _Alty::template rebind<_Container_proxy>::other
; 622  : 			_Alproxy(this->_Alnod);
; 623  : 		this->_Myproxy = _Alproxy.allocate(1);
; 624  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 625  : 		this->_Myproxy->_Mycont = this;
; 626  : 		}
; 627  : 
; 628  : 	void _Free_proxy()
; 629  : 		{	// destroy proxy
; 630  : 		typename _Alty::template rebind<_Container_proxy>::other
; 631  : 			_Alproxy(this->_Alnod);
; 632  : 		this->_Orphan_all();
; 633  : 		_Alproxy.destroy(this->_Myproxy);
; 634  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 635  : 		this->_Myproxy = 0;
; 636  : 		}
; 637  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 638  : 
; 639  : 	_Nodeptr _Buyheadnode()
; 640  : 		{	// get head node using current allocator
; 641  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));
; 642  : 		}
; 643  : 
; 644  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 645  : 		{	// free head node using current allocator
; 646  : 		this->_Alnod.destroy(
; 647  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 648  : 		this->_Alnod.destroy(
; 649  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 650  : 		this->_Alnod.deallocate(_Pnode, 1);
; 651  : 		}
; 652  : 
; 653  : 	_Nodeptr _Buynode0(_Nodeptr _Next,
; 654  : 		_Nodeptr _Prev)
; 655  : 		{	// allocate a node and set links
; 656  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 657  : 
; 658  : 		if (_Next == _Nodeptr())
; 659  : 			{	// point at self
; 660  : 			_Next = _Pnode;
; 661  : 			_Prev = _Pnode;
; 662  : 			}
; 663  : 		_TRY_BEGIN
; 664  : 		this->_Alnod.construct(
; 665  : 			_STD addressof(this->_Nextnode(_Pnode)), _Next);
; 666  : 		this->_Alnod.construct(
; 667  : 			_STD addressof(this->_Prevnode(_Pnode)), _Prev);
; 668  : 		_CATCH_ALL
; 669  : 		this->_Alnod.deallocate(_Pnode, 1);
; 670  : 		_RERAISE;
; 671  : 		_CATCH_END
; 672  : 
; 673  : 		return (_Pnode);
; 674  : 		}
; 675  : 
; 676  : 	_Alty& _Getal()
; 677  : 		{	// get reference to allocator
; 678  : 		return (this->_Alnod);
; 679  : 		}
; 680  : 
; 681  : 	const _Alty& _Getal() const
; 682  : 		{	// get reference to allocator
; 683  : 		return (this->_Alnod);
; 684  : 		}
; 685  : 	};
; 686  : 
; 687  : 		// TEMPLATE CLASS _List_alloc
; 688  : template<class _Alloc_types>
; 689  : 	class _List_alloc<false, _Alloc_types>
; 690  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 691  : 	{	// base class for list to hold allocator with no storage
; 692  : public:
; 693  : 	typedef _List_alloc<false, _Alloc_types> _Myt;
; 694  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 695  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 696  : 	typedef typename _Alloc_types::_Node _Node;
; 697  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 698  : 
; 699  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 700  : 	_List_alloc(const _Alloc& = _Alloc())
; 701  : 		{	// construct head node, allocator from _Al
; 702  : 		this->_Myhead = _Buyheadnode();

  00019	89 06		 mov	 DWORD PTR [esi], eax

; 892  : 		}

  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	c3		 ret	 0
??0?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ENDP ; std::list<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::list<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??1?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ PROC ; std::list<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~list<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 1094 : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1097 : 
; 1098 : 	_Myt& operator=(const _Myt& _Right)
; 1099 : 		{	// assign _Right
; 1100 : 		if (this != &_Right)
; 1101 : 			{	// different, assign it
; 1102 : 			if (this->_Getal() != _Right._Getal()
; 1103 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1104 : 				{	// change allocator before copying
; 1105 : 				clear();
; 1106 : 				this->_Change_alloc(_Right._Getal());
; 1107 : 				}
; 1108 : 
; 1109 : 			assign(_Right.begin(), _Right.end());
; 1110 : 			}
; 1111 : 		return (*this);
; 1112 : 		}
; 1113 : 
; 1114 : 	iterator begin() _NOEXCEPT
; 1115 : 		{	// return iterator for beginning of mutable sequence
; 1116 : 		return (iterator(this->_Nextnode(this->_Myhead), this));
; 1117 : 		}
; 1118 : 
; 1119 : 	const_iterator begin() const _NOEXCEPT
; 1120 : 		{	// return iterator for beginning of nonmutable sequence
; 1121 : 		return (const_iterator(this->_Nextnode(this->_Myhead), this));
; 1122 : 		}
; 1123 : 
; 1124 : 	iterator end() _NOEXCEPT
; 1125 : 		{	// return iterator for end of mutable sequence
; 1126 : 		return (iterator(this->_Myhead, this));
; 1127 : 		}
; 1128 : 
; 1129 : 	const_iterator end() const _NOEXCEPT
; 1130 : 		{	// return iterator for end of nonmutable sequence
; 1131 : 		return (const_iterator(this->_Myhead, this));
; 1132 : 		}
; 1133 : 
; 1134 : 	_Unchecked_iterator _Unchecked_begin()
; 1135 : 		{	// return iterator for beginning of mutable sequence
; 1136 : 		return (_Unchecked_iterator(this->_Nextnode(this->_Myhead),
; 1137 : 			this));
; 1138 : 		}
; 1139 : 
; 1140 : 	_Unchecked_const_iterator _Unchecked_begin() const
; 1141 : 		{	// return iterator for beginning of nonmutable sequence
; 1142 : 		return (_Unchecked_const_iterator(this->_Nextnode(this->_Myhead),
; 1143 : 			this));
; 1144 : 		}
; 1145 : 
; 1146 : 	_Unchecked_iterator _Unchecked_end()
; 1147 : 		{	// return unchecked iterator for end of mutable sequence
; 1148 : 		return (_Unchecked_iterator(this->_Myhead, this));
; 1149 : 		}
; 1150 : 
; 1151 : 	_Unchecked_const_iterator _Unchecked_end() const
; 1152 : 		{	// return unchecked iterator for end of nonmutable sequence
; 1153 : 		return (_Unchecked_const_iterator(this->_Myhead, this));
; 1154 : 		}
; 1155 : 
; 1156 : 	iterator _Make_iter(const_iterator _Where) const _NOEXCEPT
; 1157 : 		{	// make iterator from const_iterator
; 1158 : 		return (iterator(_Where._Ptr, this));
; 1159 : 		}
; 1160 : 
; 1161 : 	iterator _Make_iter(_Unchecked_const_iterator _Where) const
; 1162 : 		{	// make iterator from _Unchecked_const_iterator
; 1163 : 		return (iterator(_Where._Ptr, this));
; 1164 : 		}
; 1165 : 
; 1166 : 	reverse_iterator rbegin() _NOEXCEPT
; 1167 : 		{	// return iterator for beginning of reversed mutable sequence
; 1168 : 		return (reverse_iterator(end()));
; 1169 : 		}
; 1170 : 
; 1171 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1172 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1173 : 		return (const_reverse_iterator(end()));
; 1174 : 		}
; 1175 : 
; 1176 : 	reverse_iterator rend() _NOEXCEPT
; 1177 : 		{	// return iterator for end of reversed mutable sequence
; 1178 : 		return (reverse_iterator(begin()));
; 1179 : 		}
; 1180 : 
; 1181 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1182 : 		{	// return iterator for end of reversed nonmutable sequence
; 1183 : 		return (const_reverse_iterator(begin()));
; 1184 : 		}
; 1185 : 
; 1186 : 	const_iterator cbegin() const _NOEXCEPT
; 1187 : 		{	// return iterator for beginning of nonmutable sequence
; 1188 : 		return (((const _Myt *)this)->begin());
; 1189 : 		}
; 1190 : 
; 1191 : 	const_iterator cend() const _NOEXCEPT
; 1192 : 		{	// return iterator for end of nonmutable sequence
; 1193 : 		return (((const _Myt *)this)->end());
; 1194 : 		}
; 1195 : 
; 1196 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1197 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1198 : 		return (((const _Myt *)this)->rbegin());
; 1199 : 		}
; 1200 : 
; 1201 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1202 : 		{	// return iterator for end of reversed nonmutable sequence
; 1203 : 		return (((const _Myt *)this)->rend());
; 1204 : 		}
; 1205 : 
; 1206 : 	void resize(size_type _Newsize)
; 1207 : 		{	// determine new length, padding with _Ty() elements as needed
; 1208 : 		if (this->_Mysize < _Newsize)
; 1209 : 			{	// pad to make larger
; 1210 : 			size_type _Count = 0;
; 1211 : 			_TRY_BEGIN
; 1212 : 			for (; this->_Mysize < _Newsize; ++_Count)
; 1213 : 				_Insert(_Unchecked_end());
; 1214 : 			_CATCH_ALL
; 1215 : 			for (; 0 < _Count; --_Count)
; 1216 : 				pop_back();	// undo inserts
; 1217 : 			_RERAISE;
; 1218 : 			_CATCH_END
; 1219 : 			}
; 1220 : 		else
; 1221 : 			while (_Newsize < this->_Mysize)
; 1222 : 				pop_back();
; 1223 : 		}
; 1224 : 
; 1225 : 	void resize(size_type _Newsize, const _Ty& _Val)
; 1226 : 		{	// determine new length, padding with _Val elements as needed
; 1227 : 		if (this->_Mysize < _Newsize)
; 1228 : 			_Insert_n(_Unchecked_end(), _Newsize - this->_Mysize, _Val);
; 1229 : 		else
; 1230 : 			while (_Newsize < this->_Mysize)
; 1231 : 				pop_back();
; 1232 : 		}
; 1233 : 
; 1234 : 	size_type size() const _NOEXCEPT
; 1235 : 		{	// return length of sequence
; 1236 : 		return (this->_Mysize);
; 1237 : 		}
; 1238 : 
; 1239 : 	size_type max_size() const _NOEXCEPT
; 1240 : 		{	// return maximum possible length of sequence
; 1241 : 		return (this->_Getal().max_size());
; 1242 : 		}
; 1243 : 
; 1244 : 	bool empty() const _NOEXCEPT
; 1245 : 		{	// test if sequence is empty
; 1246 : 		return (this->_Mysize == 0);
; 1247 : 		}
; 1248 : 
; 1249 : 	allocator_type get_allocator() const _NOEXCEPT
; 1250 : 		{	// return allocator object for values
; 1251 : 		return (this->_Getal());
; 1252 : 		}
; 1253 : 
; 1254 : 	reference front()
; 1255 : 		{	// return first element of mutable sequence
; 1256 : 		return (*begin());
; 1257 : 		}
; 1258 : 
; 1259 : 	const_reference front() const
; 1260 : 		{	// return first element of nonmutable sequence
; 1261 : 		return (*begin());
; 1262 : 		}
; 1263 : 
; 1264 : 	reference back()
; 1265 : 		{	// return last element of mutable sequence
; 1266 : 		return (*(--end()));
; 1267 : 		}
; 1268 : 
; 1269 : 	const_reference back() const
; 1270 : 		{	// return last element of nonmutable sequence
; 1271 : 		return (*(--end()));
; 1272 : 		}
; 1273 : 
; 1274 : 	void push_front(const _Ty& _Val)
; 1275 : 		{	// insert element at beginning
; 1276 : 		_Insert(_Unchecked_begin(), _Val);
; 1277 : 		}
; 1278 : 
; 1279 : 	void pop_front()
; 1280 : 		{	// erase element at beginning
; 1281 : 		erase(begin());
; 1282 : 		}
; 1283 : 
; 1284 : 	void push_back(const _Ty& _Val)
; 1285 : 		{	// insert element at end
; 1286 : 		_Insert(_Unchecked_end(), _Val);
; 1287 : 		}
; 1288 : 
; 1289 : 	void pop_back()
; 1290 : 		{	// erase element at end
; 1291 : 		erase(--end());
; 1292 : 		}
; 1293 : 
; 1294 : 	template<class _Iter>
; 1295 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1296 : 			void>::type
; 1297 : 		assign(_Iter _First, _Iter _Last)
; 1298 : 		{	// assign [_First, _Last), input iterators
; 1299 : 		iterator _Old = begin();
; 1300 : 		_TRY_BEGIN
; 1301 : 		for (; _First != _Last && _Old != end(); ++_First, ++_Old)
; 1302 : 			_Reusenode(_Old, *_First);
; 1303 : 		for (; _First != _Last; ++_First)
; 1304 : 			_Insert(_Unchecked_end(), *_First);
; 1305 : 		_CATCH_ALL
; 1306 : 		clear();
; 1307 : 		_RERAISE;
; 1308 : 		_CATCH_END
; 1309 : 		erase(_Old, end());
; 1310 : 		}
; 1311 : 
; 1312 : 	template<class _TArg>
; 1313 : 		void _Reusenode(iterator _Where, _TArg&& _Arg)
; 1314 : 		{	// destroy the element at _Where and reconstruct from _Arg
; 1315 : 		_TRY_BEGIN
; 1316 : 		this->_Getal().destroy(
; 1317 : 			_STD addressof(this->_Myval(_Where._Ptr)));
; 1318 : 		this->_Getal().construct(
; 1319 : 			_STD addressof(this->_Myval(_Where._Ptr)),
; 1320 : 			_STD forward<_TArg>(_Arg));
; 1321 : 		_CATCH_ALL
; 1322 : 		_Unlinknode(_Where);
; 1323 : 		this->_Getal().destroy(
; 1324 : 			_STD addressof(this->_Nextnode(_Where._Ptr)));
; 1325 : 		this->_Getal().destroy(
; 1326 : 			_STD addressof(this->_Prevnode(_Where._Ptr)));
; 1327 : 		this->_Getal().deallocate(_Where._Ptr, 1);
; 1328 : 		_RERAISE;
; 1329 : 		_CATCH_END
; 1330 : 		}
; 1331 : 
; 1332 : 	void assign(size_type _Count, const _Ty& _Val)
; 1333 : 		{	// assign _Count * _Val
; 1334 : 		clear();
; 1335 : 		_Insert_n(_Unchecked_begin(), _Count, _Val);
; 1336 : 		}
; 1337 : 
; 1338 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1339 : 		{	// insert _Val at _Where
; 1340 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1341 : 		if (_Where._Getcont() != this)
; 1342 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1343 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1344 : 
; 1345 : 		_Insert(_Where._Unchecked(), _Val);
; 1346 : 		return (_Make_iter(--_Where));
; 1347 : 		}
; 1348 : 
; 1349 : 	iterator insert(const_iterator _Where, size_type _Count, const _Ty& _Val)
; 1350 : 		{	// insert _Count * _Val at _Where
; 1351 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1352 : 		if (_Where._Getcont() != this)
; 1353 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1354 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1355 : 
; 1356 : 		iterator _Prev = _Make_iter(_Where);
; 1357 : 		if (_Prev == begin())
; 1358 : 			{	// insert sequence at beginning
; 1359 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1360 : 			return (begin());
; 1361 : 			}
; 1362 : 		else
; 1363 : 			{	// insert sequence not at beginning
; 1364 : 			--_Prev;
; 1365 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1366 : 			return (++_Prev);
; 1367 : 			}
; 1368 : 		}
; 1369 : 
; 1370 : 	template<class _Iter>
; 1371 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1372 : 			iterator>::type
; 1373 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1374 : 		{	// insert [_First, _Last) at _Where
; 1375 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1376 : 		if (_Where._Getcont() != this)
; 1377 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1378 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1379 : 
; 1380 : 		iterator _Prev = _Make_iter(_Where);
; 1381 : 		if (_Prev == begin())
; 1382 : 			{	// insert sequence at beginning
; 1383 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1384 : 				_Iter_cat(_First));
; 1385 : 			return (begin());
; 1386 : 			}
; 1387 : 		else
; 1388 : 			{	// insert sequence not at beginning
; 1389 : 			--_Prev;
; 1390 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1391 : 				_Iter_cat(_First));
; 1392 : 			return (++_Prev);
; 1393 : 			}
; 1394 : 		}
; 1395 : 
; 1396 : 	template<class _Iter>
; 1397 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1398 : 			_Iter _First, _Iter _Last, input_iterator_tag)
; 1399 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1400 : 		size_type _Num = 0;
; 1401 : 
; 1402 : 		_TRY_BEGIN
; 1403 : 		for (; _First != _Last; ++_First, ++_Num)
; 1404 : 			_Insert(_Where, *_First);
; 1405 : 		_CATCH_ALL
; 1406 : 		for (; 0 < _Num; --_Num)
; 1407 : 			{	// undo inserts
; 1408 : 			_Unchecked_const_iterator _Before = _Where;
; 1409 : 			_Unchecked_erase(--_Before);
; 1410 : 			}
; 1411 : 		_RERAISE;
; 1412 : 		_CATCH_END
; 1413 : 		}
; 1414 : 
; 1415 : 	template<class _Iter>
; 1416 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1417 : 			_Iter _First, _Iter _Last, forward_iterator_tag)
; 1418 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1419 : 		_DEBUG_RANGE(_First, _Last);
; 1420 : 		_Iter _Next = _First;
; 1421 : 
; 1422 : 		_TRY_BEGIN
; 1423 : 		for (; _First != _Last; ++_First)
; 1424 : 			_Insert(_Where, *_First);
; 1425 : 		_CATCH_ALL
; 1426 : 		for (; _Next != _First; ++_Next)
; 1427 : 			{	// undo inserts
; 1428 : 			_Unchecked_const_iterator _Before = _Where;
; 1429 : 			_Unchecked_erase(--_Before);
; 1430 : 			}
; 1431 : 		_RERAISE;
; 1432 : 		_CATCH_END
; 1433 : 		}
; 1434 : 
; 1435 : 	_Nodeptr _Unlinknode(const_iterator _Where)
; 1436 : 		{	// unlink node at _Where from the list
; 1437 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1438 : 		if (_Where._Getcont() != this || _Where._Ptr == this->_Myhead)
; 1439 : 			_DEBUG_ERROR("list erase iterator outside range");
; 1440 : 		_Nodeptr _Pnode = (_Where)._Mynode();
; 1441 : 		_Orphan_ptr(*this, _Pnode);
; 1442 : 
; 1443 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1444 : 		_Nodeptr _Pnode = (_Where)._Mynode();
; 1445 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1446 : 
; 1447 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1448 : 			this->_Nextnode(_Pnode);
; 1449 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1450 : 			this->_Prevnode(_Pnode);
; 1451 : 
; 1452 : 		--this->_Mysize;
; 1453 : 		return (_Pnode);
; 1454 : 		}
; 1455 : 
; 1456 : 	iterator erase(const_iterator _Where)
; 1457 : 		{	// erase element at _Where
; 1458 : 		_Nodeptr _Pnode = _Unlinknode(_Where++);
; 1459 : 		this->_Freenode(_Pnode);
; 1460 : 		return (_Make_iter(_Where));
; 1461 : 		}
; 1462 : 
; 1463 : 	void _Unchecked_erase(_Unchecked_const_iterator _Where)
; 1464 : 		{	// erase element at _Where
; 1465 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1466 : 
; 1467 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1468 : 			this->_Nextnode(_Pnode);
; 1469 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1470 : 			this->_Prevnode(_Pnode);
; 1471 : 		this->_Freenode(_Pnode);
; 1472 : 		--this->_Mysize;
; 1473 : 		}
; 1474 : 
; 1475 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1476 : 		{	// erase [_First, _Last)
; 1477 : 		if (_First == begin() && _Last == end())
; 1478 : 			{	// erase all and return fresh iterator
; 1479 : 			clear();
; 1480 : 			return (end());
; 1481 : 			}
; 1482 : 		else
; 1483 : 			{	// erase subrange
; 1484 : 			while (_First != _Last)
; 1485 : 				_First = erase(_First);
; 1486 : 			return (_Make_iter(_Last));
; 1487 : 			}
; 1488 : 		}
; 1489 : 
; 1490 : 	void clear() _NOEXCEPT
; 1491 : 		{	// erase all
; 1492 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1493 : 		this->_Orphan_ptr(*this, nullptr);
; 1494 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1495 : 
; 1496 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead);
; 1497 : 		this->_Nextnode(this->_Myhead) = this->_Myhead;
; 1498 : 		this->_Prevnode(this->_Myhead) = this->_Myhead;
; 1499 : 		this->_Mysize = 0;
; 1500 : 
; 1501 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead; _Pnode = _Pnext)
; 1502 : 			{	// delete an element
; 1503 : 			_Pnext = this->_Nextnode(_Pnode);
; 1504 : 			this->_Freenode(_Pnode);
; 1505 : 			}
; 1506 : 		}
; 1507 : 
; 1508 : 	void swap(_Myt& _Right)
; 1509 : 		{	// exchange contents with _Right
; 1510 : 		if (this == &_Right)
; 1511 : 			;	// same object, do nothing
; 1512 : 		else if (this->_Getal() == _Right._Getal())
; 1513 : 			{	// same allocator, swap control information
; 1514 : 			this->_Swap_all(_Right);
; 1515 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1516 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1517 : 			}
; 1518 : 
; 1519 : 		else if (_Alty::propagate_on_container_swap::value)
; 1520 : 			{	// swap allocators and control information
; 1521 : 			this->_Swap_alloc(_Right);
; 1522 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1523 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1524 : 			}
; 1525 : 
; 1526 : 		else	// containers are incompatible
; 1527 : 
; 1528 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1529 : 			_DEBUG_ERROR("list containers incompatible for swap");
; 1530 : 
; 1531 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1532 : 			_XSTD terminate();
; 1533 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1534 : 		}
; 1535 : 
; 1536 : 	void splice(const_iterator _Where, _Myt& _Right)
; 1537 : 		{	// splice all of _Right at _Where
; 1538 : 		if (this != &_Right && !_Right.empty())
; 1539 : 			{	// worth splicing, do it
; 1540 : 			_Splice(_Where, _Right, _Right.begin(), _Right.end(),
; 1541 : 				_Right._Mysize);
; 1542 : 			}
; 1543 : 		}
; 1544 : 
; 1545 : 	void splice(const_iterator _Where, _Myt&& _Right)
; 1546 : 		{	// splice all of _Right at _Where
; 1547 : 		splice(_Where, (_Myt&)_Right);
; 1548 : 		}
; 1549 : 
; 1550 : 	void splice(const_iterator _Where, _Myt& _Right,
; 1551 : 		const_iterator _First)
; 1552 : 		{	// splice _Right [_First, _First + 1) at _Where
; 1553 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1554 : 		if (_First == _Right.end())
; 1555 : 			_DEBUG_ERROR("list splice iterator outside range");
; 1556 : 		else
; 1557 : 
; 1558 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1559 : 		if (_First != _Right.end())
; 1560 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1561 : 
; 1562 : 			{	// element exists, try splice
; 1563 : 			const_iterator _Last = _First;
; 1564 : 			++_Last;
; 1565 : 			if (this != &_Right
; 1566 : 				|| (_Where != _First && _Where != _Last))
; 1567 : 				_Splice(_Where, _Right, _First, _Last, 1);
; 1568 : 			}
; 1569 : 		}
; 1570 : 
; 1571 : 	void splice(const_iterator _Where, _Myt&& _Right,
; 1572 : 		const_iterator _First)
; 1573 : 		{	// splice _Right [_First, _First + 1) at _Where
; 1574 : 		splice(_Where, (_Myt&)_Right, _First);
; 1575 : 		}
; 1576 : 
; 1577 : 	void splice(const_iterator _Where,
; 1578 : 		_Myt& _Right, const_iterator _First, const_iterator _Last)
; 1579 : 		{	// splice _Right [_First, _Last) at _Where
; 1580 : 		if (_First != _Last && (this != &_Right || _Where != _Last))
; 1581 : 			{	// worth splicing, do it
; 1582 : 			size_type _Count = 0;
; 1583 : 
; 1584 : 			if (this == &_Right)
; 1585 : 				;	// just rearrange this list
; 1586 : 			else if (_First == _Right.begin() && _Last == _Right.end())
; 1587 : 				_Count = _Right._Mysize;	// splice in whole list
; 1588 : 			else
; 1589 : 				{	// count nodes and check for knot
; 1590 : 				const_iterator _Next = _First;
; 1591 : 
; 1592 : 				for (; _Next != _Last; ++_Next, ++_Count)
; 1593 : 					if (_Next == _Right.end())
; 1594 : 						_Xlength_error("list<T> bad splice");
; 1595 : 				}
; 1596 : 			_Splice(_Where, _Right, _First, _Last, _Count);
; 1597 : 			}
; 1598 : 		}
; 1599 : 
; 1600 : 	void splice(const_iterator _Where,
; 1601 : 		_Myt&& _Right, const_iterator _First, const_iterator _Last)
; 1602 : 		{	// splice _Right [_First, _Last) at _Where
; 1603 : 		splice(_Where, (_Myt&)_Right, _First, _Last);
; 1604 : 		}
; 1605 : 
; 1606 : 	void remove(const _Ty& _Val)
; 1607 : 		{	// erase each element matching _Val
; 1608 : 		iterator _Val_it = end();
; 1609 : 
; 1610 : 		for (iterator _First = begin(); _First != end(); )
; 1611 : 			if (*_First == _Val)
; 1612 : 				if (_STD addressof(*_First) == _STD addressof(_Val))
; 1613 : 					_Val_it = _First++;
; 1614 : 				else
; 1615 : 					_First = erase(_First);
; 1616 : 			else
; 1617 : 				++_First;
; 1618 : 
; 1619 : 		if (_Val_it != end())
; 1620 : 			erase(_Val_it);
; 1621 : 		}
; 1622 : 
; 1623 : 	template<class _Pr1>
; 1624 : 		void remove_if(_Pr1 _Pred)
; 1625 : 		{	// erase each element satisfying _Pred
; 1626 : 		for (iterator _First = begin(); _First != end(); )
; 1627 : 			if (_Pred(*_First))
; 1628 : 				_First = erase(_First);
; 1629 : 			else
; 1630 : 				++_First;
; 1631 : 		}
; 1632 : 
; 1633 : 	void unique()
; 1634 : 		{	// erase each element matching previous
; 1635 : 		unique(equal_to<>());
; 1636 : 		}
; 1637 : 
; 1638 : 	template<class _Pr2>
; 1639 : 		void unique(_Pr2 _Pred)
; 1640 : 		{	// erase each element satisfying _Pred with previous
; 1641 : 		const _Nodeptr _Phead = this->_Myhead;
; 1642 : 		_Nodeptr _Pprev = this->_Nextnode(_Phead);
; 1643 : 		_Nodeptr _Pnode = this->_Nextnode(_Pprev);
; 1644 : 
; 1645 : 		while (_Pnode != _Phead)
; 1646 : 			if (_Pred(_Pprev->_Myval, _Pnode->_Myval))
; 1647 : 				{	// match, remove it
; 1648 : 				const _Nodeptr _Perase = _Pnode;
; 1649 : 				_Pnode = this->_Nextnode(_Pnode);
; 1650 : 
; 1651 : 				this->_Nextnode(_Pprev) = _Pnode;
; 1652 : 				this->_Prevnode(_Pnode) = _Pprev;
; 1653 : 				this->_Freenode(_Perase);
; 1654 : 
; 1655 : 				--this->_Mysize;
; 1656 : 				}
; 1657 : 			else
; 1658 : 				{	// no match, advance
; 1659 : 				_Pprev = _Pnode;
; 1660 : 				_Pnode = this->_Nextnode(_Pnode);
; 1661 : 				}
; 1662 : 		}
; 1663 : 
; 1664 : 	void merge(_Myt& _Right)
; 1665 : 		{	// merge in elements from _Right, both ordered by operator<
; 1666 : 		merge(_Right, less<>());
; 1667 : 		}
; 1668 : 
; 1669 : 	void merge(_Myt&& _Right)
; 1670 : 		{	// merge in elements from _Right, both ordered by operator<
; 1671 : 		merge((_Myt&)_Right);
; 1672 : 		}
; 1673 : 
; 1674 : 	template<class _Pr2>
; 1675 : 		void merge(_Myt& _Right, _Pr2 _Pred)
; 1676 : 		{	// merge in elements from _Right, both ordered by _Pred
; 1677 : 		if (&_Right != this)
; 1678 : 			{	// safe to merge, do it
; 1679 : 			iterator _First1 = begin(), _Last1 = end();
; 1680 : 			iterator _First2 = _Right.begin(), _Last2 = _Right.end();
; 1681 : 			_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 1682 : 			_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 1683 : 
; 1684 : 			while (_First1 != _Last1 && _First2 != _Last2)
; 1685 : 				if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))
; 1686 : 					{	// splice in an element from _Right
; 1687 : 					iterator _Mid2 = _First2;
; 1688 : 					_Splice(_First1, _Right, _First2, ++_Mid2, 1);
; 1689 : 					_First2 = _Mid2;
; 1690 : 					}
; 1691 : 				else
; 1692 : 					++_First1;
; 1693 : 
; 1694 : 			if (_First2 != _Last2)
; 1695 : 				_Splice(_Last1, _Right, _First2, _Last2,
; 1696 : 					_Right._Mysize);	// splice remainder of _Right
; 1697 : 			}
; 1698 : 		}
; 1699 : 
; 1700 : 	template<class _Pr2>
; 1701 : 		void merge(_Myt&& _Right, _Pr2 _Pred)
; 1702 : 		{	// merge in elements from _Right, both ordered by _Pred
; 1703 : 		merge((_Myt&)_Right, _Pred);
; 1704 : 		}
; 1705 : 
; 1706 : 	void sort()
; 1707 : 		{	// order sequence, using operator<
; 1708 : 		sort(less<>());
; 1709 : 		}
; 1710 : 
; 1711 : 	template<class _Pr2>
; 1712 : 		void sort(_Pr2 _Pred)
; 1713 : 		{	// order sequence, using _Pred
; 1714 : 		if (2 <= this->_Mysize)
; 1715 : 			{	// worth sorting, do it
; 1716 : 			const size_t _MAXBINS = 25;
; 1717 : 			_Myt _Templist(this->_Getal()), _Binlist[_MAXBINS + 1];
; 1718 : 			size_t _Maxbin = 0;
; 1719 : 
; 1720 : 			while (!empty())
; 1721 : 				{	// sort another element, using bins
; 1722 : 				_Templist._Splice_same(_Templist.begin(), *this, begin(),
; 1723 : 					++begin(), 1);
; 1724 : 
; 1725 : 				size_t _Bin;
; 1726 : 				for (_Bin = 0; _Bin < _Maxbin && !_Binlist[_Bin].empty();
; 1727 : 					++_Bin)
; 1728 : 					{	// merge into ever larger bins
; 1729 : 					_Binlist[_Bin].merge(_Templist, _Pred);
; 1730 : 					_Binlist[_Bin].swap(_Templist);
; 1731 : 					}
; 1732 : 
; 1733 : 				if (_Bin == _MAXBINS)
; 1734 : 					_Binlist[_Bin - 1].merge(_Templist, _Pred);
; 1735 : 				else
; 1736 : 					{	// spill to new bin, while they last
; 1737 : 					_Binlist[_Bin].swap(_Templist);
; 1738 : 					if (_Bin == _Maxbin)
; 1739 : 						++_Maxbin;
; 1740 : 					}
; 1741 : 				}
; 1742 : 
; 1743 : 			for (size_t _Bin = 1; _Bin < _Maxbin; ++_Bin)
; 1744 : 				_Binlist[_Bin].merge(_Binlist[_Bin - 1],
; 1745 : 					_Pred);	// merge up
; 1746 : 
; 1747 : 			_Analysis_assume_(0 < _Maxbin);
; 1748 : 
; 1749 : 			splice(begin(), _Binlist[_Maxbin - 1]);	// result in last bin
; 1750 : 			}
; 1751 : 		}
; 1752 : 
; 1753 : 	void reverse() _NOEXCEPT
; 1754 : 		{	// reverse sequence
; 1755 : 		const _Nodeptr _Phead = this->_Myhead;
; 1756 : 		_Nodeptr _Pnode = _Phead;
; 1757 : 
; 1758 : 		for (; ; )
; 1759 : 			{	// flip pointers in a node
; 1760 : 			const _Nodeptr _Pnext = this->_Nextnode(_Pnode);
; 1761 : 			this->_Nextnode(_Pnode) = this->_Prevnode(_Pnode);
; 1762 : 			this->_Prevnode(_Pnode) = _Pnext;
; 1763 : 
; 1764 : 			if (_Pnext == _Phead)
; 1765 : 				break;
; 1766 : 			_Pnode = _Pnext;
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	void _Splice(const_iterator _Where,
; 1771 : 		_Myt& _Right, const_iterator _First, const_iterator _Last,
; 1772 : 		size_type _Count)
; 1773 : 		{	// splice _Right [_First, _Last) before _Where
; 1774 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1775 : 		if (_Where._Getcont() != this)
; 1776 : 			_DEBUG_ERROR("list splice iterator outside range");
; 1777 : 		if (this->_Getal() != _Right._Getal())
; 1778 : 			_DEBUG_ERROR("list containers incompatible for splice");
; 1779 : 
; 1780 : 		if (this != &_Right)
; 1781 : 			{	// transfer ownership
; 1782 : 			_Lockit _Lock(_LOCK_DEBUG);
; 1783 : 
; 1784 : 			const bool _One = _Count == 1;
; 1785 : 			const bool _All = _Count == _Right.size();
; 1786 : 			const bool _Some = !_One && !_All;
; 1787 : 
; 1788 : 			_Nodeptr _Oldprev = _First._Ptr->_Prev;
; 1789 : 
; 1790 : 			if (_Some)
; 1791 : 				for (_Nodeptr _Ptr = _First._Ptr; _Ptr != _Last._Ptr;
; 1792 : 					_Ptr = _Ptr->_Next)
; 1793 : 					{	// mark _Prev pointers
; 1794 : 					_Ptr->_Prev = 0;
; 1795 : 					}
; 1796 : 
; 1797 : 			const_iterator **_Pnext = (const_iterator **)_Right._Getpfirst();
; 1798 : 
; 1799 : 			if (_Pnext == 0)
; 1800 : 				_DEBUG_ERROR("list container corrupted");
; 1801 : 
; 1802 : 			while (*_Pnext != 0)
; 1803 : 				{	// check the iterator
; 1804 : 				const_iterator& _Iter = **_Pnext;
; 1805 : 
; 1806 : 				if ((_One && _Iter._Ptr == _First._Ptr)
; 1807 : 					|| (_All && _Iter._Ptr != _Right._Myhead)
; 1808 : 					|| (_Some && _Iter._Ptr->_Prev == 0))
; 1809 : 					{	// adopt the iterator
; 1810 : 					*_Pnext = (const_iterator *)_Iter._Mynextiter;
; 1811 : 					_Iter._Myproxy = this->_Myproxy;
; 1812 : 					_Iter._Mynextiter = this->_Myproxy->_Myfirstiter;
; 1813 : 					this->_Myproxy->_Myfirstiter = &_Iter;
; 1814 : 					}
; 1815 : 				else
; 1816 : 					{	// skip the iterator
; 1817 : 					_Pnext = (const_iterator **)_Iter._Getpnext();
; 1818 : 					}
; 1819 : 				}
; 1820 : 
; 1821 : 			if (_Some)
; 1822 : 				for (_Nodeptr _Ptr = _First._Ptr; _Ptr != _Last._Ptr;
; 1823 : 					_Ptr = _Ptr->_Next)
; 1824 : 					{	// restore _Prev pointers
; 1825 : 					_Ptr->_Prev = _Oldprev;
; 1826 : 					_Oldprev = _Ptr;
; 1827 : 					}
; 1828 : 			}
; 1829 : 
; 1830 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1831 : 		if (this->_Getal() != _Right._Getal())
; 1832 : 			_XSTD terminate();
; 1833 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1834 : 
; 1835 : 		_Splice_same(_Where, _Right, _First, _Last, _Count);
; 1836 : 		}
; 1837 : 
; 1838 : 	void _Splice_same(const_iterator _Where,
; 1839 : 		_Myt& _Right, const_iterator _First, const_iterator _Last,
; 1840 : 		size_type _Count)
; 1841 : 		{	// splice _Right [_First, _Last) before _Where
; 1842 : 		if (this != &_Right)
; 1843 : 			{	// splicing from another list, adjust counts
; 1844 : 			_Incsize(_Count);
; 1845 : 			_Right._Mysize -= _Count;
; 1846 : 			}
; 1847 : 		this->_Nextnode(this->_Prevnode(_First._Mynode())) =
; 1848 : 			_Last._Mynode();
; 1849 : 		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
; 1850 : 			_Where._Mynode();
; 1851 : 		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
; 1852 : 			_First._Mynode();
; 1853 : 
; 1854 : 		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
; 1855 : 		this->_Prevnode(_Where._Mynode()) =
; 1856 : 			this->_Prevnode(_Last._Mynode());
; 1857 : 		this->_Prevnode(_Last._Mynode()) =
; 1858 : 			this->_Prevnode(_First._Mynode());
; 1859 : 		this->_Prevnode(_First._Mynode()) = _Pnode;
; 1860 : 		}
; 1861 : 
; 1862 : 	void _Unchecked_splice(_Unchecked_const_iterator _Where,
; 1863 : 		_Unchecked_const_iterator _First,
; 1864 : 		_Unchecked_const_iterator _Last)
; 1865 : 		{	// splice [_First, _Last) before _Where
; 1866 : 		this->_Nextnode(this->_Prevnode(_First._Mynode())) =
; 1867 : 			_Last._Mynode();
; 1868 : 		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
; 1869 : 			_Where._Mynode();
; 1870 : 		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
; 1871 : 			_First._Mynode();
; 1872 : 
; 1873 : 		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
; 1874 : 		this->_Prevnode(_Where._Mynode()) =
; 1875 : 			this->_Prevnode(_Last._Mynode());
; 1876 : 		this->_Prevnode(_Last._Mynode()) =
; 1877 : 			this->_Prevnode(_First._Mynode());
; 1878 : 		this->_Prevnode(_First._Mynode()) = _Pnode;
; 1879 : 		}
; 1880 : 
; 1881 : 	void _Tidy()
; 1882 : 		{	// free all storage
; 1883 : 		clear();

  00003	e8 00 00 00 00	 call	 ?clear@?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ ; std::list<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::clear
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00008	ff 36		 push	 DWORD PTR [esi]
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
  00012	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 1096 : 		}

  00013	c3		 ret	 0
??1?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ENDP ; std::list<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~list<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ?begin@?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@XZ PROC ; std::list<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin, COMDAT
; _this$ = ecx

; 1115 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mylist::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		_Ptr = _Mylist::_Nextnode(_Ptr);
; 61   : 		return (*this);
; 62   : 		}
; 63   : 
; 64   : 	_Myiter operator++(int)
; 65   : 		{	// postincrement
; 66   : 		_Myiter _Tmp = *this;
; 67   : 		++*this;
; 68   : 		return (_Tmp);
; 69   : 		}
; 70   : 
; 71   : 	_Myiter& operator--()
; 72   : 		{	// predecrement
; 73   : 		_Ptr = _Mylist::_Prevnode(_Ptr);
; 74   : 		return (*this);
; 75   : 		}
; 76   : 
; 77   : 	_Myiter operator--(int)
; 78   : 		{	// postdecrement
; 79   : 		_Myiter _Tmp = *this;
; 80   : 		--*this;
; 81   : 		return (_Tmp);
; 82   : 		}
; 83   : 
; 84   : 	bool operator==(const _Myiter& _Right) const
; 85   : 		{	// test for iterator equality
; 86   : 		return (_Ptr == _Right._Ptr);
; 87   : 		}
; 88   : 
; 89   : 	bool operator!=(const _Myiter& _Right) const
; 90   : 		{	// test for iterator inequality
; 91   : 		return (!(*this == _Right));
; 92   : 		}
; 93   : 
; 94   : 	_Nodeptr _Mynode() const
; 95   : 		{	// return node pointer
; 96   : 		return (_Ptr);
; 97   : 		}
; 98   : 
; 99   : 	_Nodeptr _Ptr;	// pointer to node
; 100  : 	};
; 101  : 
; 102  : 	// TEMPLATE CLASS _List_unchecked_iterator
; 103  : template<class _Mylist>
; 104  : 	class _List_unchecked_iterator
; 105  : 		: public _List_unchecked_const_iterator<_Mylist>
; 106  : 	{	// unchecked iterator for mutable list
; 107  : public:
; 108  : 	typedef _List_unchecked_iterator<_Mylist> _Myiter;
; 109  : 	typedef _List_unchecked_const_iterator<_Mylist> _Mybase;
; 110  : 	typedef bidirectional_iterator_tag iterator_category;
; 111  : 
; 112  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 113  : 	typedef typename _Mylist::value_type value_type;
; 114  : 	typedef typename _Mylist::difference_type difference_type;
; 115  : 	typedef typename _Mylist::pointer pointer;
; 116  : 	typedef typename _Mylist::reference reference;
; 117  : 
; 118  : 	_List_unchecked_iterator()
; 119  : 		{	// construct with null node
; 120  : 		}
; 121  : 
; 122  : 	_List_unchecked_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 123  : 		: _Mybase(_Pnode, _Plist)
; 124  : 		{	// construct with node pointer _Pnode
; 125  : 		}
; 126  : 
; 127  : 	reference operator*() const
; 128  : 		{	// return designated value
; 129  : 		return ((reference)**(_Mybase *)this);
; 130  : 		}
; 131  : 
; 132  : 	pointer operator->() const
; 133  : 		{	// return pointer to class object
; 134  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 135  : 		}
; 136  : 
; 137  : 	_Myiter& operator++()
; 138  : 		{	// preincrement
; 139  : 		++(*(_Mybase *)this);
; 140  : 		return (*this);
; 141  : 		}
; 142  : 
; 143  : 	_Myiter operator++(int)
; 144  : 		{	// postincrement
; 145  : 		_Myiter _Tmp = *this;
; 146  : 		++*this;
; 147  : 		return (_Tmp);
; 148  : 		}
; 149  : 
; 150  : 	_Myiter& operator--()
; 151  : 		{	// predecrement
; 152  : 		--(*(_Mybase *)this);
; 153  : 		return (*this);
; 154  : 		}
; 155  : 
; 156  : 	_Myiter operator--(int)
; 157  : 		{	// postdecrement
; 158  : 		_Myiter _Tmp = *this;
; 159  : 		--*this;
; 160  : 		return (_Tmp);
; 161  : 		}
; 162  : 	};
; 163  : 
; 164  : 	// TEMPLATE CLASS _List_const_iterator
; 165  : template<class _Mylist>
; 166  : 	class _List_const_iterator
; 167  : 		: public _List_unchecked_const_iterator<_Mylist, _Iterator_base>
; 168  : 	{	// iterator for nonmutable list
; 169  : public:
; 170  : 	typedef _List_const_iterator<_Mylist> _Myiter;
; 171  : 	typedef _List_unchecked_const_iterator<_Mylist, _Iterator_base> _Mybase;
; 172  : 	typedef bidirectional_iterator_tag iterator_category;
; 173  : 
; 174  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 175  : 	typedef typename _Mylist::value_type value_type;
; 176  : 	typedef typename _Mylist::difference_type difference_type;
; 177  : 	typedef typename _Mylist::const_pointer pointer;
; 178  : 	typedef typename _Mylist::const_reference reference;
; 179  : 
; 180  : 	_List_const_iterator()
; 181  : 		: _Mybase()
; 182  : 		{	// construct with null node pointer
; 183  : 		}
; 184  : 
; 185  : 	_List_const_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 186  : 		: _Mybase(_Pnode, _Plist)
; 187  : 		{	// construct with node pointer _Pnode
; 188  : 		}
; 189  : 
; 190  : 	typedef _List_unchecked_const_iterator<_Mylist> _Unchecked_type;
; 191  : 
; 192  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 193  : 		{	// reset from unchecked iterator
; 194  : 		this->_Ptr = _Right._Ptr;
; 195  : 		return (*this);
; 196  : 		}
; 197  : 
; 198  : 	_Unchecked_type _Unchecked() const
; 199  : 		{	// make an unchecked iterator
; 200  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 201  : 		}
; 202  : 
; 203  : 	reference operator*() const
; 204  : 		{	// return designated value
; 205  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 206  : 		if (this->_Getcont() == 0
; 207  : 			|| this->_Ptr == 0
; 208  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 209  : 			{	// report error
; 210  : 			_DEBUG_ERROR("list iterator not dereferencable");
; 211  : 			_SCL_SECURE_OUT_OF_RANGE;
; 212  : 			}
; 213  : 
; 214  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 215  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 216  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 217  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 218  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 219  : 
; 220  : 		return (_Mylist::_Myval(this->_Ptr));
; 221  : 		}
; 222  : 
; 223  : 	_Myiter& operator++()
; 224  : 		{	// preincrement
; 225  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 226  : 		if (this->_Getcont() == 0
; 227  : 			|| this->_Ptr == 0
; 228  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 229  : 			{	// report error
; 230  : 			_DEBUG_ERROR("list iterator not incrementable");
; 231  : 			_SCL_SECURE_OUT_OF_RANGE;
; 232  : 			}
; 233  : 
; 234  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 235  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 236  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 237  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 238  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 239  : 
; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);
; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);
; 299  : 		}
; 300  : 
; 301  : 	bool operator!=(const _Myiter& _Right) const
; 302  : 		{	// test for iterator inequality
; 303  : 		return (!(*this == _Right));
; 304  : 		}
; 305  : 	};
; 306  : 
; 307  : template<class _Mylist> inline
; 308  : 	typename _List_const_iterator<_Mylist>::_Unchecked_type
; 309  : 		_Unchecked(_List_const_iterator<_Mylist> _Iter)
; 310  : 	{	// convert to unchecked
; 311  : 	return (_Iter._Unchecked());
; 312  : 	}
; 313  : 
; 314  : template<class _Mylist> inline
; 315  : 	_List_const_iterator<_Mylist>&
; 316  : 		_Rechecked(_List_const_iterator<_Mylist>& _Iter,
; 317  : 			typename _List_const_iterator<_Mylist>
; 318  : 				::_Unchecked_type _Right)
; 319  : 	{	// convert to checked
; 320  : 	return (_Iter._Rechecked(_Right));
; 321  : 	}
; 322  : 
; 323  : 	// TEMPLATE CLASS _List_iterator
; 324  : template<class _Mylist>
; 325  : 	class _List_iterator
; 326  : 		: public _List_const_iterator<_Mylist>
; 327  : 	{	// iterator for mutable list
; 328  : public:
; 329  : 	typedef _List_iterator<_Mylist> _Myiter;
; 330  : 	typedef _List_const_iterator<_Mylist> _Mybase;
; 331  : 	typedef bidirectional_iterator_tag iterator_category;
; 332  : 
; 333  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 334  : 	typedef typename _Mylist::value_type value_type;
; 335  : 	typedef typename _Mylist::difference_type difference_type;
; 336  : 	typedef typename _Mylist::pointer pointer;
; 337  : 	typedef typename _Mylist::reference reference;
; 338  : 
; 339  : 	_List_iterator()
; 340  : 		{	// construct with null node
; 341  : 		}
; 342  : 
; 343  : 	_List_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 344  : 		: _Mybase(_Pnode, _Plist)
; 345  : 		{	// construct with node pointer _Pnode
; 346  : 		}
; 347  : 
; 348  : 	typedef _List_unchecked_iterator<_Mylist> _Unchecked_type;
; 349  : 
; 350  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 351  : 		{	// reset from unchecked iterator
; 352  : 		this->_Ptr = _Right._Ptr;
; 353  : 		return (*this);
; 354  : 		}
; 355  : 
; 356  : 	_Unchecked_type _Unchecked() const
; 357  : 		{	// make an unchecked iterator
; 358  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 359  : 		}
; 360  : 
; 361  : 	reference operator*() const
; 362  : 		{	// return designated value
; 363  : 		return ((reference)**(_Mybase *)this);
; 364  : 		}
; 365  : 
; 366  : 	pointer operator->() const
; 367  : 		{	// return pointer to class object
; 368  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 369  : 		}
; 370  : 
; 371  : 	_Myiter& operator++()
; 372  : 		{	// preincrement
; 373  : 		++(*(_Mybase *)this);
; 374  : 		return (*this);
; 375  : 		}
; 376  : 
; 377  : 	_Myiter operator++(int)
; 378  : 		{	// postincrement
; 379  : 		_Myiter _Tmp = *this;
; 380  : 		++*this;
; 381  : 		return (_Tmp);
; 382  : 		}
; 383  : 
; 384  : 	_Myiter& operator--()
; 385  : 		{	// predecrement
; 386  : 		--(*(_Mybase *)this);
; 387  : 		return (*this);
; 388  : 		}
; 389  : 
; 390  : 	_Myiter operator--(int)
; 391  : 		{	// postdecrement
; 392  : 		_Myiter _Tmp = *this;
; 393  : 		--*this;
; 394  : 		return (_Tmp);
; 395  : 		}
; 396  : 	};
; 397  : 
; 398  : template<class _Mylist> inline
; 399  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 400  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 401  : 	{	// convert to unchecked
; 402  : 	return (_Iter._Unchecked());
; 403  : 	}
; 404  : 
; 405  : template<class _Mylist> inline
; 406  : 	_List_iterator<_Mylist>&
; 407  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 408  : 			typename _List_iterator<_Mylist>
; 409  : 				::_Unchecked_type _Right)
; 410  : 	{	// convert to checked
; 411  : 	return (_Iter._Rechecked(_Right));
; 412  : 	}
; 413  : 
; 414  : 		// list TYPE WRAPPERS
; 415  : template<class _Value_type,
; 416  : 	class _Size_type,
; 417  : 	class _Difference_type,
; 418  : 	class _Pointer,
; 419  : 	class _Const_pointer,
; 420  : 	class _Reference,
; 421  : 	class _Const_reference,
; 422  : 	class _Nodeptr_type>
; 423  : 	struct _List_iter_types
; 424  : 	{	// wraps types needed by iterators
; 425  : 	typedef _Value_type value_type;
; 426  : 	typedef _Size_type size_type;
; 427  : 	typedef _Difference_type difference_type;
; 428  : 	typedef _Pointer pointer;
; 429  : 	typedef _Const_pointer const_pointer;
; 430  : 	typedef _Reference reference;
; 431  : 	typedef _Const_reference const_reference;
; 432  : 	typedef _Nodeptr_type _Nodeptr;
; 433  : 	};
; 434  : 
; 435  : template<class _Value_type,
; 436  : 	class _Voidptr>
; 437  : 	struct _List_node
; 438  : 		{	// list node
; 439  : 		_Voidptr _Next;	// successor node, or first element if head
; 440  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 441  : 		_Value_type _Myval;	// the stored value, unused if head
; 442  : 
; 443  : 	private:
; 444  : 		_List_node& operator=(const _List_node&);
; 445  : 		};
; 446  : 
; 447  : template<class _Value_type>
; 448  : 	struct _List_node<_Value_type, void *>
; 449  : 		{	// list node
; 450  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 451  : 		_Nodeptr _Next;	// successor node, or first element if head
; 452  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 453  : 		_Value_type _Myval;	// the stored value, unused if head
; 454  : 
; 455  : 	private:
; 456  : 		_List_node& operator=(const _List_node&);
; 457  : 		};
; 458  : 
; 459  : template<class _Ty>
; 460  : 	struct _List_simple_types
; 461  : 		: public _Simple_types<_Ty>
; 462  : 	{	// wraps types needed by iterators
; 463  : 	typedef _List_node<_Ty, void *> _Node;
; 464  : 	typedef _Node *_Nodeptr;
; 465  : 	};
; 466  : 
; 467  : template<class _Ty,
; 468  : 	class _Alloc0>
; 469  : 	struct _List_base_types
; 470  : 	{	// types needed for a container base
; 471  : 	typedef _Alloc0 _Alloc;
; 472  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 473  : 
; 474  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 475  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 476  : 
; 477  : 
; 478  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 479  : 		_Voidptr;
; 480  : 	typedef _List_node<typename _Alty::value_type,
; 481  : 		_Voidptr> _Node;
; 482  : 
; 483  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 484  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 485  : 	typedef _Nodeptr& _Nodepref;
; 486  : 
; 487  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 488  : 		_List_simple_types<typename _Alty::value_type>,
; 489  : 		_List_iter_types<typename _Alty::value_type,
; 490  : 			typename _Alty::size_type,
; 491  : 			typename _Alty::difference_type,
; 492  : 			typename _Alty::pointer,
; 493  : 			typename _Alty::const_pointer,
; 494  : 			typename _Alty::reference,
; 495  : 			typename _Alty::const_reference,
; 496  : 			_Nodeptr> >::type
; 497  : 		_Val_types;
; 498  : 	};
; 499  : 
; 500  : 		// TEMPLATE CLASS _List_val
; 501  : template<class _Val_types>
; 502  : 	class _List_val
; 503  : 		: public _Container_base
; 504  : 	{	// base class for list to hold data
; 505  : public:
; 506  : 	typedef _List_val<_Val_types> _Myt;
; 507  : 
; 508  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 509  : 	typedef _Nodeptr& _Nodepref;
; 510  : 
; 511  : 	typedef typename _Val_types::value_type value_type;
; 512  : 	typedef typename _Val_types::size_type size_type;
; 513  : 	typedef typename _Val_types::difference_type difference_type;
; 514  : 	typedef typename _Val_types::pointer pointer;
; 515  : 	typedef typename _Val_types::const_pointer const_pointer;
; 516  : 	typedef typename _Val_types::reference reference;
; 517  : 	typedef typename _Val_types::const_reference const_reference;
; 518  : 
; 519  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 520  : 	typedef _List_iterator<_Myt> iterator;
; 521  : 
; 522  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 523  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 524  : 
; 525  : 	_List_val()
; 526  : 		{	// initialize data
; 527  : 		this->_Myhead = 0;
; 528  : 		this->_Mysize = 0;
; 529  : 		}
; 530  : 
; 531  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 532  : 		{	// return reference to successor pointer in node
; 533  : 		return ((_Nodepref)_Pnode->_Next);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]

; 44   : 		{	// construct with node pointer _Pnode

  00005	8b 08		 mov	 ecx, DWORD PTR [eax]
  00007	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx

; 1116 : 		return (iterator(this->_Nextnode(this->_Myhead), this));
; 1117 : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?begin@?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ?end@?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@XZ PROC ; std::list<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::end, COMDAT
; _this$ = ecx

; 1125 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 44   : 		{	// construct with node pointer _Pnode

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1126 : 		return (iterator(this->_Myhead, this));
; 1127 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?end@?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ?push_back@?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::list<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back, COMDAT
; _this$ = ecx

; 1285 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 534  : 		}
; 535  : 
; 536  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 537  : 		{	// return reference to predecessor pointer in node
; 538  : 		return ((_Nodepref)_Pnode->_Prev);
; 539  : 		}
; 540  : 
; 541  : 	static reference _Myval(_Nodeptr _Pnode)
; 542  : 		{	// return reference to value in node
; 543  : 		return ((reference)_Pnode->_Myval);
; 544  : 		}
; 545  : 
; 546  : 	_Nodeptr _Myhead;	// pointer to head node
; 547  : 	size_type _Mysize;	// number of elements
; 548  : 	};
; 549  : 
; 550  : 		// TEMPLATE CLASS _List_alloc
; 551  : template<bool _Al_has_storage,
; 552  : 	class _Alloc_types>
; 553  : 	class _List_alloc
; 554  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 555  : 	{	// base class for list to hold allocator with storage
; 556  : public:
; 557  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 558  : 
; 559  : 	typedef _List_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 560  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 561  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 562  : 	typedef typename _Alloc_types::_Node _Node;
; 563  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 564  : 
; 565  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 566  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 567  : 		: _Alnod(_Al)
; 568  : 		{	// construct head node, allocator from _Al
; 569  : 		this->_Myhead = _Buyheadnode();
; 570  : 		}
; 571  : 
; 572  : 	~_List_alloc() _NOEXCEPT
; 573  : 		{	// destroy head node
; 574  : 		_Freeheadnode(this->_Myhead);
; 575  : 		}
; 576  : 
; 577  : 	void _Change_alloc(const _Alty& _Al)
; 578  : 		{	// replace old allocator
; 579  : 		this->_Alnod = _Al;
; 580  : 		}
; 581  : 
; 582  : 	void _Swap_alloc(_Myt& _Right)
; 583  : 		{	// swap allocators
; 584  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 585  : 		}
; 586  : 
; 587  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 588  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 589  : 		: _Alnod(_Al)
; 590  : 		{	// construct head node, allocator from _Al
; 591  : 		this->_Myhead = _Buyheadnode();
; 592  : 		_TRY_BEGIN
; 593  : 		_Alloc_proxy();
; 594  : 		_CATCH_ALL
; 595  : 		_Freeheadnode(this->_Myhead);
; 596  : 		_RERAISE;
; 597  : 		_CATCH_END
; 598  : 		}
; 599  : 
; 600  : 	~_List_alloc() _NOEXCEPT
; 601  : 		{	// destroy proxy
; 602  : 		_Freeheadnode(this->_Myhead);
; 603  : 		_Free_proxy();
; 604  : 		}
; 605  : 
; 606  : 	void _Change_alloc(const _Alty& _Al)
; 607  : 		{	// replace old allocator
; 608  : 		_Free_proxy();
; 609  : 		this->_Alnod = _Al;
; 610  : 		_Alloc_proxy();
; 611  : 		}
; 612  : 
; 613  : 	void _Swap_alloc(_Myt& _Right)
; 614  : 		{	// swap allocators
; 615  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 616  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 617  : 		}
; 618  : 
; 619  : 	void _Alloc_proxy()
; 620  : 		{	// construct proxy from _Alnod
; 621  : 		typename _Alty::template rebind<_Container_proxy>::other
; 622  : 			_Alproxy(this->_Alnod);
; 623  : 		this->_Myproxy = _Alproxy.allocate(1);
; 624  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 625  : 		this->_Myproxy->_Mycont = this;
; 626  : 		}
; 627  : 
; 628  : 	void _Free_proxy()
; 629  : 		{	// destroy proxy
; 630  : 		typename _Alty::template rebind<_Container_proxy>::other
; 631  : 			_Alproxy(this->_Alnod);
; 632  : 		this->_Orphan_all();
; 633  : 		_Alproxy.destroy(this->_Myproxy);
; 634  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 635  : 		this->_Myproxy = 0;
; 636  : 		}
; 637  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 638  : 
; 639  : 	_Nodeptr _Buyheadnode()
; 640  : 		{	// get head node using current allocator
; 641  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));
; 642  : 		}
; 643  : 
; 644  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 645  : 		{	// free head node using current allocator
; 646  : 		this->_Alnod.destroy(
; 647  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 648  : 		this->_Alnod.destroy(
; 649  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 650  : 		this->_Alnod.deallocate(_Pnode, 1);
; 651  : 		}
; 652  : 
; 653  : 	_Nodeptr _Buynode0(_Nodeptr _Next,
; 654  : 		_Nodeptr _Prev)
; 655  : 		{	// allocate a node and set links
; 656  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 657  : 
; 658  : 		if (_Next == _Nodeptr())
; 659  : 			{	// point at self
; 660  : 			_Next = _Pnode;
; 661  : 			_Prev = _Pnode;
; 662  : 			}
; 663  : 		_TRY_BEGIN
; 664  : 		this->_Alnod.construct(
; 665  : 			_STD addressof(this->_Nextnode(_Pnode)), _Next);
; 666  : 		this->_Alnod.construct(
; 667  : 			_STD addressof(this->_Prevnode(_Pnode)), _Prev);
; 668  : 		_CATCH_ALL
; 669  : 		this->_Alnod.deallocate(_Pnode, 1);
; 670  : 		_RERAISE;
; 671  : 		_CATCH_END
; 672  : 
; 673  : 		return (_Pnode);
; 674  : 		}
; 675  : 
; 676  : 	_Alty& _Getal()
; 677  : 		{	// get reference to allocator
; 678  : 		return (this->_Alnod);
; 679  : 		}
; 680  : 
; 681  : 	const _Alty& _Getal() const
; 682  : 		{	// get reference to allocator
; 683  : 		return (this->_Alnod);
; 684  : 		}
; 685  : 	};
; 686  : 
; 687  : 		// TEMPLATE CLASS _List_alloc
; 688  : template<class _Alloc_types>
; 689  : 	class _List_alloc<false, _Alloc_types>
; 690  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 691  : 	{	// base class for list to hold allocator with no storage
; 692  : public:
; 693  : 	typedef _List_alloc<false, _Alloc_types> _Myt;
; 694  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 695  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 696  : 	typedef typename _Alloc_types::_Node _Node;
; 697  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 698  : 
; 699  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 700  : 	_List_alloc(const _Alloc& = _Alloc())
; 701  : 		{	// construct head node, allocator from _Al
; 702  : 		this->_Myhead = _Buyheadnode();
; 703  : 		}
; 704  : 
; 705  : 	~_List_alloc() _NOEXCEPT
; 706  : 		{	// destroy head node
; 707  : 		_Freeheadnode(this->_Myhead);
; 708  : 		}
; 709  : 
; 710  : 	void _Change_alloc(const _Alty&)
; 711  : 		{	// replace old allocator
; 712  : 		}
; 713  : 
; 714  : 	void _Swap_alloc(_Myt&)
; 715  : 		{	// swap allocators
; 716  : 		}
; 717  : 
; 718  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 719  : 	_List_alloc(const _Alloc& = _Alloc())
; 720  : 		{	// construct allocators from _Al
; 721  : 		this->_Myhead = _Buyheadnode();
; 722  : 		_TRY_BEGIN
; 723  : 		_Alloc_proxy();
; 724  : 		_CATCH_ALL
; 725  : 		_Freeheadnode(this->_Myhead);
; 726  : 		_RERAISE;
; 727  : 		_CATCH_END
; 728  : 		}
; 729  : 
; 730  : 	~_List_alloc() _NOEXCEPT
; 731  : 		{	// destroy proxy
; 732  : 		_Freeheadnode(this->_Myhead);
; 733  : 		_Free_proxy();
; 734  : 		}
; 735  : 
; 736  : 	void _Change_alloc(const _Alty&)
; 737  : 		{	// replace old allocator
; 738  : 		}
; 739  : 
; 740  : 	void _Swap_alloc(_Myt& _Right)
; 741  : 		{	// swap allocators
; 742  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 743  : 		}
; 744  : 
; 745  : 	void _Alloc_proxy()
; 746  : 		{	// construct proxy from _Alnod
; 747  : 		typename _Alty::template rebind<_Container_proxy>::other
; 748  : 			_Alproxy;
; 749  : 		this->_Myproxy = _Alproxy.allocate(1);
; 750  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 751  : 		this->_Myproxy->_Mycont = this;
; 752  : 		}
; 753  : 
; 754  : 	void _Free_proxy()
; 755  : 		{	// destroy proxy
; 756  : 		typename _Alty::template rebind<_Container_proxy>::other
; 757  : 			_Alproxy;
; 758  : 		this->_Orphan_all();
; 759  : 		_Alproxy.destroy(this->_Myproxy);
; 760  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 761  : 		this->_Myproxy = 0;
; 762  : 		}
; 763  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 764  : 
; 765  : 	_Nodeptr _Buyheadnode()
; 766  : 		{	// get head node using current allocator
; 767  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));
; 768  : 		}
; 769  : 
; 770  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 771  : 		{	// free head node using current allocator
; 772  : 		this->_Getal().destroy(
; 773  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 774  : 		this->_Getal().destroy(
; 775  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 776  : 		this->_Getal().deallocate(_Pnode, 1);
; 777  : 		}
; 778  : 
; 779  : 	_Nodeptr _Buynode0(_Nodeptr _Next,
; 780  : 		_Nodeptr _Prev)
; 781  : 		{	// allocate a node and set links
; 782  : 		_Nodeptr _Pnode = this->_Getal().allocate(1);
; 783  : 
; 784  : 		if (_Next == _Nodeptr())
; 785  : 			{	// point at self
; 786  : 			_Next = _Pnode;
; 787  : 			_Prev = _Pnode;
; 788  : 			}
; 789  : 		_TRY_BEGIN
; 790  : 		this->_Getal().construct(
; 791  : 			_STD addressof(this->_Nextnode(_Pnode)), _Next);
; 792  : 		this->_Getal().construct(
; 793  : 			_STD addressof(this->_Prevnode(_Pnode)), _Prev);
; 794  : 		_CATCH_ALL
; 795  : 		this->_Getal().deallocate(_Pnode, 1);
; 796  : 		_RERAISE;
; 797  : 		_CATCH_END
; 798  : 
; 799  : 		return (_Pnode);
; 800  : 		}
; 801  : 
; 802  : 	_Alty _Getal() const
; 803  : 		{	// get reference to allocator
; 804  : 		return (_Alty());
; 805  : 		}
; 806  : 	};
; 807  : 
; 808  : 		// TEMPLATE CLASS _List_buy
; 809  : template<class _Ty,
; 810  : 	class _Alloc>
; 811  : 	class _List_buy
; 812  : 		: public _List_alloc<!is_empty<_Alloc>::value,
; 813  : 			_List_base_types<_Ty, _Alloc> >
; 814  : 	{	// base class for list to hold buynode/freenode functions
; 815  : public:
; 816  : 	typedef _List_alloc<!is_empty<_Alloc>::value,
; 817  : 		_List_base_types<_Ty, _Alloc> > _Mybase;
; 818  : 	typedef typename _Mybase::_Alty _Alty;
; 819  : 	typedef typename _Mybase::_Nodeptr _Nodeptr;
; 820  : 
; 821  : 	_List_buy(const _Alloc& _Al = _Alloc())
; 822  : 		: _Mybase(_Al)
; 823  : 		{	// construct from allocator
; 824  : 		}
; 825  : 
; 826  : 	template<class... _Valty>
; 827  : 		_Nodeptr _Buynode(_Nodeptr _Next, _Nodeptr _Prev,
; 828  : 			_Valty&&... _Val)
; 829  : 		{	// allocate a node and set links and value
; 830  : 		_Nodeptr _Pnode = this->_Buynode0(_Next, _Prev);
; 831  : 
; 832  : 		_TRY_BEGIN
; 833  : 		this->_Getal().construct(
; 834  : 			_STD addressof(this->_Myval(_Pnode)),
; 835  : 				_STD forward<_Valty>(_Val)...);
; 836  : 		_CATCH_ALL
; 837  : 		this->_Getal().deallocate(_Pnode, 1);
; 838  : 		_RERAISE;
; 839  : 		_CATCH_END
; 840  : 
; 841  : 		return (_Pnode);
; 842  : 		}
; 843  : 
; 844  : 
; 845  : 	void _Freenode(_Nodeptr _Pnode)
; 846  : 		{	// give node back
; 847  : 		this->_Getal().destroy(
; 848  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 849  : 		this->_Getal().destroy(
; 850  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 851  : 		this->_Getal().destroy(
; 852  : 			_STD addressof(this->_Myval(_Pnode)));
; 853  : 		this->_Getal().deallocate(_Pnode, 1);
; 854  : 		}
; 855  : 	};
; 856  : 
; 857  : 		// TEMPLATE CLASS list
; 858  : template<class _Ty,
; 859  : 	class _Alloc = allocator<_Ty> >
; 860  : 	class list
; 861  : 		: public _List_buy<_Ty, _Alloc>
; 862  : 	{	// bidirectional linked list
; 863  : public:
; 864  : 	typedef list<_Ty, _Alloc> _Myt;
; 865  : 	typedef _List_buy<_Ty, _Alloc> _Mybase;
; 866  : 	typedef typename _Mybase::_Node _Node;
; 867  : 	typedef typename _Mybase::_Nodeptr _Nodeptr;
; 868  : 	typedef typename _Mybase::_Alty _Alty;
; 869  : 
; 870  : 	typedef _Alloc allocator_type;
; 871  : 	typedef typename _Mybase::size_type size_type;
; 872  : 	typedef typename _Mybase::difference_type difference_type;
; 873  : 	typedef typename _Mybase::pointer pointer;
; 874  : 	typedef typename _Mybase::const_pointer const_pointer;
; 875  : 	typedef typename _Mybase::reference reference;
; 876  : 	typedef typename _Mybase::const_reference const_reference;
; 877  : 	typedef typename _Mybase::value_type value_type;
; 878  : 
; 879  : 	typedef typename _Mybase::const_iterator const_iterator;
; 880  : 	typedef typename _Mybase::iterator iterator;
; 881  : 	typedef typename _Mybase::_Unchecked_const_iterator
; 882  : 		_Unchecked_const_iterator;
; 883  : 	typedef typename _Mybase::_Unchecked_iterator
; 884  : 		_Unchecked_iterator;
; 885  : 
; 886  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 887  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 888  : 
; 889  : 	list()
; 890  : 		: _Mybase()
; 891  : 		{	// construct empty list
; 892  : 		}
; 893  : 
; 894  : 	explicit list(const _Alloc& _Al)
; 895  : 		: _Mybase(_Al)
; 896  : 		{	// construct empty list, allocator
; 897  : 		}
; 898  : 
; 899  : 	explicit list(size_type _Count)
; 900  : 		: _Mybase()
; 901  : 		{	// construct list from _Count * _Ty()
; 902  : 		resize(_Count);
; 903  : 		}
; 904  : 
; 905  : 	list(size_type _Count, const _Ty& _Val)
; 906  : 		: _Mybase()
; 907  : 		{	// construct list from _Count * _Val
; 908  : 		_Construct_n(_Count, _Val);
; 909  : 		}
; 910  : 
; 911  : 	list(size_type _Count, const _Ty& _Val, const _Alloc& _Al)
; 912  : 		: _Mybase(_Al)
; 913  : 		{	// construct list from _Count * _Val, allocator
; 914  : 		_Construct_n(_Count, _Val);
; 915  : 		}
; 916  : 
; 917  : 	list(const _Myt& _Right)
; 918  : 
; 919  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 920  : 
; 921  : 
; 922  : 		{	// construct list by copying _Right
; 923  : 		_TRY_BEGIN
; 924  : 		insert(begin(), _Right.begin(), _Right.end());
; 925  : 		_CATCH_ALL
; 926  : 		_Tidy();
; 927  : 		_RERAISE;
; 928  : 		_CATCH_END
; 929  : 		}
; 930  : 
; 931  : 	list(const _Myt& _Right, const _Alloc& _Al)
; 932  : 		: _Mybase(_Al)
; 933  : 		{	// construct list by copying _Right, allocator
; 934  : 		_TRY_BEGIN
; 935  : 		insert(begin(), _Right.begin(), _Right.end());
; 936  : 		_CATCH_ALL
; 937  : 		_Tidy();
; 938  : 		_RERAISE;
; 939  : 		_CATCH_END
; 940  : 		}
; 941  : 
; 942  : 	template<class _Iter,
; 943  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 944  : 			void>::type>
; 945  : 		list(_Iter _First, _Iter _Last)
; 946  : 		: _Mybase()
; 947  : 		{	// construct list from [_First, _Last)
; 948  : 		_Construct(_First, _Last);
; 949  : 		}
; 950  : 
; 951  : 	template<class _Iter,
; 952  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 953  : 			void>::type>
; 954  : 		list(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 955  : 		: _Mybase(_Al)
; 956  : 		{	// construct list, allocator from [_First, _Last)
; 957  : 		_Construct(_First, _Last);
; 958  : 		}
; 959  : 
; 960  : 	template<class _Iter>
; 961  : 		void _Construct(_Iter _First, _Iter _Last)
; 962  : 		{	// construct list from [_First, _Last), input iterators
; 963  : 		_TRY_BEGIN
; 964  : 		insert(begin(), _First, _Last);
; 965  : 		_CATCH_ALL
; 966  : 		_Tidy();
; 967  : 		_RERAISE;
; 968  : 		_CATCH_END
; 969  : 		}
; 970  : 
; 971  : 	void _Construct_n(size_type _Count,
; 972  : 		const _Ty& _Val)
; 973  : 		{	// construct from _Count * _Val
; 974  : 		_TRY_BEGIN
; 975  : 		_Insert_n(_Unchecked_begin(), _Count, _Val);
; 976  : 		_CATCH_ALL
; 977  : 		_Tidy();
; 978  : 		_RERAISE;
; 979  : 		_CATCH_END
; 980  : 		}
; 981  : 
; 982  : 	list(_Myt&& _Right)
; 983  : 		: _Mybase(_Right._Getal())
; 984  : 		{	// construct list by moving _Right
; 985  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 986  : 		}
; 987  : 
; 988  : 	list(_Myt&& _Right, const _Alloc& _Al)
; 989  : 		: _Mybase(_Al)
; 990  : 		{	// construct list by moving _Right, allocator
; 991  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 992  : 		}
; 993  : 
; 994  : 	_Myt& operator=(_Myt&& _Right)
; 995  : 		{	// assign by moving _Right
; 996  : 		if (this != &_Right)
; 997  : 			{	// different, assign it
; 998  : 			clear();
; 999  : 
; 1000 : 			if (_Alty::propagate_on_container_move_assignment::value
; 1001 : 				&& this->_Getal() != _Right._Getal())
; 1002 : 				this->_Change_alloc(_Right._Getal());
; 1003 : 
; 1004 : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 1005 : 			}
; 1006 : 		return (*this);
; 1007 : 		}
; 1008 : 
; 1009 : 	void _Assign_rv(_Myt&& _Right)
; 1010 : 		{	// swap with empty *this, same allocator
; 1011 : 		this->_Swap_all(_Right);
; 1012 : 		_Swap_adl(this->_Myhead, _Right._Myhead);
; 1013 : 		_STD swap(this->_Mysize, _Right._Mysize);
; 1014 : 		}
; 1015 : 
; 1016 : 	void push_front(_Ty&& _Val)
; 1017 : 		{	// insert element at beginning
; 1018 : 		_Insert(_Unchecked_begin(), _STD forward<_Ty>(_Val));
; 1019 : 		}
; 1020 : 
; 1021 : 	void push_back(_Ty&& _Val)
; 1022 : 		{	// insert element at end
; 1023 : 		_Insert(_Unchecked_end(), _STD forward<_Ty>(_Val));
; 1024 : 		}
; 1025 : 
; 1026 : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 1027 : 		{	// insert _Val at _Where
; 1028 : 		return (emplace(_Where, _STD forward<_Ty>(_Val)));
; 1029 : 		}
; 1030 : 
; 1031 : 	template<class... _Valty>
; 1032 : 		void emplace_front(_Valty&&... _Val)
; 1033 : 		{	// insert element at beginning
; 1034 : 		_Insert(_Unchecked_begin(), _STD forward<_Valty>(_Val)...);
; 1035 : 		}
; 1036 : 
; 1037 : 	template<class... _Valty>
; 1038 : 		void emplace_back(_Valty&&... _Val)
; 1039 : 		{	// insert element at end
; 1040 : 		_Insert(_Unchecked_end(), _STD forward<_Valty>(_Val)...);
; 1041 : 		}
; 1042 : 
; 1043 : 	template<class... _Valty>
; 1044 : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 1045 : 		{	// insert element at _Where
; 1046 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1047 : 		if (_Where._Getcont() != this)
; 1048 : 			_DEBUG_ERROR("list emplace iterator outside range");
; 1049 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1050 : 
; 1051 : 		_Insert(_Where._Unchecked(), _STD forward<_Valty>(_Val)...);
; 1052 : 		return (_Make_iter(--_Where));
; 1053 : 		}
; 1054 : 
; 1055 : 	template<class... _Valty>
; 1056 : 		void _Insert(_Unchecked_const_iterator _Where,
; 1057 : 		_Valty&&... _Val)
; 1058 : 		{	// insert element at _Where
; 1059 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1060 : 		_Nodeptr _Newnode =
; 1061 : 			this->_Buynode(_Pnode, this->_Prevnode(_Pnode),
; 1062 : 				_STD forward<_Valty>(_Val)...);

  00007	ff 75 08	 push	 DWORD PTR __Val$[ebp]

; 96   : 		return (_Ptr);

  0000a	8b 3e		 mov	 edi, DWORD PTR [esi]

; 534  : 		}
; 535  : 
; 536  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 537  : 		{	// return reference to predecessor pointer in node
; 538  : 		return ((_Nodepref)_Pnode->_Prev);
; 539  : 		}
; 540  : 
; 541  : 	static reference _Myval(_Nodeptr _Pnode)
; 542  : 		{	// return reference to value in node
; 543  : 		return ((reference)_Pnode->_Myval);
; 544  : 		}
; 545  : 
; 546  : 	_Nodeptr _Myhead;	// pointer to head node
; 547  : 	size_type _Mysize;	// number of elements
; 548  : 	};
; 549  : 
; 550  : 		// TEMPLATE CLASS _List_alloc
; 551  : template<bool _Al_has_storage,
; 552  : 	class _Alloc_types>
; 553  : 	class _List_alloc
; 554  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 555  : 	{	// base class for list to hold allocator with storage
; 556  : public:
; 557  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 558  : 
; 559  : 	typedef _List_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 560  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 561  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 562  : 	typedef typename _Alloc_types::_Node _Node;
; 563  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 564  : 
; 565  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 566  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 567  : 		: _Alnod(_Al)
; 568  : 		{	// construct head node, allocator from _Al
; 569  : 		this->_Myhead = _Buyheadnode();
; 570  : 		}
; 571  : 
; 572  : 	~_List_alloc() _NOEXCEPT
; 573  : 		{	// destroy head node
; 574  : 		_Freeheadnode(this->_Myhead);
; 575  : 		}
; 576  : 
; 577  : 	void _Change_alloc(const _Alty& _Al)
; 578  : 		{	// replace old allocator
; 579  : 		this->_Alnod = _Al;
; 580  : 		}
; 581  : 
; 582  : 	void _Swap_alloc(_Myt& _Right)
; 583  : 		{	// swap allocators
; 584  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 585  : 		}
; 586  : 
; 587  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 588  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 589  : 		: _Alnod(_Al)
; 590  : 		{	// construct head node, allocator from _Al
; 591  : 		this->_Myhead = _Buyheadnode();
; 592  : 		_TRY_BEGIN
; 593  : 		_Alloc_proxy();
; 594  : 		_CATCH_ALL
; 595  : 		_Freeheadnode(this->_Myhead);
; 596  : 		_RERAISE;
; 597  : 		_CATCH_END
; 598  : 		}
; 599  : 
; 600  : 	~_List_alloc() _NOEXCEPT
; 601  : 		{	// destroy proxy
; 602  : 		_Freeheadnode(this->_Myhead);
; 603  : 		_Free_proxy();
; 604  : 		}
; 605  : 
; 606  : 	void _Change_alloc(const _Alty& _Al)
; 607  : 		{	// replace old allocator
; 608  : 		_Free_proxy();
; 609  : 		this->_Alnod = _Al;
; 610  : 		_Alloc_proxy();
; 611  : 		}
; 612  : 
; 613  : 	void _Swap_alloc(_Myt& _Right)
; 614  : 		{	// swap allocators
; 615  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 616  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 617  : 		}
; 618  : 
; 619  : 	void _Alloc_proxy()
; 620  : 		{	// construct proxy from _Alnod
; 621  : 		typename _Alty::template rebind<_Container_proxy>::other
; 622  : 			_Alproxy(this->_Alnod);
; 623  : 		this->_Myproxy = _Alproxy.allocate(1);
; 624  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 625  : 		this->_Myproxy->_Mycont = this;
; 626  : 		}
; 627  : 
; 628  : 	void _Free_proxy()
; 629  : 		{	// destroy proxy
; 630  : 		typename _Alty::template rebind<_Container_proxy>::other
; 631  : 			_Alproxy(this->_Alnod);
; 632  : 		this->_Orphan_all();
; 633  : 		_Alproxy.destroy(this->_Myproxy);
; 634  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 635  : 		this->_Myproxy = 0;
; 636  : 		}
; 637  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 638  : 
; 639  : 	_Nodeptr _Buyheadnode()
; 640  : 		{	// get head node using current allocator
; 641  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));
; 642  : 		}
; 643  : 
; 644  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 645  : 		{	// free head node using current allocator
; 646  : 		this->_Alnod.destroy(
; 647  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 648  : 		this->_Alnod.destroy(
; 649  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 650  : 		this->_Alnod.deallocate(_Pnode, 1);
; 651  : 		}
; 652  : 
; 653  : 	_Nodeptr _Buynode0(_Nodeptr _Next,
; 654  : 		_Nodeptr _Prev)
; 655  : 		{	// allocate a node and set links
; 656  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 657  : 
; 658  : 		if (_Next == _Nodeptr())
; 659  : 			{	// point at self
; 660  : 			_Next = _Pnode;
; 661  : 			_Prev = _Pnode;
; 662  : 			}
; 663  : 		_TRY_BEGIN
; 664  : 		this->_Alnod.construct(
; 665  : 			_STD addressof(this->_Nextnode(_Pnode)), _Next);
; 666  : 		this->_Alnod.construct(
; 667  : 			_STD addressof(this->_Prevnode(_Pnode)), _Prev);
; 668  : 		_CATCH_ALL
; 669  : 		this->_Alnod.deallocate(_Pnode, 1);
; 670  : 		_RERAISE;
; 671  : 		_CATCH_END
; 672  : 
; 673  : 		return (_Pnode);
; 674  : 		}
; 675  : 
; 676  : 	_Alty& _Getal()
; 677  : 		{	// get reference to allocator
; 678  : 		return (this->_Alnod);
; 679  : 		}
; 680  : 
; 681  : 	const _Alty& _Getal() const
; 682  : 		{	// get reference to allocator
; 683  : 		return (this->_Alnod);
; 684  : 		}
; 685  : 	};
; 686  : 
; 687  : 		// TEMPLATE CLASS _List_alloc
; 688  : template<class _Alloc_types>
; 689  : 	class _List_alloc<false, _Alloc_types>
; 690  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 691  : 	{	// base class for list to hold allocator with no storage
; 692  : public:
; 693  : 	typedef _List_alloc<false, _Alloc_types> _Myt;
; 694  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 695  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 696  : 	typedef typename _Alloc_types::_Node _Node;
; 697  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 698  : 
; 699  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 700  : 	_List_alloc(const _Alloc& = _Alloc())
; 701  : 		{	// construct head node, allocator from _Al
; 702  : 		this->_Myhead = _Buyheadnode();
; 703  : 		}
; 704  : 
; 705  : 	~_List_alloc() _NOEXCEPT
; 706  : 		{	// destroy head node
; 707  : 		_Freeheadnode(this->_Myhead);
; 708  : 		}
; 709  : 
; 710  : 	void _Change_alloc(const _Alty&)
; 711  : 		{	// replace old allocator
; 712  : 		}
; 713  : 
; 714  : 	void _Swap_alloc(_Myt&)
; 715  : 		{	// swap allocators
; 716  : 		}
; 717  : 
; 718  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 719  : 	_List_alloc(const _Alloc& = _Alloc())
; 720  : 		{	// construct allocators from _Al
; 721  : 		this->_Myhead = _Buyheadnode();
; 722  : 		_TRY_BEGIN
; 723  : 		_Alloc_proxy();
; 724  : 		_CATCH_ALL
; 725  : 		_Freeheadnode(this->_Myhead);
; 726  : 		_RERAISE;
; 727  : 		_CATCH_END
; 728  : 		}
; 729  : 
; 730  : 	~_List_alloc() _NOEXCEPT
; 731  : 		{	// destroy proxy
; 732  : 		_Freeheadnode(this->_Myhead);
; 733  : 		_Free_proxy();
; 734  : 		}
; 735  : 
; 736  : 	void _Change_alloc(const _Alty&)
; 737  : 		{	// replace old allocator
; 738  : 		}
; 739  : 
; 740  : 	void _Swap_alloc(_Myt& _Right)
; 741  : 		{	// swap allocators
; 742  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 743  : 		}
; 744  : 
; 745  : 	void _Alloc_proxy()
; 746  : 		{	// construct proxy from _Alnod
; 747  : 		typename _Alty::template rebind<_Container_proxy>::other
; 748  : 			_Alproxy;
; 749  : 		this->_Myproxy = _Alproxy.allocate(1);
; 750  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 751  : 		this->_Myproxy->_Mycont = this;
; 752  : 		}
; 753  : 
; 754  : 	void _Free_proxy()
; 755  : 		{	// destroy proxy
; 756  : 		typename _Alty::template rebind<_Container_proxy>::other
; 757  : 			_Alproxy;
; 758  : 		this->_Orphan_all();
; 759  : 		_Alproxy.destroy(this->_Myproxy);
; 760  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 761  : 		this->_Myproxy = 0;
; 762  : 		}
; 763  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 764  : 
; 765  : 	_Nodeptr _Buyheadnode()
; 766  : 		{	// get head node using current allocator
; 767  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));
; 768  : 		}
; 769  : 
; 770  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 771  : 		{	// free head node using current allocator
; 772  : 		this->_Getal().destroy(
; 773  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 774  : 		this->_Getal().destroy(
; 775  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 776  : 		this->_Getal().deallocate(_Pnode, 1);
; 777  : 		}
; 778  : 
; 779  : 	_Nodeptr _Buynode0(_Nodeptr _Next,
; 780  : 		_Nodeptr _Prev)
; 781  : 		{	// allocate a node and set links
; 782  : 		_Nodeptr _Pnode = this->_Getal().allocate(1);
; 783  : 
; 784  : 		if (_Next == _Nodeptr())
; 785  : 			{	// point at self
; 786  : 			_Next = _Pnode;
; 787  : 			_Prev = _Pnode;
; 788  : 			}
; 789  : 		_TRY_BEGIN
; 790  : 		this->_Getal().construct(
; 791  : 			_STD addressof(this->_Nextnode(_Pnode)), _Next);
; 792  : 		this->_Getal().construct(
; 793  : 			_STD addressof(this->_Prevnode(_Pnode)), _Prev);
; 794  : 		_CATCH_ALL
; 795  : 		this->_Getal().deallocate(_Pnode, 1);
; 796  : 		_RERAISE;
; 797  : 		_CATCH_END
; 798  : 
; 799  : 		return (_Pnode);
; 800  : 		}
; 801  : 
; 802  : 	_Alty _Getal() const
; 803  : 		{	// get reference to allocator
; 804  : 		return (_Alty());
; 805  : 		}
; 806  : 	};
; 807  : 
; 808  : 		// TEMPLATE CLASS _List_buy
; 809  : template<class _Ty,
; 810  : 	class _Alloc>
; 811  : 	class _List_buy
; 812  : 		: public _List_alloc<!is_empty<_Alloc>::value,
; 813  : 			_List_base_types<_Ty, _Alloc> >
; 814  : 	{	// base class for list to hold buynode/freenode functions
; 815  : public:
; 816  : 	typedef _List_alloc<!is_empty<_Alloc>::value,
; 817  : 		_List_base_types<_Ty, _Alloc> > _Mybase;
; 818  : 	typedef typename _Mybase::_Alty _Alty;
; 819  : 	typedef typename _Mybase::_Nodeptr _Nodeptr;
; 820  : 
; 821  : 	_List_buy(const _Alloc& _Al = _Alloc())
; 822  : 		: _Mybase(_Al)
; 823  : 		{	// construct from allocator
; 824  : 		}
; 825  : 
; 826  : 	template<class... _Valty>
; 827  : 		_Nodeptr _Buynode(_Nodeptr _Next, _Nodeptr _Prev,
; 828  : 			_Valty&&... _Val)
; 829  : 		{	// allocate a node and set links and value
; 830  : 		_Nodeptr _Pnode = this->_Buynode0(_Next, _Prev);
; 831  : 
; 832  : 		_TRY_BEGIN
; 833  : 		this->_Getal().construct(
; 834  : 			_STD addressof(this->_Myval(_Pnode)),
; 835  : 				_STD forward<_Valty>(_Val)...);
; 836  : 		_CATCH_ALL
; 837  : 		this->_Getal().deallocate(_Pnode, 1);
; 838  : 		_RERAISE;
; 839  : 		_CATCH_END
; 840  : 
; 841  : 		return (_Pnode);
; 842  : 		}
; 843  : 
; 844  : 
; 845  : 	void _Freenode(_Nodeptr _Pnode)
; 846  : 		{	// give node back
; 847  : 		this->_Getal().destroy(
; 848  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 849  : 		this->_Getal().destroy(
; 850  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 851  : 		this->_Getal().destroy(
; 852  : 			_STD addressof(this->_Myval(_Pnode)));
; 853  : 		this->_Getal().deallocate(_Pnode, 1);
; 854  : 		}
; 855  : 	};
; 856  : 
; 857  : 		// TEMPLATE CLASS list
; 858  : template<class _Ty,
; 859  : 	class _Alloc = allocator<_Ty> >
; 860  : 	class list
; 861  : 		: public _List_buy<_Ty, _Alloc>
; 862  : 	{	// bidirectional linked list
; 863  : public:
; 864  : 	typedef list<_Ty, _Alloc> _Myt;
; 865  : 	typedef _List_buy<_Ty, _Alloc> _Mybase;
; 866  : 	typedef typename _Mybase::_Node _Node;
; 867  : 	typedef typename _Mybase::_Nodeptr _Nodeptr;
; 868  : 	typedef typename _Mybase::_Alty _Alty;
; 869  : 
; 870  : 	typedef _Alloc allocator_type;
; 871  : 	typedef typename _Mybase::size_type size_type;
; 872  : 	typedef typename _Mybase::difference_type difference_type;
; 873  : 	typedef typename _Mybase::pointer pointer;
; 874  : 	typedef typename _Mybase::const_pointer const_pointer;
; 875  : 	typedef typename _Mybase::reference reference;
; 876  : 	typedef typename _Mybase::const_reference const_reference;
; 877  : 	typedef typename _Mybase::value_type value_type;
; 878  : 
; 879  : 	typedef typename _Mybase::const_iterator const_iterator;
; 880  : 	typedef typename _Mybase::iterator iterator;
; 881  : 	typedef typename _Mybase::_Unchecked_const_iterator
; 882  : 		_Unchecked_const_iterator;
; 883  : 	typedef typename _Mybase::_Unchecked_iterator
; 884  : 		_Unchecked_iterator;
; 885  : 
; 886  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 887  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 888  : 
; 889  : 	list()
; 890  : 		: _Mybase()
; 891  : 		{	// construct empty list
; 892  : 		}
; 893  : 
; 894  : 	explicit list(const _Alloc& _Al)
; 895  : 		: _Mybase(_Al)
; 896  : 		{	// construct empty list, allocator
; 897  : 		}
; 898  : 
; 899  : 	explicit list(size_type _Count)
; 900  : 		: _Mybase()
; 901  : 		{	// construct list from _Count * _Ty()
; 902  : 		resize(_Count);
; 903  : 		}
; 904  : 
; 905  : 	list(size_type _Count, const _Ty& _Val)
; 906  : 		: _Mybase()
; 907  : 		{	// construct list from _Count * _Val
; 908  : 		_Construct_n(_Count, _Val);
; 909  : 		}
; 910  : 
; 911  : 	list(size_type _Count, const _Ty& _Val, const _Alloc& _Al)
; 912  : 		: _Mybase(_Al)
; 913  : 		{	// construct list from _Count * _Val, allocator
; 914  : 		_Construct_n(_Count, _Val);
; 915  : 		}
; 916  : 
; 917  : 	list(const _Myt& _Right)
; 918  : 
; 919  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 920  : 
; 921  : 
; 922  : 		{	// construct list by copying _Right
; 923  : 		_TRY_BEGIN
; 924  : 		insert(begin(), _Right.begin(), _Right.end());
; 925  : 		_CATCH_ALL
; 926  : 		_Tidy();
; 927  : 		_RERAISE;
; 928  : 		_CATCH_END
; 929  : 		}
; 930  : 
; 931  : 	list(const _Myt& _Right, const _Alloc& _Al)
; 932  : 		: _Mybase(_Al)
; 933  : 		{	// construct list by copying _Right, allocator
; 934  : 		_TRY_BEGIN
; 935  : 		insert(begin(), _Right.begin(), _Right.end());
; 936  : 		_CATCH_ALL
; 937  : 		_Tidy();
; 938  : 		_RERAISE;
; 939  : 		_CATCH_END
; 940  : 		}
; 941  : 
; 942  : 	template<class _Iter,
; 943  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 944  : 			void>::type>
; 945  : 		list(_Iter _First, _Iter _Last)
; 946  : 		: _Mybase()
; 947  : 		{	// construct list from [_First, _Last)
; 948  : 		_Construct(_First, _Last);
; 949  : 		}
; 950  : 
; 951  : 	template<class _Iter,
; 952  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 953  : 			void>::type>
; 954  : 		list(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 955  : 		: _Mybase(_Al)
; 956  : 		{	// construct list, allocator from [_First, _Last)
; 957  : 		_Construct(_First, _Last);
; 958  : 		}
; 959  : 
; 960  : 	template<class _Iter>
; 961  : 		void _Construct(_Iter _First, _Iter _Last)
; 962  : 		{	// construct list from [_First, _Last), input iterators
; 963  : 		_TRY_BEGIN
; 964  : 		insert(begin(), _First, _Last);
; 965  : 		_CATCH_ALL
; 966  : 		_Tidy();
; 967  : 		_RERAISE;
; 968  : 		_CATCH_END
; 969  : 		}
; 970  : 
; 971  : 	void _Construct_n(size_type _Count,
; 972  : 		const _Ty& _Val)
; 973  : 		{	// construct from _Count * _Val
; 974  : 		_TRY_BEGIN
; 975  : 		_Insert_n(_Unchecked_begin(), _Count, _Val);
; 976  : 		_CATCH_ALL
; 977  : 		_Tidy();
; 978  : 		_RERAISE;
; 979  : 		_CATCH_END
; 980  : 		}
; 981  : 
; 982  : 	list(_Myt&& _Right)
; 983  : 		: _Mybase(_Right._Getal())
; 984  : 		{	// construct list by moving _Right
; 985  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 986  : 		}
; 987  : 
; 988  : 	list(_Myt&& _Right, const _Alloc& _Al)
; 989  : 		: _Mybase(_Al)
; 990  : 		{	// construct list by moving _Right, allocator
; 991  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 992  : 		}
; 993  : 
; 994  : 	_Myt& operator=(_Myt&& _Right)
; 995  : 		{	// assign by moving _Right
; 996  : 		if (this != &_Right)
; 997  : 			{	// different, assign it
; 998  : 			clear();
; 999  : 
; 1000 : 			if (_Alty::propagate_on_container_move_assignment::value
; 1001 : 				&& this->_Getal() != _Right._Getal())
; 1002 : 				this->_Change_alloc(_Right._Getal());
; 1003 : 
; 1004 : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 1005 : 			}
; 1006 : 		return (*this);
; 1007 : 		}
; 1008 : 
; 1009 : 	void _Assign_rv(_Myt&& _Right)
; 1010 : 		{	// swap with empty *this, same allocator
; 1011 : 		this->_Swap_all(_Right);
; 1012 : 		_Swap_adl(this->_Myhead, _Right._Myhead);
; 1013 : 		_STD swap(this->_Mysize, _Right._Mysize);
; 1014 : 		}
; 1015 : 
; 1016 : 	void push_front(_Ty&& _Val)
; 1017 : 		{	// insert element at beginning
; 1018 : 		_Insert(_Unchecked_begin(), _STD forward<_Ty>(_Val));
; 1019 : 		}
; 1020 : 
; 1021 : 	void push_back(_Ty&& _Val)
; 1022 : 		{	// insert element at end
; 1023 : 		_Insert(_Unchecked_end(), _STD forward<_Ty>(_Val));
; 1024 : 		}
; 1025 : 
; 1026 : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 1027 : 		{	// insert _Val at _Where
; 1028 : 		return (emplace(_Where, _STD forward<_Ty>(_Val)));
; 1029 : 		}
; 1030 : 
; 1031 : 	template<class... _Valty>
; 1032 : 		void emplace_front(_Valty&&... _Val)
; 1033 : 		{	// insert element at beginning
; 1034 : 		_Insert(_Unchecked_begin(), _STD forward<_Valty>(_Val)...);
; 1035 : 		}
; 1036 : 
; 1037 : 	template<class... _Valty>
; 1038 : 		void emplace_back(_Valty&&... _Val)
; 1039 : 		{	// insert element at end
; 1040 : 		_Insert(_Unchecked_end(), _STD forward<_Valty>(_Val)...);
; 1041 : 		}
; 1042 : 
; 1043 : 	template<class... _Valty>
; 1044 : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 1045 : 		{	// insert element at _Where
; 1046 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1047 : 		if (_Where._Getcont() != this)
; 1048 : 			_DEBUG_ERROR("list emplace iterator outside range");
; 1049 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1050 : 
; 1051 : 		_Insert(_Where._Unchecked(), _STD forward<_Valty>(_Val)...);
; 1052 : 		return (_Make_iter(--_Where));
; 1053 : 		}
; 1054 : 
; 1055 : 	template<class... _Valty>
; 1056 : 		void _Insert(_Unchecked_const_iterator _Where,
; 1057 : 		_Valty&&... _Val)
; 1058 : 		{	// insert element at _Where
; 1059 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1060 : 		_Nodeptr _Newnode =
; 1061 : 			this->_Buynode(_Pnode, this->_Prevnode(_Pnode),
; 1062 : 				_STD forward<_Valty>(_Val)...);

  0000c	ff 77 04	 push	 DWORD PTR [edi+4]
  0000f	57		 push	 edi
  00010	e8 00 00 00 00	 call	 ??$_Buynode@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_buy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@PAU21@0ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_List_buy<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Buynode<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
  00015	8b d0		 mov	 edx, eax

; 1288 : 
; 1289 : 	void pop_back()
; 1290 : 		{	// erase element at end
; 1291 : 		erase(--end());
; 1292 : 		}
; 1293 : 
; 1294 : 	template<class _Iter>
; 1295 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1296 : 			void>::type
; 1297 : 		assign(_Iter _First, _Iter _Last)
; 1298 : 		{	// assign [_First, _Last), input iterators
; 1299 : 		iterator _Old = begin();
; 1300 : 		_TRY_BEGIN
; 1301 : 		for (; _First != _Last && _Old != end(); ++_First, ++_Old)
; 1302 : 			_Reusenode(_Old, *_First);
; 1303 : 		for (; _First != _Last; ++_First)
; 1304 : 			_Insert(_Unchecked_end(), *_First);
; 1305 : 		_CATCH_ALL
; 1306 : 		clear();
; 1307 : 		_RERAISE;
; 1308 : 		_CATCH_END
; 1309 : 		erase(_Old, end());
; 1310 : 		}
; 1311 : 
; 1312 : 	template<class _TArg>
; 1313 : 		void _Reusenode(iterator _Where, _TArg&& _Arg)
; 1314 : 		{	// destroy the element at _Where and reconstruct from _Arg
; 1315 : 		_TRY_BEGIN
; 1316 : 		this->_Getal().destroy(
; 1317 : 			_STD addressof(this->_Myval(_Where._Ptr)));
; 1318 : 		this->_Getal().construct(
; 1319 : 			_STD addressof(this->_Myval(_Where._Ptr)),
; 1320 : 			_STD forward<_TArg>(_Arg));
; 1321 : 		_CATCH_ALL
; 1322 : 		_Unlinknode(_Where);
; 1323 : 		this->_Getal().destroy(
; 1324 : 			_STD addressof(this->_Nextnode(_Where._Ptr)));
; 1325 : 		this->_Getal().destroy(
; 1326 : 			_STD addressof(this->_Prevnode(_Where._Ptr)));
; 1327 : 		this->_Getal().deallocate(_Where._Ptr, 1);
; 1328 : 		_RERAISE;
; 1329 : 		_CATCH_END
; 1330 : 		}
; 1331 : 
; 1332 : 	void assign(size_type _Count, const _Ty& _Val)
; 1333 : 		{	// assign _Count * _Val
; 1334 : 		clear();
; 1335 : 		_Insert_n(_Unchecked_begin(), _Count, _Val);
; 1336 : 		}
; 1337 : 
; 1338 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1339 : 		{	// insert _Val at _Where
; 1340 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1341 : 		if (_Where._Getcont() != this)
; 1342 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1343 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1344 : 
; 1345 : 		_Insert(_Where._Unchecked(), _Val);
; 1346 : 		return (_Make_iter(--_Where));
; 1347 : 		}
; 1348 : 
; 1349 : 	iterator insert(const_iterator _Where, size_type _Count, const _Ty& _Val)
; 1350 : 		{	// insert _Count * _Val at _Where
; 1351 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1352 : 		if (_Where._Getcont() != this)
; 1353 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1354 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1355 : 
; 1356 : 		iterator _Prev = _Make_iter(_Where);
; 1357 : 		if (_Prev == begin())
; 1358 : 			{	// insert sequence at beginning
; 1359 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1360 : 			return (begin());
; 1361 : 			}
; 1362 : 		else
; 1363 : 			{	// insert sequence not at beginning
; 1364 : 			--_Prev;
; 1365 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1366 : 			return (++_Prev);
; 1367 : 			}
; 1368 : 		}
; 1369 : 
; 1370 : 	template<class _Iter>
; 1371 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1372 : 			iterator>::type
; 1373 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1374 : 		{	// insert [_First, _Last) at _Where
; 1375 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1376 : 		if (_Where._Getcont() != this)
; 1377 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1378 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1379 : 
; 1380 : 		iterator _Prev = _Make_iter(_Where);
; 1381 : 		if (_Prev == begin())
; 1382 : 			{	// insert sequence at beginning
; 1383 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1384 : 				_Iter_cat(_First));
; 1385 : 			return (begin());
; 1386 : 			}
; 1387 : 		else
; 1388 : 			{	// insert sequence not at beginning
; 1389 : 			--_Prev;
; 1390 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1391 : 				_Iter_cat(_First));
; 1392 : 			return (++_Prev);
; 1393 : 			}
; 1394 : 		}
; 1395 : 
; 1396 : 	template<class _Iter>
; 1397 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1398 : 			_Iter _First, _Iter _Last, input_iterator_tag)
; 1399 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1400 : 		size_type _Num = 0;
; 1401 : 
; 1402 : 		_TRY_BEGIN
; 1403 : 		for (; _First != _Last; ++_First, ++_Num)
; 1404 : 			_Insert(_Where, *_First);
; 1405 : 		_CATCH_ALL
; 1406 : 		for (; 0 < _Num; --_Num)
; 1407 : 			{	// undo inserts
; 1408 : 			_Unchecked_const_iterator _Before = _Where;
; 1409 : 			_Unchecked_erase(--_Before);
; 1410 : 			}
; 1411 : 		_RERAISE;
; 1412 : 		_CATCH_END
; 1413 : 		}
; 1414 : 
; 1415 : 	template<class _Iter>
; 1416 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1417 : 			_Iter _First, _Iter _Last, forward_iterator_tag)
; 1418 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1419 : 		_DEBUG_RANGE(_First, _Last);
; 1420 : 		_Iter _Next = _First;
; 1421 : 
; 1422 : 		_TRY_BEGIN
; 1423 : 		for (; _First != _Last; ++_First)
; 1424 : 			_Insert(_Where, *_First);
; 1425 : 		_CATCH_ALL
; 1426 : 		for (; _Next != _First; ++_Next)
; 1427 : 			{	// undo inserts
; 1428 : 			_Unchecked_const_iterator _Before = _Where;
; 1429 : 			_Unchecked_erase(--_Before);
; 1430 : 			}
; 1431 : 		_RERAISE;
; 1432 : 		_CATCH_END
; 1433 : 		}
; 1434 : 
; 1435 : 	_Nodeptr _Unlinknode(const_iterator _Where)
; 1436 : 		{	// unlink node at _Where from the list
; 1437 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1438 : 		if (_Where._Getcont() != this || _Where._Ptr == this->_Myhead)
; 1439 : 			_DEBUG_ERROR("list erase iterator outside range");
; 1440 : 		_Nodeptr _Pnode = (_Where)._Mynode();
; 1441 : 		_Orphan_ptr(*this, _Pnode);
; 1442 : 
; 1443 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1444 : 		_Nodeptr _Pnode = (_Where)._Mynode();
; 1445 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1446 : 
; 1447 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1448 : 			this->_Nextnode(_Pnode);
; 1449 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1450 : 			this->_Prevnode(_Pnode);
; 1451 : 
; 1452 : 		--this->_Mysize;
; 1453 : 		return (_Pnode);
; 1454 : 		}
; 1455 : 
; 1456 : 	iterator erase(const_iterator _Where)
; 1457 : 		{	// erase element at _Where
; 1458 : 		_Nodeptr _Pnode = _Unlinknode(_Where++);
; 1459 : 		this->_Freenode(_Pnode);
; 1460 : 		return (_Make_iter(_Where));
; 1461 : 		}
; 1462 : 
; 1463 : 	void _Unchecked_erase(_Unchecked_const_iterator _Where)
; 1464 : 		{	// erase element at _Where
; 1465 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1466 : 
; 1467 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1468 : 			this->_Nextnode(_Pnode);
; 1469 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1470 : 			this->_Prevnode(_Pnode);
; 1471 : 		this->_Freenode(_Pnode);
; 1472 : 		--this->_Mysize;
; 1473 : 		}
; 1474 : 
; 1475 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1476 : 		{	// erase [_First, _Last)
; 1477 : 		if (_First == begin() && _Last == end())
; 1478 : 			{	// erase all and return fresh iterator
; 1479 : 			clear();
; 1480 : 			return (end());
; 1481 : 			}
; 1482 : 		else
; 1483 : 			{	// erase subrange
; 1484 : 			while (_First != _Last)
; 1485 : 				_First = erase(_First);
; 1486 : 			return (_Make_iter(_Last));
; 1487 : 			}
; 1488 : 		}
; 1489 : 
; 1490 : 	void clear() _NOEXCEPT
; 1491 : 		{	// erase all
; 1492 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1493 : 		this->_Orphan_ptr(*this, nullptr);
; 1494 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1495 : 
; 1496 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead);
; 1497 : 		this->_Nextnode(this->_Myhead) = this->_Myhead;
; 1498 : 		this->_Prevnode(this->_Myhead) = this->_Myhead;
; 1499 : 		this->_Mysize = 0;
; 1500 : 
; 1501 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead; _Pnode = _Pnext)
; 1502 : 			{	// delete an element
; 1503 : 			_Pnext = this->_Nextnode(_Pnode);
; 1504 : 			this->_Freenode(_Pnode);
; 1505 : 			}
; 1506 : 		}
; 1507 : 
; 1508 : 	void swap(_Myt& _Right)
; 1509 : 		{	// exchange contents with _Right
; 1510 : 		if (this == &_Right)
; 1511 : 			;	// same object, do nothing
; 1512 : 		else if (this->_Getal() == _Right._Getal())
; 1513 : 			{	// same allocator, swap control information
; 1514 : 			this->_Swap_all(_Right);
; 1515 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1516 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1517 : 			}
; 1518 : 
; 1519 : 		else if (_Alty::propagate_on_container_swap::value)
; 1520 : 			{	// swap allocators and control information
; 1521 : 			this->_Swap_alloc(_Right);
; 1522 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1523 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1524 : 			}
; 1525 : 
; 1526 : 		else	// containers are incompatible
; 1527 : 
; 1528 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1529 : 			_DEBUG_ERROR("list containers incompatible for swap");
; 1530 : 
; 1531 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1532 : 			_XSTD terminate();
; 1533 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1534 : 		}
; 1535 : 
; 1536 : 	void splice(const_iterator _Where, _Myt& _Right)
; 1537 : 		{	// splice all of _Right at _Where
; 1538 : 		if (this != &_Right && !_Right.empty())
; 1539 : 			{	// worth splicing, do it
; 1540 : 			_Splice(_Where, _Right, _Right.begin(), _Right.end(),
; 1541 : 				_Right._Mysize);
; 1542 : 			}
; 1543 : 		}
; 1544 : 
; 1545 : 	void splice(const_iterator _Where, _Myt&& _Right)
; 1546 : 		{	// splice all of _Right at _Where
; 1547 : 		splice(_Where, (_Myt&)_Right);
; 1548 : 		}
; 1549 : 
; 1550 : 	void splice(const_iterator _Where, _Myt& _Right,
; 1551 : 		const_iterator _First)
; 1552 : 		{	// splice _Right [_First, _First + 1) at _Where
; 1553 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1554 : 		if (_First == _Right.end())
; 1555 : 			_DEBUG_ERROR("list splice iterator outside range");
; 1556 : 		else
; 1557 : 
; 1558 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1559 : 		if (_First != _Right.end())
; 1560 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1561 : 
; 1562 : 			{	// element exists, try splice
; 1563 : 			const_iterator _Last = _First;
; 1564 : 			++_Last;
; 1565 : 			if (this != &_Right
; 1566 : 				|| (_Where != _First && _Where != _Last))
; 1567 : 				_Splice(_Where, _Right, _First, _Last, 1);
; 1568 : 			}
; 1569 : 		}
; 1570 : 
; 1571 : 	void splice(const_iterator _Where, _Myt&& _Right,
; 1572 : 		const_iterator _First)
; 1573 : 		{	// splice _Right [_First, _First + 1) at _Where
; 1574 : 		splice(_Where, (_Myt&)_Right, _First);
; 1575 : 		}
; 1576 : 
; 1577 : 	void splice(const_iterator _Where,
; 1578 : 		_Myt& _Right, const_iterator _First, const_iterator _Last)
; 1579 : 		{	// splice _Right [_First, _Last) at _Where
; 1580 : 		if (_First != _Last && (this != &_Right || _Where != _Last))
; 1581 : 			{	// worth splicing, do it
; 1582 : 			size_type _Count = 0;
; 1583 : 
; 1584 : 			if (this == &_Right)
; 1585 : 				;	// just rearrange this list
; 1586 : 			else if (_First == _Right.begin() && _Last == _Right.end())
; 1587 : 				_Count = _Right._Mysize;	// splice in whole list
; 1588 : 			else
; 1589 : 				{	// count nodes and check for knot
; 1590 : 				const_iterator _Next = _First;
; 1591 : 
; 1592 : 				for (; _Next != _Last; ++_Next, ++_Count)
; 1593 : 					if (_Next == _Right.end())
; 1594 : 						_Xlength_error("list<T> bad splice");
; 1595 : 				}
; 1596 : 			_Splice(_Where, _Right, _First, _Last, _Count);
; 1597 : 			}
; 1598 : 		}
; 1599 : 
; 1600 : 	void splice(const_iterator _Where,
; 1601 : 		_Myt&& _Right, const_iterator _First, const_iterator _Last)
; 1602 : 		{	// splice _Right [_First, _Last) at _Where
; 1603 : 		splice(_Where, (_Myt&)_Right, _First, _Last);
; 1604 : 		}
; 1605 : 
; 1606 : 	void remove(const _Ty& _Val)
; 1607 : 		{	// erase each element matching _Val
; 1608 : 		iterator _Val_it = end();
; 1609 : 
; 1610 : 		for (iterator _First = begin(); _First != end(); )
; 1611 : 			if (*_First == _Val)
; 1612 : 				if (_STD addressof(*_First) == _STD addressof(_Val))
; 1613 : 					_Val_it = _First++;
; 1614 : 				else
; 1615 : 					_First = erase(_First);
; 1616 : 			else
; 1617 : 				++_First;
; 1618 : 
; 1619 : 		if (_Val_it != end())
; 1620 : 			erase(_Val_it);
; 1621 : 		}
; 1622 : 
; 1623 : 	template<class _Pr1>
; 1624 : 		void remove_if(_Pr1 _Pred)
; 1625 : 		{	// erase each element satisfying _Pred
; 1626 : 		for (iterator _First = begin(); _First != end(); )
; 1627 : 			if (_Pred(*_First))
; 1628 : 				_First = erase(_First);
; 1629 : 			else
; 1630 : 				++_First;
; 1631 : 		}
; 1632 : 
; 1633 : 	void unique()
; 1634 : 		{	// erase each element matching previous
; 1635 : 		unique(equal_to<>());
; 1636 : 		}
; 1637 : 
; 1638 : 	template<class _Pr2>
; 1639 : 		void unique(_Pr2 _Pred)
; 1640 : 		{	// erase each element satisfying _Pred with previous
; 1641 : 		const _Nodeptr _Phead = this->_Myhead;
; 1642 : 		_Nodeptr _Pprev = this->_Nextnode(_Phead);
; 1643 : 		_Nodeptr _Pnode = this->_Nextnode(_Pprev);
; 1644 : 
; 1645 : 		while (_Pnode != _Phead)
; 1646 : 			if (_Pred(_Pprev->_Myval, _Pnode->_Myval))
; 1647 : 				{	// match, remove it
; 1648 : 				const _Nodeptr _Perase = _Pnode;
; 1649 : 				_Pnode = this->_Nextnode(_Pnode);
; 1650 : 
; 1651 : 				this->_Nextnode(_Pprev) = _Pnode;
; 1652 : 				this->_Prevnode(_Pnode) = _Pprev;
; 1653 : 				this->_Freenode(_Perase);
; 1654 : 
; 1655 : 				--this->_Mysize;
; 1656 : 				}
; 1657 : 			else
; 1658 : 				{	// no match, advance
; 1659 : 				_Pprev = _Pnode;
; 1660 : 				_Pnode = this->_Nextnode(_Pnode);
; 1661 : 				}
; 1662 : 		}
; 1663 : 
; 1664 : 	void merge(_Myt& _Right)
; 1665 : 		{	// merge in elements from _Right, both ordered by operator<
; 1666 : 		merge(_Right, less<>());
; 1667 : 		}
; 1668 : 
; 1669 : 	void merge(_Myt&& _Right)
; 1670 : 		{	// merge in elements from _Right, both ordered by operator<
; 1671 : 		merge((_Myt&)_Right);
; 1672 : 		}
; 1673 : 
; 1674 : 	template<class _Pr2>
; 1675 : 		void merge(_Myt& _Right, _Pr2 _Pred)
; 1676 : 		{	// merge in elements from _Right, both ordered by _Pred
; 1677 : 		if (&_Right != this)
; 1678 : 			{	// safe to merge, do it
; 1679 : 			iterator _First1 = begin(), _Last1 = end();
; 1680 : 			iterator _First2 = _Right.begin(), _Last2 = _Right.end();
; 1681 : 			_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 1682 : 			_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 1683 : 
; 1684 : 			while (_First1 != _Last1 && _First2 != _Last2)
; 1685 : 				if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))
; 1686 : 					{	// splice in an element from _Right
; 1687 : 					iterator _Mid2 = _First2;
; 1688 : 					_Splice(_First1, _Right, _First2, ++_Mid2, 1);
; 1689 : 					_First2 = _Mid2;
; 1690 : 					}
; 1691 : 				else
; 1692 : 					++_First1;
; 1693 : 
; 1694 : 			if (_First2 != _Last2)
; 1695 : 				_Splice(_Last1, _Right, _First2, _Last2,
; 1696 : 					_Right._Mysize);	// splice remainder of _Right
; 1697 : 			}
; 1698 : 		}
; 1699 : 
; 1700 : 	template<class _Pr2>
; 1701 : 		void merge(_Myt&& _Right, _Pr2 _Pred)
; 1702 : 		{	// merge in elements from _Right, both ordered by _Pred
; 1703 : 		merge((_Myt&)_Right, _Pred);
; 1704 : 		}
; 1705 : 
; 1706 : 	void sort()
; 1707 : 		{	// order sequence, using operator<
; 1708 : 		sort(less<>());
; 1709 : 		}
; 1710 : 
; 1711 : 	template<class _Pr2>
; 1712 : 		void sort(_Pr2 _Pred)
; 1713 : 		{	// order sequence, using _Pred
; 1714 : 		if (2 <= this->_Mysize)
; 1715 : 			{	// worth sorting, do it
; 1716 : 			const size_t _MAXBINS = 25;
; 1717 : 			_Myt _Templist(this->_Getal()), _Binlist[_MAXBINS + 1];
; 1718 : 			size_t _Maxbin = 0;
; 1719 : 
; 1720 : 			while (!empty())
; 1721 : 				{	// sort another element, using bins
; 1722 : 				_Templist._Splice_same(_Templist.begin(), *this, begin(),
; 1723 : 					++begin(), 1);
; 1724 : 
; 1725 : 				size_t _Bin;
; 1726 : 				for (_Bin = 0; _Bin < _Maxbin && !_Binlist[_Bin].empty();
; 1727 : 					++_Bin)
; 1728 : 					{	// merge into ever larger bins
; 1729 : 					_Binlist[_Bin].merge(_Templist, _Pred);
; 1730 : 					_Binlist[_Bin].swap(_Templist);
; 1731 : 					}
; 1732 : 
; 1733 : 				if (_Bin == _MAXBINS)
; 1734 : 					_Binlist[_Bin - 1].merge(_Templist, _Pred);
; 1735 : 				else
; 1736 : 					{	// spill to new bin, while they last
; 1737 : 					_Binlist[_Bin].swap(_Templist);
; 1738 : 					if (_Bin == _Maxbin)
; 1739 : 						++_Maxbin;
; 1740 : 					}
; 1741 : 				}
; 1742 : 
; 1743 : 			for (size_t _Bin = 1; _Bin < _Maxbin; ++_Bin)
; 1744 : 				_Binlist[_Bin].merge(_Binlist[_Bin - 1],
; 1745 : 					_Pred);	// merge up
; 1746 : 
; 1747 : 			_Analysis_assume_(0 < _Maxbin);
; 1748 : 
; 1749 : 			splice(begin(), _Binlist[_Maxbin - 1]);	// result in last bin
; 1750 : 			}
; 1751 : 		}
; 1752 : 
; 1753 : 	void reverse() _NOEXCEPT
; 1754 : 		{	// reverse sequence
; 1755 : 		const _Nodeptr _Phead = this->_Myhead;
; 1756 : 		_Nodeptr _Pnode = _Phead;
; 1757 : 
; 1758 : 		for (; ; )
; 1759 : 			{	// flip pointers in a node
; 1760 : 			const _Nodeptr _Pnext = this->_Nextnode(_Pnode);
; 1761 : 			this->_Nextnode(_Pnode) = this->_Prevnode(_Pnode);
; 1762 : 			this->_Prevnode(_Pnode) = _Pnext;
; 1763 : 
; 1764 : 			if (_Pnext == _Phead)
; 1765 : 				break;
; 1766 : 			_Pnode = _Pnext;
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	void _Splice(const_iterator _Where,
; 1771 : 		_Myt& _Right, const_iterator _First, const_iterator _Last,
; 1772 : 		size_type _Count)
; 1773 : 		{	// splice _Right [_First, _Last) before _Where
; 1774 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1775 : 		if (_Where._Getcont() != this)
; 1776 : 			_DEBUG_ERROR("list splice iterator outside range");
; 1777 : 		if (this->_Getal() != _Right._Getal())
; 1778 : 			_DEBUG_ERROR("list containers incompatible for splice");
; 1779 : 
; 1780 : 		if (this != &_Right)
; 1781 : 			{	// transfer ownership
; 1782 : 			_Lockit _Lock(_LOCK_DEBUG);
; 1783 : 
; 1784 : 			const bool _One = _Count == 1;
; 1785 : 			const bool _All = _Count == _Right.size();
; 1786 : 			const bool _Some = !_One && !_All;
; 1787 : 
; 1788 : 			_Nodeptr _Oldprev = _First._Ptr->_Prev;
; 1789 : 
; 1790 : 			if (_Some)
; 1791 : 				for (_Nodeptr _Ptr = _First._Ptr; _Ptr != _Last._Ptr;
; 1792 : 					_Ptr = _Ptr->_Next)
; 1793 : 					{	// mark _Prev pointers
; 1794 : 					_Ptr->_Prev = 0;
; 1795 : 					}
; 1796 : 
; 1797 : 			const_iterator **_Pnext = (const_iterator **)_Right._Getpfirst();
; 1798 : 
; 1799 : 			if (_Pnext == 0)
; 1800 : 				_DEBUG_ERROR("list container corrupted");
; 1801 : 
; 1802 : 			while (*_Pnext != 0)
; 1803 : 				{	// check the iterator
; 1804 : 				const_iterator& _Iter = **_Pnext;
; 1805 : 
; 1806 : 				if ((_One && _Iter._Ptr == _First._Ptr)
; 1807 : 					|| (_All && _Iter._Ptr != _Right._Myhead)
; 1808 : 					|| (_Some && _Iter._Ptr->_Prev == 0))
; 1809 : 					{	// adopt the iterator
; 1810 : 					*_Pnext = (const_iterator *)_Iter._Mynextiter;
; 1811 : 					_Iter._Myproxy = this->_Myproxy;
; 1812 : 					_Iter._Mynextiter = this->_Myproxy->_Myfirstiter;
; 1813 : 					this->_Myproxy->_Myfirstiter = &_Iter;
; 1814 : 					}
; 1815 : 				else
; 1816 : 					{	// skip the iterator
; 1817 : 					_Pnext = (const_iterator **)_Iter._Getpnext();
; 1818 : 					}
; 1819 : 				}
; 1820 : 
; 1821 : 			if (_Some)
; 1822 : 				for (_Nodeptr _Ptr = _First._Ptr; _Ptr != _Last._Ptr;
; 1823 : 					_Ptr = _Ptr->_Next)
; 1824 : 					{	// restore _Prev pointers
; 1825 : 					_Ptr->_Prev = _Oldprev;
; 1826 : 					_Oldprev = _Ptr;
; 1827 : 					}
; 1828 : 			}
; 1829 : 
; 1830 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1831 : 		if (this->_Getal() != _Right._Getal())
; 1832 : 			_XSTD terminate();
; 1833 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1834 : 
; 1835 : 		_Splice_same(_Where, _Right, _First, _Last, _Count);
; 1836 : 		}
; 1837 : 
; 1838 : 	void _Splice_same(const_iterator _Where,
; 1839 : 		_Myt& _Right, const_iterator _First, const_iterator _Last,
; 1840 : 		size_type _Count)
; 1841 : 		{	// splice _Right [_First, _Last) before _Where
; 1842 : 		if (this != &_Right)
; 1843 : 			{	// splicing from another list, adjust counts
; 1844 : 			_Incsize(_Count);
; 1845 : 			_Right._Mysize -= _Count;
; 1846 : 			}
; 1847 : 		this->_Nextnode(this->_Prevnode(_First._Mynode())) =
; 1848 : 			_Last._Mynode();
; 1849 : 		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
; 1850 : 			_Where._Mynode();
; 1851 : 		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
; 1852 : 			_First._Mynode();
; 1853 : 
; 1854 : 		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
; 1855 : 		this->_Prevnode(_Where._Mynode()) =
; 1856 : 			this->_Prevnode(_Last._Mynode());
; 1857 : 		this->_Prevnode(_Last._Mynode()) =
; 1858 : 			this->_Prevnode(_First._Mynode());
; 1859 : 		this->_Prevnode(_First._Mynode()) = _Pnode;
; 1860 : 		}
; 1861 : 
; 1862 : 	void _Unchecked_splice(_Unchecked_const_iterator _Where,
; 1863 : 		_Unchecked_const_iterator _First,
; 1864 : 		_Unchecked_const_iterator _Last)
; 1865 : 		{	// splice [_First, _Last) before _Where
; 1866 : 		this->_Nextnode(this->_Prevnode(_First._Mynode())) =
; 1867 : 			_Last._Mynode();
; 1868 : 		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
; 1869 : 			_Where._Mynode();
; 1870 : 		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
; 1871 : 			_First._Mynode();
; 1872 : 
; 1873 : 		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
; 1874 : 		this->_Prevnode(_Where._Mynode()) =
; 1875 : 			this->_Prevnode(_Last._Mynode());
; 1876 : 		this->_Prevnode(_Last._Mynode()) =
; 1877 : 			this->_Prevnode(_First._Mynode());
; 1878 : 		this->_Prevnode(_First._Mynode()) = _Pnode;
; 1879 : 		}
; 1880 : 
; 1881 : 	void _Tidy()
; 1882 : 		{	// free all storage
; 1883 : 		clear();
; 1884 : 		}
; 1885 : 
; 1886 : 	void _Insert_n(_Unchecked_const_iterator _Where,
; 1887 : 		size_type _Count, const _Ty& _Val)
; 1888 : 		{	// insert _Count * _Val at _Where
; 1889 : 		size_type _Countsave = _Count;
; 1890 : 
; 1891 : 		_TRY_BEGIN
; 1892 : 		for (; 0 < _Count; --_Count)
; 1893 : 			_Insert(_Where, _Val);
; 1894 : 		_CATCH_ALL
; 1895 : 		for (; _Count < _Countsave; ++_Count)
; 1896 : 			{	// undo inserts
; 1897 : 			_Unchecked_const_iterator _Before = _Where;
; 1898 : 			_Unchecked_erase(--_Before);
; 1899 : 			}
; 1900 : 		_RERAISE;
; 1901 : 		_CATCH_END
; 1902 : 		}
; 1903 : 
; 1904 : 	void _Incsize(size_type _Count)
; 1905 : 		{	// alter element count, with checking
; 1906 : 		if (max_size() - this->_Mysize - 1 < _Count)

  00017	b9 fe ff ff 07	 mov	 ecx, 134217726		; 07fffffeH
  0001c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001f	2b c8		 sub	 ecx, eax
  00021	83 f9 01	 cmp	 ecx, 1
  00024	72 12		 jb	 SHORT $LN41@push_back

; 1908 : 		this->_Mysize += _Count;

  00026	40		 inc	 eax
  00027	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1063 : 		_Incsize(1);
; 1064 : 		this->_Prevnode(_Pnode) = _Newnode;

  0002a	89 57 04	 mov	 DWORD PTR [edi+4], edx

; 97   : 		}
; 98   : 
; 99   : 	_Nodeptr _Ptr;	// pointer to node
; 100  : 	};
; 101  : 
; 102  : 	// TEMPLATE CLASS _List_unchecked_iterator
; 103  : template<class _Mylist>
; 104  : 	class _List_unchecked_iterator
; 105  : 		: public _List_unchecked_const_iterator<_Mylist>
; 106  : 	{	// unchecked iterator for mutable list
; 107  : public:
; 108  : 	typedef _List_unchecked_iterator<_Mylist> _Myiter;
; 109  : 	typedef _List_unchecked_const_iterator<_Mylist> _Mybase;
; 110  : 	typedef bidirectional_iterator_tag iterator_category;
; 111  : 
; 112  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 113  : 	typedef typename _Mylist::value_type value_type;
; 114  : 	typedef typename _Mylist::difference_type difference_type;
; 115  : 	typedef typename _Mylist::pointer pointer;
; 116  : 	typedef typename _Mylist::reference reference;
; 117  : 
; 118  : 	_List_unchecked_iterator()
; 119  : 		{	// construct with null node
; 120  : 		}
; 121  : 
; 122  : 	_List_unchecked_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 123  : 		: _Mybase(_Pnode, _Plist)
; 124  : 		{	// construct with node pointer _Pnode
; 125  : 		}
; 126  : 
; 127  : 	reference operator*() const
; 128  : 		{	// return designated value
; 129  : 		return ((reference)**(_Mybase *)this);
; 130  : 		}
; 131  : 
; 132  : 	pointer operator->() const
; 133  : 		{	// return pointer to class object
; 134  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 135  : 		}
; 136  : 
; 137  : 	_Myiter& operator++()
; 138  : 		{	// preincrement
; 139  : 		++(*(_Mybase *)this);
; 140  : 		return (*this);
; 141  : 		}
; 142  : 
; 143  : 	_Myiter operator++(int)
; 144  : 		{	// postincrement
; 145  : 		_Myiter _Tmp = *this;
; 146  : 		++*this;
; 147  : 		return (_Tmp);
; 148  : 		}
; 149  : 
; 150  : 	_Myiter& operator--()
; 151  : 		{	// predecrement
; 152  : 		--(*(_Mybase *)this);
; 153  : 		return (*this);
; 154  : 		}
; 155  : 
; 156  : 	_Myiter operator--(int)
; 157  : 		{	// postdecrement
; 158  : 		_Myiter _Tmp = *this;
; 159  : 		--*this;
; 160  : 		return (_Tmp);
; 161  : 		}
; 162  : 	};
; 163  : 
; 164  : 	// TEMPLATE CLASS _List_const_iterator
; 165  : template<class _Mylist>
; 166  : 	class _List_const_iterator
; 167  : 		: public _List_unchecked_const_iterator<_Mylist, _Iterator_base>
; 168  : 	{	// iterator for nonmutable list
; 169  : public:
; 170  : 	typedef _List_const_iterator<_Mylist> _Myiter;
; 171  : 	typedef _List_unchecked_const_iterator<_Mylist, _Iterator_base> _Mybase;
; 172  : 	typedef bidirectional_iterator_tag iterator_category;
; 173  : 
; 174  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 175  : 	typedef typename _Mylist::value_type value_type;
; 176  : 	typedef typename _Mylist::difference_type difference_type;
; 177  : 	typedef typename _Mylist::const_pointer pointer;
; 178  : 	typedef typename _Mylist::const_reference reference;
; 179  : 
; 180  : 	_List_const_iterator()
; 181  : 		: _Mybase()
; 182  : 		{	// construct with null node pointer
; 183  : 		}
; 184  : 
; 185  : 	_List_const_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 186  : 		: _Mybase(_Pnode, _Plist)
; 187  : 		{	// construct with node pointer _Pnode
; 188  : 		}
; 189  : 
; 190  : 	typedef _List_unchecked_const_iterator<_Mylist> _Unchecked_type;
; 191  : 
; 192  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 193  : 		{	// reset from unchecked iterator
; 194  : 		this->_Ptr = _Right._Ptr;
; 195  : 		return (*this);
; 196  : 		}
; 197  : 
; 198  : 	_Unchecked_type _Unchecked() const
; 199  : 		{	// make an unchecked iterator
; 200  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 201  : 		}
; 202  : 
; 203  : 	reference operator*() const
; 204  : 		{	// return designated value
; 205  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 206  : 		if (this->_Getcont() == 0
; 207  : 			|| this->_Ptr == 0
; 208  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 209  : 			{	// report error
; 210  : 			_DEBUG_ERROR("list iterator not dereferencable");
; 211  : 			_SCL_SECURE_OUT_OF_RANGE;
; 212  : 			}
; 213  : 
; 214  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 215  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 216  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 217  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 218  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 219  : 
; 220  : 		return (_Mylist::_Myval(this->_Ptr));
; 221  : 		}
; 222  : 
; 223  : 	_Myiter& operator++()
; 224  : 		{	// preincrement
; 225  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 226  : 		if (this->_Getcont() == 0
; 227  : 			|| this->_Ptr == 0
; 228  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 229  : 			{	// report error
; 230  : 			_DEBUG_ERROR("list iterator not incrementable");
; 231  : 			_SCL_SECURE_OUT_OF_RANGE;
; 232  : 			}
; 233  : 
; 234  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 235  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 236  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 237  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 238  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 239  : 
; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);
; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);
; 299  : 		}
; 300  : 
; 301  : 	bool operator!=(const _Myiter& _Right) const
; 302  : 		{	// test for iterator inequality
; 303  : 		return (!(*this == _Right));
; 304  : 		}
; 305  : 	};
; 306  : 
; 307  : template<class _Mylist> inline
; 308  : 	typename _List_const_iterator<_Mylist>::_Unchecked_type
; 309  : 		_Unchecked(_List_const_iterator<_Mylist> _Iter)
; 310  : 	{	// convert to unchecked
; 311  : 	return (_Iter._Unchecked());
; 312  : 	}
; 313  : 
; 314  : template<class _Mylist> inline
; 315  : 	_List_const_iterator<_Mylist>&
; 316  : 		_Rechecked(_List_const_iterator<_Mylist>& _Iter,
; 317  : 			typename _List_const_iterator<_Mylist>
; 318  : 				::_Unchecked_type _Right)
; 319  : 	{	// convert to checked
; 320  : 	return (_Iter._Rechecked(_Right));
; 321  : 	}
; 322  : 
; 323  : 	// TEMPLATE CLASS _List_iterator
; 324  : template<class _Mylist>
; 325  : 	class _List_iterator
; 326  : 		: public _List_const_iterator<_Mylist>
; 327  : 	{	// iterator for mutable list
; 328  : public:
; 329  : 	typedef _List_iterator<_Mylist> _Myiter;
; 330  : 	typedef _List_const_iterator<_Mylist> _Mybase;
; 331  : 	typedef bidirectional_iterator_tag iterator_category;
; 332  : 
; 333  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 334  : 	typedef typename _Mylist::value_type value_type;
; 335  : 	typedef typename _Mylist::difference_type difference_type;
; 336  : 	typedef typename _Mylist::pointer pointer;
; 337  : 	typedef typename _Mylist::reference reference;
; 338  : 
; 339  : 	_List_iterator()
; 340  : 		{	// construct with null node
; 341  : 		}
; 342  : 
; 343  : 	_List_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 344  : 		: _Mybase(_Pnode, _Plist)
; 345  : 		{	// construct with node pointer _Pnode
; 346  : 		}
; 347  : 
; 348  : 	typedef _List_unchecked_iterator<_Mylist> _Unchecked_type;
; 349  : 
; 350  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 351  : 		{	// reset from unchecked iterator
; 352  : 		this->_Ptr = _Right._Ptr;
; 353  : 		return (*this);
; 354  : 		}
; 355  : 
; 356  : 	_Unchecked_type _Unchecked() const
; 357  : 		{	// make an unchecked iterator
; 358  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 359  : 		}
; 360  : 
; 361  : 	reference operator*() const
; 362  : 		{	// return designated value
; 363  : 		return ((reference)**(_Mybase *)this);
; 364  : 		}
; 365  : 
; 366  : 	pointer operator->() const
; 367  : 		{	// return pointer to class object
; 368  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 369  : 		}
; 370  : 
; 371  : 	_Myiter& operator++()
; 372  : 		{	// preincrement
; 373  : 		++(*(_Mybase *)this);
; 374  : 		return (*this);
; 375  : 		}
; 376  : 
; 377  : 	_Myiter operator++(int)
; 378  : 		{	// postincrement
; 379  : 		_Myiter _Tmp = *this;
; 380  : 		++*this;
; 381  : 		return (_Tmp);
; 382  : 		}
; 383  : 
; 384  : 	_Myiter& operator--()
; 385  : 		{	// predecrement
; 386  : 		--(*(_Mybase *)this);
; 387  : 		return (*this);
; 388  : 		}
; 389  : 
; 390  : 	_Myiter operator--(int)
; 391  : 		{	// postdecrement
; 392  : 		_Myiter _Tmp = *this;
; 393  : 		--*this;
; 394  : 		return (_Tmp);
; 395  : 		}
; 396  : 	};
; 397  : 
; 398  : template<class _Mylist> inline
; 399  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 400  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 401  : 	{	// convert to unchecked
; 402  : 	return (_Iter._Unchecked());
; 403  : 	}
; 404  : 
; 405  : template<class _Mylist> inline
; 406  : 	_List_iterator<_Mylist>&
; 407  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 408  : 			typename _List_iterator<_Mylist>
; 409  : 				::_Unchecked_type _Right)
; 410  : 	{	// convert to checked
; 411  : 	return (_Iter._Rechecked(_Right));
; 412  : 	}
; 413  : 
; 414  : 		// list TYPE WRAPPERS
; 415  : template<class _Value_type,
; 416  : 	class _Size_type,
; 417  : 	class _Difference_type,
; 418  : 	class _Pointer,
; 419  : 	class _Const_pointer,
; 420  : 	class _Reference,
; 421  : 	class _Const_reference,
; 422  : 	class _Nodeptr_type>
; 423  : 	struct _List_iter_types
; 424  : 	{	// wraps types needed by iterators
; 425  : 	typedef _Value_type value_type;
; 426  : 	typedef _Size_type size_type;
; 427  : 	typedef _Difference_type difference_type;
; 428  : 	typedef _Pointer pointer;
; 429  : 	typedef _Const_pointer const_pointer;
; 430  : 	typedef _Reference reference;
; 431  : 	typedef _Const_reference const_reference;
; 432  : 	typedef _Nodeptr_type _Nodeptr;
; 433  : 	};
; 434  : 
; 435  : template<class _Value_type,
; 436  : 	class _Voidptr>
; 437  : 	struct _List_node
; 438  : 		{	// list node
; 439  : 		_Voidptr _Next;	// successor node, or first element if head
; 440  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 441  : 		_Value_type _Myval;	// the stored value, unused if head
; 442  : 
; 443  : 	private:
; 444  : 		_List_node& operator=(const _List_node&);
; 445  : 		};
; 446  : 
; 447  : template<class _Value_type>
; 448  : 	struct _List_node<_Value_type, void *>
; 449  : 		{	// list node
; 450  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 451  : 		_Nodeptr _Next;	// successor node, or first element if head
; 452  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 453  : 		_Value_type _Myval;	// the stored value, unused if head
; 454  : 
; 455  : 	private:
; 456  : 		_List_node& operator=(const _List_node&);
; 457  : 		};
; 458  : 
; 459  : template<class _Ty>
; 460  : 	struct _List_simple_types
; 461  : 		: public _Simple_types<_Ty>
; 462  : 	{	// wraps types needed by iterators
; 463  : 	typedef _List_node<_Ty, void *> _Node;
; 464  : 	typedef _Node *_Nodeptr;
; 465  : 	};
; 466  : 
; 467  : template<class _Ty,
; 468  : 	class _Alloc0>
; 469  : 	struct _List_base_types
; 470  : 	{	// types needed for a container base
; 471  : 	typedef _Alloc0 _Alloc;
; 472  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 473  : 
; 474  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 475  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 476  : 
; 477  : 
; 478  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 479  : 		_Voidptr;
; 480  : 	typedef _List_node<typename _Alty::value_type,
; 481  : 		_Voidptr> _Node;
; 482  : 
; 483  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 484  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 485  : 	typedef _Nodeptr& _Nodepref;
; 486  : 
; 487  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 488  : 		_List_simple_types<typename _Alty::value_type>,
; 489  : 		_List_iter_types<typename _Alty::value_type,
; 490  : 			typename _Alty::size_type,
; 491  : 			typename _Alty::difference_type,
; 492  : 			typename _Alty::pointer,
; 493  : 			typename _Alty::const_pointer,
; 494  : 			typename _Alty::reference,
; 495  : 			typename _Alty::const_reference,
; 496  : 			_Nodeptr> >::type
; 497  : 		_Val_types;
; 498  : 	};
; 499  : 
; 500  : 		// TEMPLATE CLASS _List_val
; 501  : template<class _Val_types>
; 502  : 	class _List_val
; 503  : 		: public _Container_base
; 504  : 	{	// base class for list to hold data
; 505  : public:
; 506  : 	typedef _List_val<_Val_types> _Myt;
; 507  : 
; 508  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 509  : 	typedef _Nodeptr& _Nodepref;
; 510  : 
; 511  : 	typedef typename _Val_types::value_type value_type;
; 512  : 	typedef typename _Val_types::size_type size_type;
; 513  : 	typedef typename _Val_types::difference_type difference_type;
; 514  : 	typedef typename _Val_types::pointer pointer;
; 515  : 	typedef typename _Val_types::const_pointer const_pointer;
; 516  : 	typedef typename _Val_types::reference reference;
; 517  : 	typedef typename _Val_types::const_reference const_reference;
; 518  : 
; 519  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 520  : 	typedef _List_iterator<_Myt> iterator;
; 521  : 
; 522  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 523  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 524  : 
; 525  : 	_List_val()
; 526  : 		{	// initialize data
; 527  : 		this->_Myhead = 0;
; 528  : 		this->_Mysize = 0;
; 529  : 		}
; 530  : 
; 531  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 532  : 		{	// return reference to successor pointer in node
; 533  : 		return ((_Nodepref)_Pnode->_Next);

  0002d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00030	5f		 pop	 edi
  00031	5e		 pop	 esi

; 1065 : 		this->_Nextnode(this->_Prevnode(_Newnode)) = _Newnode;

  00032	89 10		 mov	 DWORD PTR [eax], edx

; 1286 : 		_Insert(_Unchecked_end(), _Val);
; 1287 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN41@push_back:

; 1907 : 			_Xlength_error("list<T> too long");

  00038	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  0003d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN43@push_back:
$LN40@push_back:
  00042	cc		 int	 3
?push_back@?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::list<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ?clear@?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ PROC ; std::list<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::clear, COMDAT
; _this$ = ecx

; 1491 : 		{	// erase all

  00000	53		 push	 ebx
  00001	8b d9		 mov	 ebx, ecx
  00003	56		 push	 esi

; 533  : 		return ((_Nodepref)_Pnode->_Next);

  00004	8b 03		 mov	 eax, DWORD PTR [ebx]

; 1492 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1493 : 		this->_Orphan_ptr(*this, nullptr);
; 1494 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1495 : 
; 1496 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead);

  00006	8b 30		 mov	 esi, DWORD PTR [eax]

; 1497 : 		this->_Nextnode(this->_Myhead) = this->_Myhead;

  00008	89 00		 mov	 DWORD PTR [eax], eax

; 534  : 		}
; 535  : 
; 536  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 537  : 		{	// return reference to predecessor pointer in node
; 538  : 		return ((_Nodepref)_Pnode->_Prev);

  0000a	8b 03		 mov	 eax, DWORD PTR [ebx]

; 1498 : 		this->_Prevnode(this->_Myhead) = this->_Myhead;

  0000c	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 1499 : 		this->_Mysize = 0;

  0000f	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0

; 1501 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead; _Pnode = _Pnext)

  00016	3b 33		 cmp	 esi, DWORD PTR [ebx]
  00018	74 3b		 je	 SHORT $LN1@clear
  0001a	57		 push	 edi
  0001b	eb 03 8d 49 00	 npad	 5
$LL3@clear:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00020	83 7e 1c 10	 cmp	 DWORD PTR [esi+28], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 1503 : 			_Pnext = this->_Nextnode(_Pnode);

  00024	8b 3e		 mov	 edi, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00026	72 0b		 jb	 SHORT $LN63@clear
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00028	ff 76 08	 push	 DWORD PTR [esi+8]
  0002b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00030	83 c4 04	 add	 esp, 4
$LN63@clear:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00033	c7 46 1c 0f 00
	00 00		 mov	 DWORD PTR [esi+28], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0003a	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00041	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00042	c6 46 08 00	 mov	 BYTE PTR [esi+8], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00046	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004b	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 1501 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead; _Pnode = _Pnext)

  0004e	8b f7		 mov	 esi, edi
  00050	3b 3b		 cmp	 edi, DWORD PTR [ebx]
  00052	75 cc		 jne	 SHORT $LL3@clear
  00054	5f		 pop	 edi
$LN1@clear:
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx

; 1504 : 			this->_Freenode(_Pnode);
; 1505 : 			}
; 1506 : 		}

  00057	c3		 ret	 0
?clear@?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ ENDP ; std::list<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx

; 39   : 		{	// construct with null node pointer

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 340  : 		{	// construct with null node
; 341  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ
_TEXT	SEGMENT
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator*, COMDAT
; _this$ = ecx

; 365  : 
; 366  : 	pointer operator->() const
; 367  : 		{	// return pointer to class object
; 368  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 369  : 		}
; 370  : 
; 371  : 	_Myiter& operator++()
; 372  : 		{	// preincrement
; 373  : 		++(*(_Mybase *)this);
; 374  : 		return (*this);
; 375  : 		}
; 376  : 
; 377  : 	_Myiter operator++(int)
; 378  : 		{	// postincrement
; 379  : 		_Myiter _Tmp = *this;
; 380  : 		++*this;
; 381  : 		return (_Tmp);
; 382  : 		}
; 383  : 
; 384  : 	_Myiter& operator--()
; 385  : 		{	// predecrement
; 386  : 		--(*(_Mybase *)this);
; 387  : 		return (*this);
; 388  : 		}
; 389  : 
; 390  : 	_Myiter operator--(int)
; 391  : 		{	// postdecrement
; 392  : 		_Myiter _Tmp = *this;
; 393  : 		--*this;
; 394  : 		return (_Tmp);
; 395  : 		}
; 396  : 	};
; 397  : 
; 398  : template<class _Mylist> inline
; 399  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 400  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 401  : 	{	// convert to unchecked
; 402  : 	return (_Iter._Unchecked());
; 403  : 	}
; 404  : 
; 405  : template<class _Mylist> inline
; 406  : 	_List_iterator<_Mylist>&
; 407  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 408  : 			typename _List_iterator<_Mylist>
; 409  : 				::_Unchecked_type _Right)
; 410  : 	{	// convert to checked
; 411  : 	return (_Iter._Rechecked(_Right));
; 412  : 	}
; 413  : 
; 414  : 		// list TYPE WRAPPERS
; 415  : template<class _Value_type,
; 416  : 	class _Size_type,
; 417  : 	class _Difference_type,
; 418  : 	class _Pointer,
; 419  : 	class _Const_pointer,
; 420  : 	class _Reference,
; 421  : 	class _Const_reference,
; 422  : 	class _Nodeptr_type>
; 423  : 	struct _List_iter_types
; 424  : 	{	// wraps types needed by iterators
; 425  : 	typedef _Value_type value_type;
; 426  : 	typedef _Size_type size_type;
; 427  : 	typedef _Difference_type difference_type;
; 428  : 	typedef _Pointer pointer;
; 429  : 	typedef _Const_pointer const_pointer;
; 430  : 	typedef _Reference reference;
; 431  : 	typedef _Const_reference const_reference;
; 432  : 	typedef _Nodeptr_type _Nodeptr;
; 433  : 	};
; 434  : 
; 435  : template<class _Value_type,
; 436  : 	class _Voidptr>
; 437  : 	struct _List_node
; 438  : 		{	// list node
; 439  : 		_Voidptr _Next;	// successor node, or first element if head
; 440  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 441  : 		_Value_type _Myval;	// the stored value, unused if head
; 442  : 
; 443  : 	private:
; 444  : 		_List_node& operator=(const _List_node&);
; 445  : 		};
; 446  : 
; 447  : template<class _Value_type>
; 448  : 	struct _List_node<_Value_type, void *>
; 449  : 		{	// list node
; 450  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 451  : 		_Nodeptr _Next;	// successor node, or first element if head
; 452  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 453  : 		_Value_type _Myval;	// the stored value, unused if head
; 454  : 
; 455  : 	private:
; 456  : 		_List_node& operator=(const _List_node&);
; 457  : 		};
; 458  : 
; 459  : template<class _Ty>
; 460  : 	struct _List_simple_types
; 461  : 		: public _Simple_types<_Ty>
; 462  : 	{	// wraps types needed by iterators
; 463  : 	typedef _List_node<_Ty, void *> _Node;
; 464  : 	typedef _Node *_Nodeptr;
; 465  : 	};
; 466  : 
; 467  : template<class _Ty,
; 468  : 	class _Alloc0>
; 469  : 	struct _List_base_types
; 470  : 	{	// types needed for a container base
; 471  : 	typedef _Alloc0 _Alloc;
; 472  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 473  : 
; 474  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 475  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 476  : 
; 477  : 
; 478  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 479  : 		_Voidptr;
; 480  : 	typedef _List_node<typename _Alty::value_type,
; 481  : 		_Voidptr> _Node;
; 482  : 
; 483  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 484  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 485  : 	typedef _Nodeptr& _Nodepref;
; 486  : 
; 487  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 488  : 		_List_simple_types<typename _Alty::value_type>,
; 489  : 		_List_iter_types<typename _Alty::value_type,
; 490  : 			typename _Alty::size_type,
; 491  : 			typename _Alty::difference_type,
; 492  : 			typename _Alty::pointer,
; 493  : 			typename _Alty::const_pointer,
; 494  : 			typename _Alty::reference,
; 495  : 			typename _Alty::const_reference,
; 496  : 			_Nodeptr> >::type
; 497  : 		_Val_types;
; 498  : 	};
; 499  : 
; 500  : 		// TEMPLATE CLASS _List_val
; 501  : template<class _Val_types>
; 502  : 	class _List_val
; 503  : 		: public _Container_base
; 504  : 	{	// base class for list to hold data
; 505  : public:
; 506  : 	typedef _List_val<_Val_types> _Myt;
; 507  : 
; 508  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 509  : 	typedef _Nodeptr& _Nodepref;
; 510  : 
; 511  : 	typedef typename _Val_types::value_type value_type;
; 512  : 	typedef typename _Val_types::size_type size_type;
; 513  : 	typedef typename _Val_types::difference_type difference_type;
; 514  : 	typedef typename _Val_types::pointer pointer;
; 515  : 	typedef typename _Val_types::const_pointer const_pointer;
; 516  : 	typedef typename _Val_types::reference reference;
; 517  : 	typedef typename _Val_types::const_reference const_reference;
; 518  : 
; 519  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 520  : 	typedef _List_iterator<_Myt> iterator;
; 521  : 
; 522  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 523  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 524  : 
; 525  : 	_List_val()
; 526  : 		{	// initialize data
; 527  : 		this->_Myhead = 0;
; 528  : 		this->_Mysize = 0;
; 529  : 		}
; 530  : 
; 531  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 532  : 		{	// return reference to successor pointer in node
; 533  : 		return ((_Nodepref)_Pnode->_Next);
; 534  : 		}
; 535  : 
; 536  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 537  : 		{	// return reference to predecessor pointer in node
; 538  : 		return ((_Nodepref)_Pnode->_Prev);
; 539  : 		}
; 540  : 
; 541  : 	static reference _Myval(_Nodeptr _Pnode)
; 542  : 		{	// return reference to value in node
; 543  : 		return ((reference)_Pnode->_Myval);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 08	 add	 eax, 8

; 363  : 		return ((reference)**(_Mybase *)this);
; 364  : 		}

  00005	c3		 ret	 0
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator++, COMDAT
; _this$ = ecx

; 376  : 
; 377  : 	_Myiter operator++(int)
; 378  : 		{	// postincrement
; 379  : 		_Myiter _Tmp = *this;
; 380  : 		++*this;
; 381  : 		return (_Tmp);
; 382  : 		}
; 383  : 
; 384  : 	_Myiter& operator--()
; 385  : 		{	// predecrement
; 386  : 		--(*(_Mybase *)this);
; 387  : 		return (*this);
; 388  : 		}
; 389  : 
; 390  : 	_Myiter operator--(int)
; 391  : 		{	// postdecrement
; 392  : 		_Myiter _Tmp = *this;
; 393  : 		--*this;
; 394  : 		return (_Tmp);
; 395  : 		}
; 396  : 	};
; 397  : 
; 398  : template<class _Mylist> inline
; 399  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 400  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 401  : 	{	// convert to unchecked
; 402  : 	return (_Iter._Unchecked());
; 403  : 	}
; 404  : 
; 405  : template<class _Mylist> inline
; 406  : 	_List_iterator<_Mylist>&
; 407  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 408  : 			typename _List_iterator<_Mylist>
; 409  : 				::_Unchecked_type _Right)
; 410  : 	{	// convert to checked
; 411  : 	return (_Iter._Rechecked(_Right));
; 412  : 	}
; 413  : 
; 414  : 		// list TYPE WRAPPERS
; 415  : template<class _Value_type,
; 416  : 	class _Size_type,
; 417  : 	class _Difference_type,
; 418  : 	class _Pointer,
; 419  : 	class _Const_pointer,
; 420  : 	class _Reference,
; 421  : 	class _Const_reference,
; 422  : 	class _Nodeptr_type>
; 423  : 	struct _List_iter_types
; 424  : 	{	// wraps types needed by iterators
; 425  : 	typedef _Value_type value_type;
; 426  : 	typedef _Size_type size_type;
; 427  : 	typedef _Difference_type difference_type;
; 428  : 	typedef _Pointer pointer;
; 429  : 	typedef _Const_pointer const_pointer;
; 430  : 	typedef _Reference reference;
; 431  : 	typedef _Const_reference const_reference;
; 432  : 	typedef _Nodeptr_type _Nodeptr;
; 433  : 	};
; 434  : 
; 435  : template<class _Value_type,
; 436  : 	class _Voidptr>
; 437  : 	struct _List_node
; 438  : 		{	// list node
; 439  : 		_Voidptr _Next;	// successor node, or first element if head
; 440  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 441  : 		_Value_type _Myval;	// the stored value, unused if head
; 442  : 
; 443  : 	private:
; 444  : 		_List_node& operator=(const _List_node&);
; 445  : 		};
; 446  : 
; 447  : template<class _Value_type>
; 448  : 	struct _List_node<_Value_type, void *>
; 449  : 		{	// list node
; 450  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 451  : 		_Nodeptr _Next;	// successor node, or first element if head
; 452  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 453  : 		_Value_type _Myval;	// the stored value, unused if head
; 454  : 
; 455  : 	private:
; 456  : 		_List_node& operator=(const _List_node&);
; 457  : 		};
; 458  : 
; 459  : template<class _Ty>
; 460  : 	struct _List_simple_types
; 461  : 		: public _Simple_types<_Ty>
; 462  : 	{	// wraps types needed by iterators
; 463  : 	typedef _List_node<_Ty, void *> _Node;
; 464  : 	typedef _Node *_Nodeptr;
; 465  : 	};
; 466  : 
; 467  : template<class _Ty,
; 468  : 	class _Alloc0>
; 469  : 	struct _List_base_types
; 470  : 	{	// types needed for a container base
; 471  : 	typedef _Alloc0 _Alloc;
; 472  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 473  : 
; 474  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 475  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 476  : 
; 477  : 
; 478  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 479  : 		_Voidptr;
; 480  : 	typedef _List_node<typename _Alty::value_type,
; 481  : 		_Voidptr> _Node;
; 482  : 
; 483  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 484  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 485  : 	typedef _Nodeptr& _Nodepref;
; 486  : 
; 487  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 488  : 		_List_simple_types<typename _Alty::value_type>,
; 489  : 		_List_iter_types<typename _Alty::value_type,
; 490  : 			typename _Alty::size_type,
; 491  : 			typename _Alty::difference_type,
; 492  : 			typename _Alty::pointer,
; 493  : 			typename _Alty::const_pointer,
; 494  : 			typename _Alty::reference,
; 495  : 			typename _Alty::const_reference,
; 496  : 			_Nodeptr> >::type
; 497  : 		_Val_types;
; 498  : 	};
; 499  : 
; 500  : 		// TEMPLATE CLASS _List_val
; 501  : template<class _Val_types>
; 502  : 	class _List_val
; 503  : 		: public _Container_base
; 504  : 	{	// base class for list to hold data
; 505  : public:
; 506  : 	typedef _List_val<_Val_types> _Myt;
; 507  : 
; 508  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 509  : 	typedef _Nodeptr& _Nodepref;
; 510  : 
; 511  : 	typedef typename _Val_types::value_type value_type;
; 512  : 	typedef typename _Val_types::size_type size_type;
; 513  : 	typedef typename _Val_types::difference_type difference_type;
; 514  : 	typedef typename _Val_types::pointer pointer;
; 515  : 	typedef typename _Val_types::const_pointer const_pointer;
; 516  : 	typedef typename _Val_types::reference reference;
; 517  : 	typedef typename _Val_types::const_reference const_reference;
; 518  : 
; 519  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 520  : 	typedef _List_iterator<_Myt> iterator;
; 521  : 
; 522  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 523  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 524  : 
; 525  : 	_List_val()
; 526  : 		{	// initialize data
; 527  : 		this->_Myhead = 0;
; 528  : 		this->_Mysize = 0;
; 529  : 		}
; 530  : 
; 531  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 532  : 		{	// return reference to successor pointer in node
; 533  : 		return ((_Nodepref)_Pnode->_Next);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  00002	8b 00		 mov	 eax, DWORD PTR [eax]
  00004	89 01		 mov	 DWORD PTR [ecx], eax

; 373  : 		++(*(_Mybase *)this);
; 374  : 		return (*this);

  00006	8b c1		 mov	 eax, ecx

; 375  : 		}

  00008	c3		 ret	 0
??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator!=, COMDAT
; _this$ = ecx

; 302  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 298  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]

; 303  : 		return (!(*this == _Right));

  00005	33 c0		 xor	 eax, eax

; 298  : 		return (this->_Ptr == _Right._Ptr);

  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]

; 303  : 		return (!(*this == _Right));

  0000c	0f 95 c0	 setne	 al

; 304  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??1?$_List_buy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_List_buy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ PROC ; std::_List_buy<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_List_buy<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 573  : 		::operator delete(_Ptr);

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00007	59		 pop	 ecx
  00008	c3		 ret	 0
??1?$_List_buy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ENDP ; std::_List_buy<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_List_buy<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ?_Unchecked_end@?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Unchecked_end@?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@XZ PROC ; std::list<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Unchecked_end, COMDAT
; _this$ = ecx

; 1147 : 		{	// return unchecked iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 44   : 		{	// construct with node pointer _Pnode

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1148 : 		return (_Unchecked_iterator(this->_Myhead, this));
; 1149 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?_Unchecked_end@?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ?_Tidy@?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ
_TEXT	SEGMENT
?_Tidy@?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ PROC ; std::list<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy, COMDAT
; _this$ = ecx

; 1883 : 		clear();

  00000	e9 00 00 00 00	 jmp	 ?clear@?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ ; std::list<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::clear
?_Tidy@?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ ENDP ; std::list<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??0?$_List_buy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??0?$_List_buy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC ; std::_List_buy<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_List_buy<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 823  : 		{	// construct from allocator

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 703  : 		}
; 704  : 
; 705  : 	~_List_alloc() _NOEXCEPT
; 706  : 		{	// destroy head node
; 707  : 		_Freeheadnode(this->_Myhead);
; 708  : 		}
; 709  : 
; 710  : 	void _Change_alloc(const _Alty&)
; 711  : 		{	// replace old allocator
; 712  : 		}
; 713  : 
; 714  : 	void _Swap_alloc(_Myt&)
; 715  : 		{	// swap allocators
; 716  : 		}
; 717  : 
; 718  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 719  : 	_List_alloc(const _Alloc& = _Alloc())
; 720  : 		{	// construct allocators from _Al
; 721  : 		this->_Myhead = _Buyheadnode();
; 722  : 		_TRY_BEGIN
; 723  : 		_Alloc_proxy();
; 724  : 		_CATCH_ALL
; 725  : 		_Freeheadnode(this->_Myhead);
; 726  : 		_RERAISE;
; 727  : 		_CATCH_END
; 728  : 		}
; 729  : 
; 730  : 	~_List_alloc() _NOEXCEPT
; 731  : 		{	// destroy proxy
; 732  : 		_Freeheadnode(this->_Myhead);
; 733  : 		_Free_proxy();
; 734  : 		}
; 735  : 
; 736  : 	void _Change_alloc(const _Alty&)
; 737  : 		{	// replace old allocator
; 738  : 		}
; 739  : 
; 740  : 	void _Swap_alloc(_Myt& _Right)
; 741  : 		{	// swap allocators
; 742  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 743  : 		}
; 744  : 
; 745  : 	void _Alloc_proxy()
; 746  : 		{	// construct proxy from _Alnod
; 747  : 		typename _Alty::template rebind<_Container_proxy>::other
; 748  : 			_Alproxy;
; 749  : 		this->_Myproxy = _Alproxy.allocate(1);
; 750  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 751  : 		this->_Myproxy->_Mycont = this;
; 752  : 		}
; 753  : 
; 754  : 	void _Free_proxy()
; 755  : 		{	// destroy proxy
; 756  : 		typename _Alty::template rebind<_Container_proxy>::other
; 757  : 			_Alproxy;
; 758  : 		this->_Orphan_all();
; 759  : 		_Alproxy.destroy(this->_Myproxy);
; 760  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 761  : 		this->_Myproxy = 0;
; 762  : 		}
; 763  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 764  : 
; 765  : 	_Nodeptr _Buyheadnode()
; 766  : 		{	// get head node using current allocator
; 767  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  00003	6a 00		 push	 0
  00005	6a 00		 push	 0

; 527  : 		this->_Myhead = 0;

  00007	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 528  : 		this->_Mysize = 0;

  0000d	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 703  : 		}
; 704  : 
; 705  : 	~_List_alloc() _NOEXCEPT
; 706  : 		{	// destroy head node
; 707  : 		_Freeheadnode(this->_Myhead);
; 708  : 		}
; 709  : 
; 710  : 	void _Change_alloc(const _Alty&)
; 711  : 		{	// replace old allocator
; 712  : 		}
; 713  : 
; 714  : 	void _Swap_alloc(_Myt&)
; 715  : 		{	// swap allocators
; 716  : 		}
; 717  : 
; 718  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 719  : 	_List_alloc(const _Alloc& = _Alloc())
; 720  : 		{	// construct allocators from _Al
; 721  : 		this->_Myhead = _Buyheadnode();
; 722  : 		_TRY_BEGIN
; 723  : 		_Alloc_proxy();
; 724  : 		_CATCH_ALL
; 725  : 		_Freeheadnode(this->_Myhead);
; 726  : 		_RERAISE;
; 727  : 		_CATCH_END
; 728  : 		}
; 729  : 
; 730  : 	~_List_alloc() _NOEXCEPT
; 731  : 		{	// destroy proxy
; 732  : 		_Freeheadnode(this->_Myhead);
; 733  : 		_Free_proxy();
; 734  : 		}
; 735  : 
; 736  : 	void _Change_alloc(const _Alty&)
; 737  : 		{	// replace old allocator
; 738  : 		}
; 739  : 
; 740  : 	void _Swap_alloc(_Myt& _Right)
; 741  : 		{	// swap allocators
; 742  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 743  : 		}
; 744  : 
; 745  : 	void _Alloc_proxy()
; 746  : 		{	// construct proxy from _Alnod
; 747  : 		typename _Alty::template rebind<_Container_proxy>::other
; 748  : 			_Alproxy;
; 749  : 		this->_Myproxy = _Alproxy.allocate(1);
; 750  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 751  : 		this->_Myproxy->_Mycont = this;
; 752  : 		}
; 753  : 
; 754  : 	void _Free_proxy()
; 755  : 		{	// destroy proxy
; 756  : 		typename _Alty::template rebind<_Container_proxy>::other
; 757  : 			_Alproxy;
; 758  : 		this->_Orphan_all();
; 759  : 		_Alproxy.destroy(this->_Myproxy);
; 760  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 761  : 		this->_Myproxy = 0;
; 762  : 		}
; 763  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 764  : 
; 765  : 	_Nodeptr _Buyheadnode()
; 766  : 		{	// get head node using current allocator
; 767  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  00014	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@PAU32@0@Z ; std::_List_alloc<0,std::_List_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Buynode0

; 529  : 		}
; 530  : 
; 531  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 532  : 		{	// return reference to successor pointer in node
; 533  : 		return ((_Nodepref)_Pnode->_Next);
; 534  : 		}
; 535  : 
; 536  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 537  : 		{	// return reference to predecessor pointer in node
; 538  : 		return ((_Nodepref)_Pnode->_Prev);
; 539  : 		}
; 540  : 
; 541  : 	static reference _Myval(_Nodeptr _Pnode)
; 542  : 		{	// return reference to value in node
; 543  : 		return ((reference)_Pnode->_Myval);
; 544  : 		}
; 545  : 
; 546  : 	_Nodeptr _Myhead;	// pointer to head node
; 547  : 	size_type _Mysize;	// number of elements
; 548  : 	};
; 549  : 
; 550  : 		// TEMPLATE CLASS _List_alloc
; 551  : template<bool _Al_has_storage,
; 552  : 	class _Alloc_types>
; 553  : 	class _List_alloc
; 554  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 555  : 	{	// base class for list to hold allocator with storage
; 556  : public:
; 557  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 558  : 
; 559  : 	typedef _List_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 560  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 561  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 562  : 	typedef typename _Alloc_types::_Node _Node;
; 563  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 564  : 
; 565  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 566  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 567  : 		: _Alnod(_Al)
; 568  : 		{	// construct head node, allocator from _Al
; 569  : 		this->_Myhead = _Buyheadnode();
; 570  : 		}
; 571  : 
; 572  : 	~_List_alloc() _NOEXCEPT
; 573  : 		{	// destroy head node
; 574  : 		_Freeheadnode(this->_Myhead);
; 575  : 		}
; 576  : 
; 577  : 	void _Change_alloc(const _Alty& _Al)
; 578  : 		{	// replace old allocator
; 579  : 		this->_Alnod = _Al;
; 580  : 		}
; 581  : 
; 582  : 	void _Swap_alloc(_Myt& _Right)
; 583  : 		{	// swap allocators
; 584  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 585  : 		}
; 586  : 
; 587  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 588  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 589  : 		: _Alnod(_Al)
; 590  : 		{	// construct head node, allocator from _Al
; 591  : 		this->_Myhead = _Buyheadnode();
; 592  : 		_TRY_BEGIN
; 593  : 		_Alloc_proxy();
; 594  : 		_CATCH_ALL
; 595  : 		_Freeheadnode(this->_Myhead);
; 596  : 		_RERAISE;
; 597  : 		_CATCH_END
; 598  : 		}
; 599  : 
; 600  : 	~_List_alloc() _NOEXCEPT
; 601  : 		{	// destroy proxy
; 602  : 		_Freeheadnode(this->_Myhead);
; 603  : 		_Free_proxy();
; 604  : 		}
; 605  : 
; 606  : 	void _Change_alloc(const _Alty& _Al)
; 607  : 		{	// replace old allocator
; 608  : 		_Free_proxy();
; 609  : 		this->_Alnod = _Al;
; 610  : 		_Alloc_proxy();
; 611  : 		}
; 612  : 
; 613  : 	void _Swap_alloc(_Myt& _Right)
; 614  : 		{	// swap allocators
; 615  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 616  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 617  : 		}
; 618  : 
; 619  : 	void _Alloc_proxy()
; 620  : 		{	// construct proxy from _Alnod
; 621  : 		typename _Alty::template rebind<_Container_proxy>::other
; 622  : 			_Alproxy(this->_Alnod);
; 623  : 		this->_Myproxy = _Alproxy.allocate(1);
; 624  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 625  : 		this->_Myproxy->_Mycont = this;
; 626  : 		}
; 627  : 
; 628  : 	void _Free_proxy()
; 629  : 		{	// destroy proxy
; 630  : 		typename _Alty::template rebind<_Container_proxy>::other
; 631  : 			_Alproxy(this->_Alnod);
; 632  : 		this->_Orphan_all();
; 633  : 		_Alproxy.destroy(this->_Myproxy);
; 634  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 635  : 		this->_Myproxy = 0;
; 636  : 		}
; 637  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 638  : 
; 639  : 	_Nodeptr _Buyheadnode()
; 640  : 		{	// get head node using current allocator
; 641  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));
; 642  : 		}
; 643  : 
; 644  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 645  : 		{	// free head node using current allocator
; 646  : 		this->_Alnod.destroy(
; 647  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 648  : 		this->_Alnod.destroy(
; 649  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 650  : 		this->_Alnod.deallocate(_Pnode, 1);
; 651  : 		}
; 652  : 
; 653  : 	_Nodeptr _Buynode0(_Nodeptr _Next,
; 654  : 		_Nodeptr _Prev)
; 655  : 		{	// allocate a node and set links
; 656  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 657  : 
; 658  : 		if (_Next == _Nodeptr())
; 659  : 			{	// point at self
; 660  : 			_Next = _Pnode;
; 661  : 			_Prev = _Pnode;
; 662  : 			}
; 663  : 		_TRY_BEGIN
; 664  : 		this->_Alnod.construct(
; 665  : 			_STD addressof(this->_Nextnode(_Pnode)), _Next);
; 666  : 		this->_Alnod.construct(
; 667  : 			_STD addressof(this->_Prevnode(_Pnode)), _Prev);
; 668  : 		_CATCH_ALL
; 669  : 		this->_Alnod.deallocate(_Pnode, 1);
; 670  : 		_RERAISE;
; 671  : 		_CATCH_END
; 672  : 
; 673  : 		return (_Pnode);
; 674  : 		}
; 675  : 
; 676  : 	_Alty& _Getal()
; 677  : 		{	// get reference to allocator
; 678  : 		return (this->_Alnod);
; 679  : 		}
; 680  : 
; 681  : 	const _Alty& _Getal() const
; 682  : 		{	// get reference to allocator
; 683  : 		return (this->_Alnod);
; 684  : 		}
; 685  : 	};
; 686  : 
; 687  : 		// TEMPLATE CLASS _List_alloc
; 688  : template<class _Alloc_types>
; 689  : 	class _List_alloc<false, _Alloc_types>
; 690  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 691  : 	{	// base class for list to hold allocator with no storage
; 692  : public:
; 693  : 	typedef _List_alloc<false, _Alloc_types> _Myt;
; 694  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 695  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 696  : 	typedef typename _Alloc_types::_Node _Node;
; 697  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 698  : 
; 699  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 700  : 	_List_alloc(const _Alloc& = _Alloc())
; 701  : 		{	// construct head node, allocator from _Al
; 702  : 		this->_Myhead = _Buyheadnode();

  00019	89 06		 mov	 DWORD PTR [esi], eax

; 824  : 		}

  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	c2 04 00	 ret	 4
??0?$_List_buy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::_List_buy<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_List_buy<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ?_Freenode@?$_List_buy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freenode@?$_List_buy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@@Z PROC ; std::_List_buy<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Freenode, COMDAT
; _this$ = ecx

; 846  : 		{	// give node back

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 543  : 		return ((reference)_Pnode->_Myval);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Pnode$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00007	83 7e 1c 10	 cmp	 DWORD PTR [esi+28], 16	; 00000010H
  0000b	72 0b		 jb	 SHORT $LN50@Freenode
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0000d	ff 76 08	 push	 DWORD PTR [esi+8]
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4
$LN50@Freenode:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00018	c7 46 1c 0f 00
	00 00		 mov	 DWORD PTR [esi+28], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0001f	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00026	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00027	c6 46 08 00	 mov	 BYTE PTR [esi+8], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0002b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00030	83 c4 04	 add	 esp, 4
  00033	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 854  : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
?_Freenode@?$_List_buy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@@Z ENDP ; std::_List_buy<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Freenode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??1?$_List_alloc@$0A@U?$_List_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_List_alloc@$0A@U?$_List_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@XZ PROC ; std::_List_alloc<0,std::_List_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~_List_alloc<0,std::_List_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00007	59		 pop	 ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 708  : 		}

  00008	c3		 ret	 0
??1?$_List_alloc@$0A@U?$_List_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@XZ ENDP ; std::_List_alloc<0,std::_List_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~_List_alloc<0,std::_List_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ?_Nextnode@?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAAAPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Nextnode@?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAAAPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@PAU32@@Z PROC ; std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Nextnode, COMDAT

; 532  : 		{	// return reference to successor pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 533  : 		return ((_Nodepref)_Pnode->_Next);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 534  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?_Nextnode@?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAAAPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@PAU32@@Z ENDP ; std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Nextnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ?_Prevnode@?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAAAPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Prevnode@?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAAAPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@PAU32@@Z PROC ; std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Prevnode, COMDAT

; 537  : 		{	// return reference to predecessor pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 538  : 		return ((_Nodepref)_Pnode->_Prev);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 04	 add	 eax, 4

; 539  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Prevnode@?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAAAPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@PAU32@@Z ENDP ; std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Prevnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx

; 345  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 44   : 		{	// construct with node pointer _Pnode

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 346  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx

; 39   : 		{	// construct with null node pointer

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 183  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ
_TEXT	SEGMENT
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator*, COMDAT
; _this$ = ecx

; 222  : 
; 223  : 	_Myiter& operator++()
; 224  : 		{	// preincrement
; 225  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 226  : 		if (this->_Getcont() == 0
; 227  : 			|| this->_Ptr == 0
; 228  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 229  : 			{	// report error
; 230  : 			_DEBUG_ERROR("list iterator not incrementable");
; 231  : 			_SCL_SECURE_OUT_OF_RANGE;
; 232  : 			}
; 233  : 
; 234  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 235  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 236  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 237  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 238  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 239  : 
; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);
; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);
; 299  : 		}
; 300  : 
; 301  : 	bool operator!=(const _Myiter& _Right) const
; 302  : 		{	// test for iterator inequality
; 303  : 		return (!(*this == _Right));
; 304  : 		}
; 305  : 	};
; 306  : 
; 307  : template<class _Mylist> inline
; 308  : 	typename _List_const_iterator<_Mylist>::_Unchecked_type
; 309  : 		_Unchecked(_List_const_iterator<_Mylist> _Iter)
; 310  : 	{	// convert to unchecked
; 311  : 	return (_Iter._Unchecked());
; 312  : 	}
; 313  : 
; 314  : template<class _Mylist> inline
; 315  : 	_List_const_iterator<_Mylist>&
; 316  : 		_Rechecked(_List_const_iterator<_Mylist>& _Iter,
; 317  : 			typename _List_const_iterator<_Mylist>
; 318  : 				::_Unchecked_type _Right)
; 319  : 	{	// convert to checked
; 320  : 	return (_Iter._Rechecked(_Right));
; 321  : 	}
; 322  : 
; 323  : 	// TEMPLATE CLASS _List_iterator
; 324  : template<class _Mylist>
; 325  : 	class _List_iterator
; 326  : 		: public _List_const_iterator<_Mylist>
; 327  : 	{	// iterator for mutable list
; 328  : public:
; 329  : 	typedef _List_iterator<_Mylist> _Myiter;
; 330  : 	typedef _List_const_iterator<_Mylist> _Mybase;
; 331  : 	typedef bidirectional_iterator_tag iterator_category;
; 332  : 
; 333  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 334  : 	typedef typename _Mylist::value_type value_type;
; 335  : 	typedef typename _Mylist::difference_type difference_type;
; 336  : 	typedef typename _Mylist::pointer pointer;
; 337  : 	typedef typename _Mylist::reference reference;
; 338  : 
; 339  : 	_List_iterator()
; 340  : 		{	// construct with null node
; 341  : 		}
; 342  : 
; 343  : 	_List_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 344  : 		: _Mybase(_Pnode, _Plist)
; 345  : 		{	// construct with node pointer _Pnode
; 346  : 		}
; 347  : 
; 348  : 	typedef _List_unchecked_iterator<_Mylist> _Unchecked_type;
; 349  : 
; 350  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 351  : 		{	// reset from unchecked iterator
; 352  : 		this->_Ptr = _Right._Ptr;
; 353  : 		return (*this);
; 354  : 		}
; 355  : 
; 356  : 	_Unchecked_type _Unchecked() const
; 357  : 		{	// make an unchecked iterator
; 358  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 359  : 		}
; 360  : 
; 361  : 	reference operator*() const
; 362  : 		{	// return designated value
; 363  : 		return ((reference)**(_Mybase *)this);
; 364  : 		}
; 365  : 
; 366  : 	pointer operator->() const
; 367  : 		{	// return pointer to class object
; 368  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 369  : 		}
; 370  : 
; 371  : 	_Myiter& operator++()
; 372  : 		{	// preincrement
; 373  : 		++(*(_Mybase *)this);
; 374  : 		return (*this);
; 375  : 		}
; 376  : 
; 377  : 	_Myiter operator++(int)
; 378  : 		{	// postincrement
; 379  : 		_Myiter _Tmp = *this;
; 380  : 		++*this;
; 381  : 		return (_Tmp);
; 382  : 		}
; 383  : 
; 384  : 	_Myiter& operator--()
; 385  : 		{	// predecrement
; 386  : 		--(*(_Mybase *)this);
; 387  : 		return (*this);
; 388  : 		}
; 389  : 
; 390  : 	_Myiter operator--(int)
; 391  : 		{	// postdecrement
; 392  : 		_Myiter _Tmp = *this;
; 393  : 		--*this;
; 394  : 		return (_Tmp);
; 395  : 		}
; 396  : 	};
; 397  : 
; 398  : template<class _Mylist> inline
; 399  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 400  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 401  : 	{	// convert to unchecked
; 402  : 	return (_Iter._Unchecked());
; 403  : 	}
; 404  : 
; 405  : template<class _Mylist> inline
; 406  : 	_List_iterator<_Mylist>&
; 407  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 408  : 			typename _List_iterator<_Mylist>
; 409  : 				::_Unchecked_type _Right)
; 410  : 	{	// convert to checked
; 411  : 	return (_Iter._Rechecked(_Right));
; 412  : 	}
; 413  : 
; 414  : 		// list TYPE WRAPPERS
; 415  : template<class _Value_type,
; 416  : 	class _Size_type,
; 417  : 	class _Difference_type,
; 418  : 	class _Pointer,
; 419  : 	class _Const_pointer,
; 420  : 	class _Reference,
; 421  : 	class _Const_reference,
; 422  : 	class _Nodeptr_type>
; 423  : 	struct _List_iter_types
; 424  : 	{	// wraps types needed by iterators
; 425  : 	typedef _Value_type value_type;
; 426  : 	typedef _Size_type size_type;
; 427  : 	typedef _Difference_type difference_type;
; 428  : 	typedef _Pointer pointer;
; 429  : 	typedef _Const_pointer const_pointer;
; 430  : 	typedef _Reference reference;
; 431  : 	typedef _Const_reference const_reference;
; 432  : 	typedef _Nodeptr_type _Nodeptr;
; 433  : 	};
; 434  : 
; 435  : template<class _Value_type,
; 436  : 	class _Voidptr>
; 437  : 	struct _List_node
; 438  : 		{	// list node
; 439  : 		_Voidptr _Next;	// successor node, or first element if head
; 440  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 441  : 		_Value_type _Myval;	// the stored value, unused if head
; 442  : 
; 443  : 	private:
; 444  : 		_List_node& operator=(const _List_node&);
; 445  : 		};
; 446  : 
; 447  : template<class _Value_type>
; 448  : 	struct _List_node<_Value_type, void *>
; 449  : 		{	// list node
; 450  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 451  : 		_Nodeptr _Next;	// successor node, or first element if head
; 452  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 453  : 		_Value_type _Myval;	// the stored value, unused if head
; 454  : 
; 455  : 	private:
; 456  : 		_List_node& operator=(const _List_node&);
; 457  : 		};
; 458  : 
; 459  : template<class _Ty>
; 460  : 	struct _List_simple_types
; 461  : 		: public _Simple_types<_Ty>
; 462  : 	{	// wraps types needed by iterators
; 463  : 	typedef _List_node<_Ty, void *> _Node;
; 464  : 	typedef _Node *_Nodeptr;
; 465  : 	};
; 466  : 
; 467  : template<class _Ty,
; 468  : 	class _Alloc0>
; 469  : 	struct _List_base_types
; 470  : 	{	// types needed for a container base
; 471  : 	typedef _Alloc0 _Alloc;
; 472  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 473  : 
; 474  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 475  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 476  : 
; 477  : 
; 478  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 479  : 		_Voidptr;
; 480  : 	typedef _List_node<typename _Alty::value_type,
; 481  : 		_Voidptr> _Node;
; 482  : 
; 483  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 484  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 485  : 	typedef _Nodeptr& _Nodepref;
; 486  : 
; 487  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 488  : 		_List_simple_types<typename _Alty::value_type>,
; 489  : 		_List_iter_types<typename _Alty::value_type,
; 490  : 			typename _Alty::size_type,
; 491  : 			typename _Alty::difference_type,
; 492  : 			typename _Alty::pointer,
; 493  : 			typename _Alty::const_pointer,
; 494  : 			typename _Alty::reference,
; 495  : 			typename _Alty::const_reference,
; 496  : 			_Nodeptr> >::type
; 497  : 		_Val_types;
; 498  : 	};
; 499  : 
; 500  : 		// TEMPLATE CLASS _List_val
; 501  : template<class _Val_types>
; 502  : 	class _List_val
; 503  : 		: public _Container_base
; 504  : 	{	// base class for list to hold data
; 505  : public:
; 506  : 	typedef _List_val<_Val_types> _Myt;
; 507  : 
; 508  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 509  : 	typedef _Nodeptr& _Nodepref;
; 510  : 
; 511  : 	typedef typename _Val_types::value_type value_type;
; 512  : 	typedef typename _Val_types::size_type size_type;
; 513  : 	typedef typename _Val_types::difference_type difference_type;
; 514  : 	typedef typename _Val_types::pointer pointer;
; 515  : 	typedef typename _Val_types::const_pointer const_pointer;
; 516  : 	typedef typename _Val_types::reference reference;
; 517  : 	typedef typename _Val_types::const_reference const_reference;
; 518  : 
; 519  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 520  : 	typedef _List_iterator<_Myt> iterator;
; 521  : 
; 522  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 523  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 524  : 
; 525  : 	_List_val()
; 526  : 		{	// initialize data
; 527  : 		this->_Myhead = 0;
; 528  : 		this->_Mysize = 0;
; 529  : 		}
; 530  : 
; 531  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 532  : 		{	// return reference to successor pointer in node
; 533  : 		return ((_Nodepref)_Pnode->_Next);
; 534  : 		}
; 535  : 
; 536  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 537  : 		{	// return reference to predecessor pointer in node
; 538  : 		return ((_Nodepref)_Pnode->_Prev);
; 539  : 		}
; 540  : 
; 541  : 	static reference _Myval(_Nodeptr _Pnode)
; 542  : 		{	// return reference to value in node
; 543  : 		return ((reference)_Pnode->_Myval);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 08	 add	 eax, 8

; 205  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 206  : 		if (this->_Getcont() == 0
; 207  : 			|| this->_Ptr == 0
; 208  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 209  : 			{	// report error
; 210  : 			_DEBUG_ERROR("list iterator not dereferencable");
; 211  : 			_SCL_SECURE_OUT_OF_RANGE;
; 212  : 			}
; 213  : 
; 214  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 215  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 216  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 217  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 218  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 219  : 
; 220  : 		return (_Mylist::_Myval(this->_Ptr));
; 221  : 		}

  00005	c3		 ret	 0
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator++, COMDAT
; _this$ = ecx

; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);
; 299  : 		}
; 300  : 
; 301  : 	bool operator!=(const _Myiter& _Right) const
; 302  : 		{	// test for iterator inequality
; 303  : 		return (!(*this == _Right));
; 304  : 		}
; 305  : 	};
; 306  : 
; 307  : template<class _Mylist> inline
; 308  : 	typename _List_const_iterator<_Mylist>::_Unchecked_type
; 309  : 		_Unchecked(_List_const_iterator<_Mylist> _Iter)
; 310  : 	{	// convert to unchecked
; 311  : 	return (_Iter._Unchecked());
; 312  : 	}
; 313  : 
; 314  : template<class _Mylist> inline
; 315  : 	_List_const_iterator<_Mylist>&
; 316  : 		_Rechecked(_List_const_iterator<_Mylist>& _Iter,
; 317  : 			typename _List_const_iterator<_Mylist>
; 318  : 				::_Unchecked_type _Right)
; 319  : 	{	// convert to checked
; 320  : 	return (_Iter._Rechecked(_Right));
; 321  : 	}
; 322  : 
; 323  : 	// TEMPLATE CLASS _List_iterator
; 324  : template<class _Mylist>
; 325  : 	class _List_iterator
; 326  : 		: public _List_const_iterator<_Mylist>
; 327  : 	{	// iterator for mutable list
; 328  : public:
; 329  : 	typedef _List_iterator<_Mylist> _Myiter;
; 330  : 	typedef _List_const_iterator<_Mylist> _Mybase;
; 331  : 	typedef bidirectional_iterator_tag iterator_category;
; 332  : 
; 333  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 334  : 	typedef typename _Mylist::value_type value_type;
; 335  : 	typedef typename _Mylist::difference_type difference_type;
; 336  : 	typedef typename _Mylist::pointer pointer;
; 337  : 	typedef typename _Mylist::reference reference;
; 338  : 
; 339  : 	_List_iterator()
; 340  : 		{	// construct with null node
; 341  : 		}
; 342  : 
; 343  : 	_List_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 344  : 		: _Mybase(_Pnode, _Plist)
; 345  : 		{	// construct with node pointer _Pnode
; 346  : 		}
; 347  : 
; 348  : 	typedef _List_unchecked_iterator<_Mylist> _Unchecked_type;
; 349  : 
; 350  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 351  : 		{	// reset from unchecked iterator
; 352  : 		this->_Ptr = _Right._Ptr;
; 353  : 		return (*this);
; 354  : 		}
; 355  : 
; 356  : 	_Unchecked_type _Unchecked() const
; 357  : 		{	// make an unchecked iterator
; 358  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 359  : 		}
; 360  : 
; 361  : 	reference operator*() const
; 362  : 		{	// return designated value
; 363  : 		return ((reference)**(_Mybase *)this);
; 364  : 		}
; 365  : 
; 366  : 	pointer operator->() const
; 367  : 		{	// return pointer to class object
; 368  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 369  : 		}
; 370  : 
; 371  : 	_Myiter& operator++()
; 372  : 		{	// preincrement
; 373  : 		++(*(_Mybase *)this);
; 374  : 		return (*this);
; 375  : 		}
; 376  : 
; 377  : 	_Myiter operator++(int)
; 378  : 		{	// postincrement
; 379  : 		_Myiter _Tmp = *this;
; 380  : 		++*this;
; 381  : 		return (_Tmp);
; 382  : 		}
; 383  : 
; 384  : 	_Myiter& operator--()
; 385  : 		{	// predecrement
; 386  : 		--(*(_Mybase *)this);
; 387  : 		return (*this);
; 388  : 		}
; 389  : 
; 390  : 	_Myiter operator--(int)
; 391  : 		{	// postdecrement
; 392  : 		_Myiter _Tmp = *this;
; 393  : 		--*this;
; 394  : 		return (_Tmp);
; 395  : 		}
; 396  : 	};
; 397  : 
; 398  : template<class _Mylist> inline
; 399  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 400  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 401  : 	{	// convert to unchecked
; 402  : 	return (_Iter._Unchecked());
; 403  : 	}
; 404  : 
; 405  : template<class _Mylist> inline
; 406  : 	_List_iterator<_Mylist>&
; 407  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 408  : 			typename _List_iterator<_Mylist>
; 409  : 				::_Unchecked_type _Right)
; 410  : 	{	// convert to checked
; 411  : 	return (_Iter._Rechecked(_Right));
; 412  : 	}
; 413  : 
; 414  : 		// list TYPE WRAPPERS
; 415  : template<class _Value_type,
; 416  : 	class _Size_type,
; 417  : 	class _Difference_type,
; 418  : 	class _Pointer,
; 419  : 	class _Const_pointer,
; 420  : 	class _Reference,
; 421  : 	class _Const_reference,
; 422  : 	class _Nodeptr_type>
; 423  : 	struct _List_iter_types
; 424  : 	{	// wraps types needed by iterators
; 425  : 	typedef _Value_type value_type;
; 426  : 	typedef _Size_type size_type;
; 427  : 	typedef _Difference_type difference_type;
; 428  : 	typedef _Pointer pointer;
; 429  : 	typedef _Const_pointer const_pointer;
; 430  : 	typedef _Reference reference;
; 431  : 	typedef _Const_reference const_reference;
; 432  : 	typedef _Nodeptr_type _Nodeptr;
; 433  : 	};
; 434  : 
; 435  : template<class _Value_type,
; 436  : 	class _Voidptr>
; 437  : 	struct _List_node
; 438  : 		{	// list node
; 439  : 		_Voidptr _Next;	// successor node, or first element if head
; 440  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 441  : 		_Value_type _Myval;	// the stored value, unused if head
; 442  : 
; 443  : 	private:
; 444  : 		_List_node& operator=(const _List_node&);
; 445  : 		};
; 446  : 
; 447  : template<class _Value_type>
; 448  : 	struct _List_node<_Value_type, void *>
; 449  : 		{	// list node
; 450  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 451  : 		_Nodeptr _Next;	// successor node, or first element if head
; 452  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 453  : 		_Value_type _Myval;	// the stored value, unused if head
; 454  : 
; 455  : 	private:
; 456  : 		_List_node& operator=(const _List_node&);
; 457  : 		};
; 458  : 
; 459  : template<class _Ty>
; 460  : 	struct _List_simple_types
; 461  : 		: public _Simple_types<_Ty>
; 462  : 	{	// wraps types needed by iterators
; 463  : 	typedef _List_node<_Ty, void *> _Node;
; 464  : 	typedef _Node *_Nodeptr;
; 465  : 	};
; 466  : 
; 467  : template<class _Ty,
; 468  : 	class _Alloc0>
; 469  : 	struct _List_base_types
; 470  : 	{	// types needed for a container base
; 471  : 	typedef _Alloc0 _Alloc;
; 472  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 473  : 
; 474  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 475  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 476  : 
; 477  : 
; 478  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 479  : 		_Voidptr;
; 480  : 	typedef _List_node<typename _Alty::value_type,
; 481  : 		_Voidptr> _Node;
; 482  : 
; 483  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 484  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 485  : 	typedef _Nodeptr& _Nodepref;
; 486  : 
; 487  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 488  : 		_List_simple_types<typename _Alty::value_type>,
; 489  : 		_List_iter_types<typename _Alty::value_type,
; 490  : 			typename _Alty::size_type,
; 491  : 			typename _Alty::difference_type,
; 492  : 			typename _Alty::pointer,
; 493  : 			typename _Alty::const_pointer,
; 494  : 			typename _Alty::reference,
; 495  : 			typename _Alty::const_reference,
; 496  : 			_Nodeptr> >::type
; 497  : 		_Val_types;
; 498  : 	};
; 499  : 
; 500  : 		// TEMPLATE CLASS _List_val
; 501  : template<class _Val_types>
; 502  : 	class _List_val
; 503  : 		: public _Container_base
; 504  : 	{	// base class for list to hold data
; 505  : public:
; 506  : 	typedef _List_val<_Val_types> _Myt;
; 507  : 
; 508  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 509  : 	typedef _Nodeptr& _Nodepref;
; 510  : 
; 511  : 	typedef typename _Val_types::value_type value_type;
; 512  : 	typedef typename _Val_types::size_type size_type;
; 513  : 	typedef typename _Val_types::difference_type difference_type;
; 514  : 	typedef typename _Val_types::pointer pointer;
; 515  : 	typedef typename _Val_types::const_pointer const_pointer;
; 516  : 	typedef typename _Val_types::reference reference;
; 517  : 	typedef typename _Val_types::const_reference const_reference;
; 518  : 
; 519  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 520  : 	typedef _List_iterator<_Myt> iterator;
; 521  : 
; 522  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 523  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 524  : 
; 525  : 	_List_val()
; 526  : 		{	// initialize data
; 527  : 		this->_Myhead = 0;
; 528  : 		this->_Mysize = 0;
; 529  : 		}
; 530  : 
; 531  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 532  : 		{	// return reference to successor pointer in node
; 533  : 		return ((_Nodepref)_Pnode->_Next);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 225  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 226  : 		if (this->_Getcont() == 0
; 227  : 			|| this->_Ptr == 0
; 228  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 229  : 			{	// report error
; 230  : 			_DEBUG_ERROR("list iterator not incrementable");
; 231  : 			_SCL_SECURE_OUT_OF_RANGE;
; 232  : 			}
; 233  : 
; 234  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 235  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 236  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 237  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 238  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 239  : 
; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  00002	8b 00		 mov	 eax, DWORD PTR [eax]
  00004	89 01		 mov	 DWORD PTR [ecx], eax

; 241  : 		return (*this);

  00006	8b c1		 mov	 eax, ecx

; 242  : 		}

  00008	c3		 ret	 0
??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator==, COMDAT
; _this$ = ecx

; 284  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	33 c0		 xor	 eax, eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0000c	0f 94 c0	 sete	 al

; 299  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??0?$_List_alloc@$0A@U?$_List_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_List_alloc@$0A@U?$_List_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC ; std::_List_alloc<0,std::_List_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_List_alloc<0,std::_List_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx

; 700  : 	_List_alloc(const _Alloc& = _Alloc())

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 704  : 
; 705  : 	~_List_alloc() _NOEXCEPT
; 706  : 		{	// destroy head node
; 707  : 		_Freeheadnode(this->_Myhead);
; 708  : 		}
; 709  : 
; 710  : 	void _Change_alloc(const _Alty&)
; 711  : 		{	// replace old allocator
; 712  : 		}
; 713  : 
; 714  : 	void _Swap_alloc(_Myt&)
; 715  : 		{	// swap allocators
; 716  : 		}
; 717  : 
; 718  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 719  : 	_List_alloc(const _Alloc& = _Alloc())
; 720  : 		{	// construct allocators from _Al
; 721  : 		this->_Myhead = _Buyheadnode();
; 722  : 		_TRY_BEGIN
; 723  : 		_Alloc_proxy();
; 724  : 		_CATCH_ALL
; 725  : 		_Freeheadnode(this->_Myhead);
; 726  : 		_RERAISE;
; 727  : 		_CATCH_END
; 728  : 		}
; 729  : 
; 730  : 	~_List_alloc() _NOEXCEPT
; 731  : 		{	// destroy proxy
; 732  : 		_Freeheadnode(this->_Myhead);
; 733  : 		_Free_proxy();
; 734  : 		}
; 735  : 
; 736  : 	void _Change_alloc(const _Alty&)
; 737  : 		{	// replace old allocator
; 738  : 		}
; 739  : 
; 740  : 	void _Swap_alloc(_Myt& _Right)
; 741  : 		{	// swap allocators
; 742  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 743  : 		}
; 744  : 
; 745  : 	void _Alloc_proxy()
; 746  : 		{	// construct proxy from _Alnod
; 747  : 		typename _Alty::template rebind<_Container_proxy>::other
; 748  : 			_Alproxy;
; 749  : 		this->_Myproxy = _Alproxy.allocate(1);
; 750  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 751  : 		this->_Myproxy->_Mycont = this;
; 752  : 		}
; 753  : 
; 754  : 	void _Free_proxy()
; 755  : 		{	// destroy proxy
; 756  : 		typename _Alty::template rebind<_Container_proxy>::other
; 757  : 			_Alproxy;
; 758  : 		this->_Orphan_all();
; 759  : 		_Alproxy.destroy(this->_Myproxy);
; 760  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 761  : 		this->_Myproxy = 0;
; 762  : 		}
; 763  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 764  : 
; 765  : 	_Nodeptr _Buyheadnode()
; 766  : 		{	// get head node using current allocator
; 767  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  00003	6a 00		 push	 0
  00005	6a 00		 push	 0

; 527  : 		this->_Myhead = 0;

  00007	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 528  : 		this->_Mysize = 0;

  0000d	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 704  : 
; 705  : 	~_List_alloc() _NOEXCEPT
; 706  : 		{	// destroy head node
; 707  : 		_Freeheadnode(this->_Myhead);
; 708  : 		}
; 709  : 
; 710  : 	void _Change_alloc(const _Alty&)
; 711  : 		{	// replace old allocator
; 712  : 		}
; 713  : 
; 714  : 	void _Swap_alloc(_Myt&)
; 715  : 		{	// swap allocators
; 716  : 		}
; 717  : 
; 718  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 719  : 	_List_alloc(const _Alloc& = _Alloc())
; 720  : 		{	// construct allocators from _Al
; 721  : 		this->_Myhead = _Buyheadnode();
; 722  : 		_TRY_BEGIN
; 723  : 		_Alloc_proxy();
; 724  : 		_CATCH_ALL
; 725  : 		_Freeheadnode(this->_Myhead);
; 726  : 		_RERAISE;
; 727  : 		_CATCH_END
; 728  : 		}
; 729  : 
; 730  : 	~_List_alloc() _NOEXCEPT
; 731  : 		{	// destroy proxy
; 732  : 		_Freeheadnode(this->_Myhead);
; 733  : 		_Free_proxy();
; 734  : 		}
; 735  : 
; 736  : 	void _Change_alloc(const _Alty&)
; 737  : 		{	// replace old allocator
; 738  : 		}
; 739  : 
; 740  : 	void _Swap_alloc(_Myt& _Right)
; 741  : 		{	// swap allocators
; 742  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 743  : 		}
; 744  : 
; 745  : 	void _Alloc_proxy()
; 746  : 		{	// construct proxy from _Alnod
; 747  : 		typename _Alty::template rebind<_Container_proxy>::other
; 748  : 			_Alproxy;
; 749  : 		this->_Myproxy = _Alproxy.allocate(1);
; 750  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 751  : 		this->_Myproxy->_Mycont = this;
; 752  : 		}
; 753  : 
; 754  : 	void _Free_proxy()
; 755  : 		{	// destroy proxy
; 756  : 		typename _Alty::template rebind<_Container_proxy>::other
; 757  : 			_Alproxy;
; 758  : 		this->_Orphan_all();
; 759  : 		_Alproxy.destroy(this->_Myproxy);
; 760  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 761  : 		this->_Myproxy = 0;
; 762  : 		}
; 763  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 764  : 
; 765  : 	_Nodeptr _Buyheadnode()
; 766  : 		{	// get head node using current allocator
; 767  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  00014	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@PAU32@0@Z ; std::_List_alloc<0,std::_List_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Buynode0

; 701  : 		{	// construct head node, allocator from _Al
; 702  : 		this->_Myhead = _Buyheadnode();

  00019	89 06		 mov	 DWORD PTR [esi], eax

; 703  : 		}

  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	c2 04 00	 ret	 4
??0?$_List_alloc@$0A@U?$_List_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::_List_alloc<0,std::_List_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_List_alloc<0,std::_List_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ?_Freeheadnode@?$_List_alloc@$0A@U?$_List_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEXPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freeheadnode@?$_List_alloc@$0A@U?$_List_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEXPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@@Z PROC ; std::_List_alloc<0,std::_List_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Freeheadnode, COMDAT
; _this$ = ecx

; 771  : 		{	// free head node using current allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Pnode$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 777  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?_Freeheadnode@?$_List_alloc@$0A@U?$_List_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEXPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@@Z ENDP ; std::_List_alloc<0,std::_List_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Freeheadnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ?_Getal@?$_List_alloc@$0A@U?$_List_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_List_alloc@$0A@U?$_List_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@2@XZ PROC ; std::_List_alloc<0,std::_List_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal, COMDAT
; _this$ = ecx

; 803  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 804  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 805  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_List_alloc@$0A@U?$_List_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@2@XZ ENDP ; std::_List_alloc<0,std::_List_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> > >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ?_Myval@?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@@Z PROC ; std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Myval, COMDAT

; 542  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 543  : 		return ((reference)_Pnode->_Myval);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 08	 add	 eax, 8

; 544  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Myval@?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@@Z ENDP ; std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx

; 187  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 44   : 		{	// construct with node pointer _Pnode

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 188  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 39   : 		{	// construct with null node pointer

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 40   : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx

; 124  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 44   : 		{	// construct with node pointer _Pnode

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 125  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ?_Buyheadnode@?$_List_alloc@$0A@U?$_List_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Buyheadnode@?$_List_alloc@$0A@U?$_List_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@XZ PROC ; std::_List_alloc<0,std::_List_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Buyheadnode, COMDAT
; _this$ = ecx

; 767  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  00000	6a 00		 push	 0
  00002	6a 00		 push	 0
  00004	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@PAU32@0@Z ; std::_List_alloc<0,std::_List_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Buynode0

; 768  : 		}

  00009	c3		 ret	 0
?_Buyheadnode@?$_List_alloc@$0A@U?$_List_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@XZ ENDP ; std::_List_alloc<0,std::_List_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Buyheadnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> > >::_Wrap_alloc<std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> > >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> > >::_Wrap_alloc<std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@QAEXPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@QAEXPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@I@Z PROC ; std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> >::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@QAEXPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@I@Z ENDP ; std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??0?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ PROC ; std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 526  : 		{	// initialize data
; 527  : 		this->_Myhead = 0;

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 528  : 		this->_Mysize = 0;
; 529  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c3		 ret	 0
??0?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ ENDP ; std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 44   : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@PAU32@0@Z
_TEXT	SEGMENT
__Next$ = 8						; size = 4
__Prev$ = 12						; size = 4
?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@PAU32@0@Z PROC ; std::_List_alloc<0,std::_List_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Buynode0, COMDAT
; _this$ = ecx

; 781  : 		{	// allocate a node and set links

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00003	6a 20		 push	 32			; 00000020H
  00005	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000a	83 c4 04	 add	 esp, 4
  0000d	85 c0		 test	 eax, eax
  0000f	74 1f		 je	 SHORT $LN76@Buynode0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 784  : 		if (_Next == _Nodeptr())

  00011	8b 4d 08	 mov	 ecx, DWORD PTR __Next$[ebp]
  00014	85 c9		 test	 ecx, ecx
  00016	75 06		 jne	 SHORT $LN74@Buynode0

; 785  : 			{	// point at self
; 786  : 			_Next = _Pnode;

  00018	8b c8		 mov	 ecx, eax

; 787  : 			_Prev = _Pnode;

  0001a	8b d0		 mov	 edx, eax
  0001c	eb 03		 jmp	 SHORT $LN2@Buynode0
$LN74@Buynode0:
  0001e	8b 55 0c	 mov	 edx, DWORD PTR __Prev$[ebp]
$LN2@Buynode0:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00021	89 08		 mov	 DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 538  : 		return ((_Nodepref)_Pnode->_Prev);

  00023	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00026	85 c9		 test	 ecx, ecx
  00028	74 02		 je	 SHORT $LN3@Buynode0
  0002a	89 11		 mov	 DWORD PTR [ecx], edx
$LN3@Buynode0:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 800  : 		}

  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
$LN76@Buynode0:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  00030	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN78@Buynode0:
$LN75@Buynode0:
  00035	cc		 int	 3
?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@PAU32@0@Z ENDP ; std::_List_alloc<0,std::_List_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Buynode0
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@QAE@XZ PROC ; std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> >::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> >, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@QAE@XZ ENDP ; std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> >::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> > >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 19		 je	 SHORT $LN6@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 07	 cmp	 eax, 134217727		; 07ffffffH
  00011	77 18		 ja	 SHORT $LN14@allocate
  00013	c1 e0 05	 shl	 eax, 5
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	74 06		 je	 SHORT $LN14@allocate
$LN6@allocate:

; 847  : 		return (_Mybase::allocate(_Count));

  00025	8b c1		 mov	 eax, ecx

; 848  : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN14@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002b	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN16@allocate:
$LN13@allocate:
  00030	cc		 int	 3
?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@QAEPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@QAEPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@I@Z PROC ; std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> >::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 19		 je	 SHORT $LN4@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 07	 cmp	 eax, 134217727		; 07ffffffH
  00011	77 18		 ja	 SHORT $LN11@allocate
  00013	c1 e0 05	 shl	 eax, 5
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	74 06		 je	 SHORT $LN11@allocate
$LN4@allocate:

; 578  : 		return (_Allocate(_Count, (pointer)0));

  00025	8b c1		 mov	 eax, ecx

; 579  : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN11@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002b	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN13@allocate:
$LN10@allocate:
  00030	cc		 int	 3
?allocate@?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@QAEPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@I@Z ENDP ; std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??$_Insert@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U_Iterator_base0@2@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Insert@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U_Iterator_base0@2@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::list<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Insert<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>, COMDAT
; _this$ = ecx

; 1056 : 		void _Insert(_Unchecked_const_iterator _Where,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 534  : 		}
; 535  : 
; 536  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 537  : 		{	// return reference to predecessor pointer in node
; 538  : 		return ((_Nodepref)_Pnode->_Prev);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Where$[ebp]
  00007	57		 push	 edi

; 1057 : 		_Valty&&... _Val)
; 1058 : 		{	// insert element at _Where
; 1059 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1060 : 		_Nodeptr _Newnode =
; 1061 : 			this->_Buynode(_Pnode, this->_Prevnode(_Pnode),
; 1062 : 				_STD forward<_Valty>(_Val)...);

  00008	ff 75 0c	 push	 DWORD PTR _<_Val_0>$[ebp]
  0000b	8b f9		 mov	 edi, ecx
  0000d	ff 76 04	 push	 DWORD PTR [esi+4]
  00010	56		 push	 esi
  00011	e8 00 00 00 00	 call	 ??$_Buynode@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_buy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@PAU21@0ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_List_buy<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Buynode<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
  00016	8b d0		 mov	 edx, eax

; 1067 : 
; 1068 : 
; 1069 : 	list(_XSTD initializer_list<_Ty> _Ilist,
; 1070 : 		const _Alloc& _Al = allocator_type())
; 1071 : 		: _Mybase(_Al)
; 1072 : 		{	// construct from initializer_list
; 1073 : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 1074 : 		}
; 1075 : 
; 1076 : 	_Myt& operator=(_XSTD initializer_list<_Ty> _Ilist)
; 1077 : 		{	// assign initializer_list
; 1078 : 		assign(_Ilist.begin(), _Ilist.end());
; 1079 : 		return (*this);
; 1080 : 		}
; 1081 : 
; 1082 : 	void assign(_XSTD initializer_list<_Ty> _Ilist)
; 1083 : 		{	// assign initializer_list
; 1084 : 		assign(_Ilist.begin(), _Ilist.end());
; 1085 : 		}
; 1086 : 
; 1087 : 	iterator insert(const_iterator _Where,
; 1088 : 		_XSTD initializer_list<_Ty> _Ilist)
; 1089 : 		{	// insert initializer_list
; 1090 : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 1091 : 		}
; 1092 : 
; 1093 : 	~list() _NOEXCEPT
; 1094 : 		{	// destroy the object
; 1095 : 		_Tidy();
; 1096 : 		}
; 1097 : 
; 1098 : 	_Myt& operator=(const _Myt& _Right)
; 1099 : 		{	// assign _Right
; 1100 : 		if (this != &_Right)
; 1101 : 			{	// different, assign it
; 1102 : 			if (this->_Getal() != _Right._Getal()
; 1103 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1104 : 				{	// change allocator before copying
; 1105 : 				clear();
; 1106 : 				this->_Change_alloc(_Right._Getal());
; 1107 : 				}
; 1108 : 
; 1109 : 			assign(_Right.begin(), _Right.end());
; 1110 : 			}
; 1111 : 		return (*this);
; 1112 : 		}
; 1113 : 
; 1114 : 	iterator begin() _NOEXCEPT
; 1115 : 		{	// return iterator for beginning of mutable sequence
; 1116 : 		return (iterator(this->_Nextnode(this->_Myhead), this));
; 1117 : 		}
; 1118 : 
; 1119 : 	const_iterator begin() const _NOEXCEPT
; 1120 : 		{	// return iterator for beginning of nonmutable sequence
; 1121 : 		return (const_iterator(this->_Nextnode(this->_Myhead), this));
; 1122 : 		}
; 1123 : 
; 1124 : 	iterator end() _NOEXCEPT
; 1125 : 		{	// return iterator for end of mutable sequence
; 1126 : 		return (iterator(this->_Myhead, this));
; 1127 : 		}
; 1128 : 
; 1129 : 	const_iterator end() const _NOEXCEPT
; 1130 : 		{	// return iterator for end of nonmutable sequence
; 1131 : 		return (const_iterator(this->_Myhead, this));
; 1132 : 		}
; 1133 : 
; 1134 : 	_Unchecked_iterator _Unchecked_begin()
; 1135 : 		{	// return iterator for beginning of mutable sequence
; 1136 : 		return (_Unchecked_iterator(this->_Nextnode(this->_Myhead),
; 1137 : 			this));
; 1138 : 		}
; 1139 : 
; 1140 : 	_Unchecked_const_iterator _Unchecked_begin() const
; 1141 : 		{	// return iterator for beginning of nonmutable sequence
; 1142 : 		return (_Unchecked_const_iterator(this->_Nextnode(this->_Myhead),
; 1143 : 			this));
; 1144 : 		}
; 1145 : 
; 1146 : 	_Unchecked_iterator _Unchecked_end()
; 1147 : 		{	// return unchecked iterator for end of mutable sequence
; 1148 : 		return (_Unchecked_iterator(this->_Myhead, this));
; 1149 : 		}
; 1150 : 
; 1151 : 	_Unchecked_const_iterator _Unchecked_end() const
; 1152 : 		{	// return unchecked iterator for end of nonmutable sequence
; 1153 : 		return (_Unchecked_const_iterator(this->_Myhead, this));
; 1154 : 		}
; 1155 : 
; 1156 : 	iterator _Make_iter(const_iterator _Where) const _NOEXCEPT
; 1157 : 		{	// make iterator from const_iterator
; 1158 : 		return (iterator(_Where._Ptr, this));
; 1159 : 		}
; 1160 : 
; 1161 : 	iterator _Make_iter(_Unchecked_const_iterator _Where) const
; 1162 : 		{	// make iterator from _Unchecked_const_iterator
; 1163 : 		return (iterator(_Where._Ptr, this));
; 1164 : 		}
; 1165 : 
; 1166 : 	reverse_iterator rbegin() _NOEXCEPT
; 1167 : 		{	// return iterator for beginning of reversed mutable sequence
; 1168 : 		return (reverse_iterator(end()));
; 1169 : 		}
; 1170 : 
; 1171 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1172 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1173 : 		return (const_reverse_iterator(end()));
; 1174 : 		}
; 1175 : 
; 1176 : 	reverse_iterator rend() _NOEXCEPT
; 1177 : 		{	// return iterator for end of reversed mutable sequence
; 1178 : 		return (reverse_iterator(begin()));
; 1179 : 		}
; 1180 : 
; 1181 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1182 : 		{	// return iterator for end of reversed nonmutable sequence
; 1183 : 		return (const_reverse_iterator(begin()));
; 1184 : 		}
; 1185 : 
; 1186 : 	const_iterator cbegin() const _NOEXCEPT
; 1187 : 		{	// return iterator for beginning of nonmutable sequence
; 1188 : 		return (((const _Myt *)this)->begin());
; 1189 : 		}
; 1190 : 
; 1191 : 	const_iterator cend() const _NOEXCEPT
; 1192 : 		{	// return iterator for end of nonmutable sequence
; 1193 : 		return (((const _Myt *)this)->end());
; 1194 : 		}
; 1195 : 
; 1196 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1197 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1198 : 		return (((const _Myt *)this)->rbegin());
; 1199 : 		}
; 1200 : 
; 1201 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1202 : 		{	// return iterator for end of reversed nonmutable sequence
; 1203 : 		return (((const _Myt *)this)->rend());
; 1204 : 		}
; 1205 : 
; 1206 : 	void resize(size_type _Newsize)
; 1207 : 		{	// determine new length, padding with _Ty() elements as needed
; 1208 : 		if (this->_Mysize < _Newsize)
; 1209 : 			{	// pad to make larger
; 1210 : 			size_type _Count = 0;
; 1211 : 			_TRY_BEGIN
; 1212 : 			for (; this->_Mysize < _Newsize; ++_Count)
; 1213 : 				_Insert(_Unchecked_end());
; 1214 : 			_CATCH_ALL
; 1215 : 			for (; 0 < _Count; --_Count)
; 1216 : 				pop_back();	// undo inserts
; 1217 : 			_RERAISE;
; 1218 : 			_CATCH_END
; 1219 : 			}
; 1220 : 		else
; 1221 : 			while (_Newsize < this->_Mysize)
; 1222 : 				pop_back();
; 1223 : 		}
; 1224 : 
; 1225 : 	void resize(size_type _Newsize, const _Ty& _Val)
; 1226 : 		{	// determine new length, padding with _Val elements as needed
; 1227 : 		if (this->_Mysize < _Newsize)
; 1228 : 			_Insert_n(_Unchecked_end(), _Newsize - this->_Mysize, _Val);
; 1229 : 		else
; 1230 : 			while (_Newsize < this->_Mysize)
; 1231 : 				pop_back();
; 1232 : 		}
; 1233 : 
; 1234 : 	size_type size() const _NOEXCEPT
; 1235 : 		{	// return length of sequence
; 1236 : 		return (this->_Mysize);
; 1237 : 		}
; 1238 : 
; 1239 : 	size_type max_size() const _NOEXCEPT
; 1240 : 		{	// return maximum possible length of sequence
; 1241 : 		return (this->_Getal().max_size());
; 1242 : 		}
; 1243 : 
; 1244 : 	bool empty() const _NOEXCEPT
; 1245 : 		{	// test if sequence is empty
; 1246 : 		return (this->_Mysize == 0);
; 1247 : 		}
; 1248 : 
; 1249 : 	allocator_type get_allocator() const _NOEXCEPT
; 1250 : 		{	// return allocator object for values
; 1251 : 		return (this->_Getal());
; 1252 : 		}
; 1253 : 
; 1254 : 	reference front()
; 1255 : 		{	// return first element of mutable sequence
; 1256 : 		return (*begin());
; 1257 : 		}
; 1258 : 
; 1259 : 	const_reference front() const
; 1260 : 		{	// return first element of nonmutable sequence
; 1261 : 		return (*begin());
; 1262 : 		}
; 1263 : 
; 1264 : 	reference back()
; 1265 : 		{	// return last element of mutable sequence
; 1266 : 		return (*(--end()));
; 1267 : 		}
; 1268 : 
; 1269 : 	const_reference back() const
; 1270 : 		{	// return last element of nonmutable sequence
; 1271 : 		return (*(--end()));
; 1272 : 		}
; 1273 : 
; 1274 : 	void push_front(const _Ty& _Val)
; 1275 : 		{	// insert element at beginning
; 1276 : 		_Insert(_Unchecked_begin(), _Val);
; 1277 : 		}
; 1278 : 
; 1279 : 	void pop_front()
; 1280 : 		{	// erase element at beginning
; 1281 : 		erase(begin());
; 1282 : 		}
; 1283 : 
; 1284 : 	void push_back(const _Ty& _Val)
; 1285 : 		{	// insert element at end
; 1286 : 		_Insert(_Unchecked_end(), _Val);
; 1287 : 		}
; 1288 : 
; 1289 : 	void pop_back()
; 1290 : 		{	// erase element at end
; 1291 : 		erase(--end());
; 1292 : 		}
; 1293 : 
; 1294 : 	template<class _Iter>
; 1295 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1296 : 			void>::type
; 1297 : 		assign(_Iter _First, _Iter _Last)
; 1298 : 		{	// assign [_First, _Last), input iterators
; 1299 : 		iterator _Old = begin();
; 1300 : 		_TRY_BEGIN
; 1301 : 		for (; _First != _Last && _Old != end(); ++_First, ++_Old)
; 1302 : 			_Reusenode(_Old, *_First);
; 1303 : 		for (; _First != _Last; ++_First)
; 1304 : 			_Insert(_Unchecked_end(), *_First);
; 1305 : 		_CATCH_ALL
; 1306 : 		clear();
; 1307 : 		_RERAISE;
; 1308 : 		_CATCH_END
; 1309 : 		erase(_Old, end());
; 1310 : 		}
; 1311 : 
; 1312 : 	template<class _TArg>
; 1313 : 		void _Reusenode(iterator _Where, _TArg&& _Arg)
; 1314 : 		{	// destroy the element at _Where and reconstruct from _Arg
; 1315 : 		_TRY_BEGIN
; 1316 : 		this->_Getal().destroy(
; 1317 : 			_STD addressof(this->_Myval(_Where._Ptr)));
; 1318 : 		this->_Getal().construct(
; 1319 : 			_STD addressof(this->_Myval(_Where._Ptr)),
; 1320 : 			_STD forward<_TArg>(_Arg));
; 1321 : 		_CATCH_ALL
; 1322 : 		_Unlinknode(_Where);
; 1323 : 		this->_Getal().destroy(
; 1324 : 			_STD addressof(this->_Nextnode(_Where._Ptr)));
; 1325 : 		this->_Getal().destroy(
; 1326 : 			_STD addressof(this->_Prevnode(_Where._Ptr)));
; 1327 : 		this->_Getal().deallocate(_Where._Ptr, 1);
; 1328 : 		_RERAISE;
; 1329 : 		_CATCH_END
; 1330 : 		}
; 1331 : 
; 1332 : 	void assign(size_type _Count, const _Ty& _Val)
; 1333 : 		{	// assign _Count * _Val
; 1334 : 		clear();
; 1335 : 		_Insert_n(_Unchecked_begin(), _Count, _Val);
; 1336 : 		}
; 1337 : 
; 1338 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1339 : 		{	// insert _Val at _Where
; 1340 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1341 : 		if (_Where._Getcont() != this)
; 1342 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1343 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1344 : 
; 1345 : 		_Insert(_Where._Unchecked(), _Val);
; 1346 : 		return (_Make_iter(--_Where));
; 1347 : 		}
; 1348 : 
; 1349 : 	iterator insert(const_iterator _Where, size_type _Count, const _Ty& _Val)
; 1350 : 		{	// insert _Count * _Val at _Where
; 1351 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1352 : 		if (_Where._Getcont() != this)
; 1353 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1354 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1355 : 
; 1356 : 		iterator _Prev = _Make_iter(_Where);
; 1357 : 		if (_Prev == begin())
; 1358 : 			{	// insert sequence at beginning
; 1359 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1360 : 			return (begin());
; 1361 : 			}
; 1362 : 		else
; 1363 : 			{	// insert sequence not at beginning
; 1364 : 			--_Prev;
; 1365 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1366 : 			return (++_Prev);
; 1367 : 			}
; 1368 : 		}
; 1369 : 
; 1370 : 	template<class _Iter>
; 1371 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1372 : 			iterator>::type
; 1373 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1374 : 		{	// insert [_First, _Last) at _Where
; 1375 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1376 : 		if (_Where._Getcont() != this)
; 1377 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1378 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1379 : 
; 1380 : 		iterator _Prev = _Make_iter(_Where);
; 1381 : 		if (_Prev == begin())
; 1382 : 			{	// insert sequence at beginning
; 1383 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1384 : 				_Iter_cat(_First));
; 1385 : 			return (begin());
; 1386 : 			}
; 1387 : 		else
; 1388 : 			{	// insert sequence not at beginning
; 1389 : 			--_Prev;
; 1390 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1391 : 				_Iter_cat(_First));
; 1392 : 			return (++_Prev);
; 1393 : 			}
; 1394 : 		}
; 1395 : 
; 1396 : 	template<class _Iter>
; 1397 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1398 : 			_Iter _First, _Iter _Last, input_iterator_tag)
; 1399 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1400 : 		size_type _Num = 0;
; 1401 : 
; 1402 : 		_TRY_BEGIN
; 1403 : 		for (; _First != _Last; ++_First, ++_Num)
; 1404 : 			_Insert(_Where, *_First);
; 1405 : 		_CATCH_ALL
; 1406 : 		for (; 0 < _Num; --_Num)
; 1407 : 			{	// undo inserts
; 1408 : 			_Unchecked_const_iterator _Before = _Where;
; 1409 : 			_Unchecked_erase(--_Before);
; 1410 : 			}
; 1411 : 		_RERAISE;
; 1412 : 		_CATCH_END
; 1413 : 		}
; 1414 : 
; 1415 : 	template<class _Iter>
; 1416 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1417 : 			_Iter _First, _Iter _Last, forward_iterator_tag)
; 1418 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1419 : 		_DEBUG_RANGE(_First, _Last);
; 1420 : 		_Iter _Next = _First;
; 1421 : 
; 1422 : 		_TRY_BEGIN
; 1423 : 		for (; _First != _Last; ++_First)
; 1424 : 			_Insert(_Where, *_First);
; 1425 : 		_CATCH_ALL
; 1426 : 		for (; _Next != _First; ++_Next)
; 1427 : 			{	// undo inserts
; 1428 : 			_Unchecked_const_iterator _Before = _Where;
; 1429 : 			_Unchecked_erase(--_Before);
; 1430 : 			}
; 1431 : 		_RERAISE;
; 1432 : 		_CATCH_END
; 1433 : 		}
; 1434 : 
; 1435 : 	_Nodeptr _Unlinknode(const_iterator _Where)
; 1436 : 		{	// unlink node at _Where from the list
; 1437 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1438 : 		if (_Where._Getcont() != this || _Where._Ptr == this->_Myhead)
; 1439 : 			_DEBUG_ERROR("list erase iterator outside range");
; 1440 : 		_Nodeptr _Pnode = (_Where)._Mynode();
; 1441 : 		_Orphan_ptr(*this, _Pnode);
; 1442 : 
; 1443 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1444 : 		_Nodeptr _Pnode = (_Where)._Mynode();
; 1445 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1446 : 
; 1447 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1448 : 			this->_Nextnode(_Pnode);
; 1449 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1450 : 			this->_Prevnode(_Pnode);
; 1451 : 
; 1452 : 		--this->_Mysize;
; 1453 : 		return (_Pnode);
; 1454 : 		}
; 1455 : 
; 1456 : 	iterator erase(const_iterator _Where)
; 1457 : 		{	// erase element at _Where
; 1458 : 		_Nodeptr _Pnode = _Unlinknode(_Where++);
; 1459 : 		this->_Freenode(_Pnode);
; 1460 : 		return (_Make_iter(_Where));
; 1461 : 		}
; 1462 : 
; 1463 : 	void _Unchecked_erase(_Unchecked_const_iterator _Where)
; 1464 : 		{	// erase element at _Where
; 1465 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1466 : 
; 1467 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1468 : 			this->_Nextnode(_Pnode);
; 1469 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1470 : 			this->_Prevnode(_Pnode);
; 1471 : 		this->_Freenode(_Pnode);
; 1472 : 		--this->_Mysize;
; 1473 : 		}
; 1474 : 
; 1475 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1476 : 		{	// erase [_First, _Last)
; 1477 : 		if (_First == begin() && _Last == end())
; 1478 : 			{	// erase all and return fresh iterator
; 1479 : 			clear();
; 1480 : 			return (end());
; 1481 : 			}
; 1482 : 		else
; 1483 : 			{	// erase subrange
; 1484 : 			while (_First != _Last)
; 1485 : 				_First = erase(_First);
; 1486 : 			return (_Make_iter(_Last));
; 1487 : 			}
; 1488 : 		}
; 1489 : 
; 1490 : 	void clear() _NOEXCEPT
; 1491 : 		{	// erase all
; 1492 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1493 : 		this->_Orphan_ptr(*this, nullptr);
; 1494 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1495 : 
; 1496 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead);
; 1497 : 		this->_Nextnode(this->_Myhead) = this->_Myhead;
; 1498 : 		this->_Prevnode(this->_Myhead) = this->_Myhead;
; 1499 : 		this->_Mysize = 0;
; 1500 : 
; 1501 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead; _Pnode = _Pnext)
; 1502 : 			{	// delete an element
; 1503 : 			_Pnext = this->_Nextnode(_Pnode);
; 1504 : 			this->_Freenode(_Pnode);
; 1505 : 			}
; 1506 : 		}
; 1507 : 
; 1508 : 	void swap(_Myt& _Right)
; 1509 : 		{	// exchange contents with _Right
; 1510 : 		if (this == &_Right)
; 1511 : 			;	// same object, do nothing
; 1512 : 		else if (this->_Getal() == _Right._Getal())
; 1513 : 			{	// same allocator, swap control information
; 1514 : 			this->_Swap_all(_Right);
; 1515 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1516 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1517 : 			}
; 1518 : 
; 1519 : 		else if (_Alty::propagate_on_container_swap::value)
; 1520 : 			{	// swap allocators and control information
; 1521 : 			this->_Swap_alloc(_Right);
; 1522 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1523 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1524 : 			}
; 1525 : 
; 1526 : 		else	// containers are incompatible
; 1527 : 
; 1528 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1529 : 			_DEBUG_ERROR("list containers incompatible for swap");
; 1530 : 
; 1531 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1532 : 			_XSTD terminate();
; 1533 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1534 : 		}
; 1535 : 
; 1536 : 	void splice(const_iterator _Where, _Myt& _Right)
; 1537 : 		{	// splice all of _Right at _Where
; 1538 : 		if (this != &_Right && !_Right.empty())
; 1539 : 			{	// worth splicing, do it
; 1540 : 			_Splice(_Where, _Right, _Right.begin(), _Right.end(),
; 1541 : 				_Right._Mysize);
; 1542 : 			}
; 1543 : 		}
; 1544 : 
; 1545 : 	void splice(const_iterator _Where, _Myt&& _Right)
; 1546 : 		{	// splice all of _Right at _Where
; 1547 : 		splice(_Where, (_Myt&)_Right);
; 1548 : 		}
; 1549 : 
; 1550 : 	void splice(const_iterator _Where, _Myt& _Right,
; 1551 : 		const_iterator _First)
; 1552 : 		{	// splice _Right [_First, _First + 1) at _Where
; 1553 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1554 : 		if (_First == _Right.end())
; 1555 : 			_DEBUG_ERROR("list splice iterator outside range");
; 1556 : 		else
; 1557 : 
; 1558 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1559 : 		if (_First != _Right.end())
; 1560 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1561 : 
; 1562 : 			{	// element exists, try splice
; 1563 : 			const_iterator _Last = _First;
; 1564 : 			++_Last;
; 1565 : 			if (this != &_Right
; 1566 : 				|| (_Where != _First && _Where != _Last))
; 1567 : 				_Splice(_Where, _Right, _First, _Last, 1);
; 1568 : 			}
; 1569 : 		}
; 1570 : 
; 1571 : 	void splice(const_iterator _Where, _Myt&& _Right,
; 1572 : 		const_iterator _First)
; 1573 : 		{	// splice _Right [_First, _First + 1) at _Where
; 1574 : 		splice(_Where, (_Myt&)_Right, _First);
; 1575 : 		}
; 1576 : 
; 1577 : 	void splice(const_iterator _Where,
; 1578 : 		_Myt& _Right, const_iterator _First, const_iterator _Last)
; 1579 : 		{	// splice _Right [_First, _Last) at _Where
; 1580 : 		if (_First != _Last && (this != &_Right || _Where != _Last))
; 1581 : 			{	// worth splicing, do it
; 1582 : 			size_type _Count = 0;
; 1583 : 
; 1584 : 			if (this == &_Right)
; 1585 : 				;	// just rearrange this list
; 1586 : 			else if (_First == _Right.begin() && _Last == _Right.end())
; 1587 : 				_Count = _Right._Mysize;	// splice in whole list
; 1588 : 			else
; 1589 : 				{	// count nodes and check for knot
; 1590 : 				const_iterator _Next = _First;
; 1591 : 
; 1592 : 				for (; _Next != _Last; ++_Next, ++_Count)
; 1593 : 					if (_Next == _Right.end())
; 1594 : 						_Xlength_error("list<T> bad splice");
; 1595 : 				}
; 1596 : 			_Splice(_Where, _Right, _First, _Last, _Count);
; 1597 : 			}
; 1598 : 		}
; 1599 : 
; 1600 : 	void splice(const_iterator _Where,
; 1601 : 		_Myt&& _Right, const_iterator _First, const_iterator _Last)
; 1602 : 		{	// splice _Right [_First, _Last) at _Where
; 1603 : 		splice(_Where, (_Myt&)_Right, _First, _Last);
; 1604 : 		}
; 1605 : 
; 1606 : 	void remove(const _Ty& _Val)
; 1607 : 		{	// erase each element matching _Val
; 1608 : 		iterator _Val_it = end();
; 1609 : 
; 1610 : 		for (iterator _First = begin(); _First != end(); )
; 1611 : 			if (*_First == _Val)
; 1612 : 				if (_STD addressof(*_First) == _STD addressof(_Val))
; 1613 : 					_Val_it = _First++;
; 1614 : 				else
; 1615 : 					_First = erase(_First);
; 1616 : 			else
; 1617 : 				++_First;
; 1618 : 
; 1619 : 		if (_Val_it != end())
; 1620 : 			erase(_Val_it);
; 1621 : 		}
; 1622 : 
; 1623 : 	template<class _Pr1>
; 1624 : 		void remove_if(_Pr1 _Pred)
; 1625 : 		{	// erase each element satisfying _Pred
; 1626 : 		for (iterator _First = begin(); _First != end(); )
; 1627 : 			if (_Pred(*_First))
; 1628 : 				_First = erase(_First);
; 1629 : 			else
; 1630 : 				++_First;
; 1631 : 		}
; 1632 : 
; 1633 : 	void unique()
; 1634 : 		{	// erase each element matching previous
; 1635 : 		unique(equal_to<>());
; 1636 : 		}
; 1637 : 
; 1638 : 	template<class _Pr2>
; 1639 : 		void unique(_Pr2 _Pred)
; 1640 : 		{	// erase each element satisfying _Pred with previous
; 1641 : 		const _Nodeptr _Phead = this->_Myhead;
; 1642 : 		_Nodeptr _Pprev = this->_Nextnode(_Phead);
; 1643 : 		_Nodeptr _Pnode = this->_Nextnode(_Pprev);
; 1644 : 
; 1645 : 		while (_Pnode != _Phead)
; 1646 : 			if (_Pred(_Pprev->_Myval, _Pnode->_Myval))
; 1647 : 				{	// match, remove it
; 1648 : 				const _Nodeptr _Perase = _Pnode;
; 1649 : 				_Pnode = this->_Nextnode(_Pnode);
; 1650 : 
; 1651 : 				this->_Nextnode(_Pprev) = _Pnode;
; 1652 : 				this->_Prevnode(_Pnode) = _Pprev;
; 1653 : 				this->_Freenode(_Perase);
; 1654 : 
; 1655 : 				--this->_Mysize;
; 1656 : 				}
; 1657 : 			else
; 1658 : 				{	// no match, advance
; 1659 : 				_Pprev = _Pnode;
; 1660 : 				_Pnode = this->_Nextnode(_Pnode);
; 1661 : 				}
; 1662 : 		}
; 1663 : 
; 1664 : 	void merge(_Myt& _Right)
; 1665 : 		{	// merge in elements from _Right, both ordered by operator<
; 1666 : 		merge(_Right, less<>());
; 1667 : 		}
; 1668 : 
; 1669 : 	void merge(_Myt&& _Right)
; 1670 : 		{	// merge in elements from _Right, both ordered by operator<
; 1671 : 		merge((_Myt&)_Right);
; 1672 : 		}
; 1673 : 
; 1674 : 	template<class _Pr2>
; 1675 : 		void merge(_Myt& _Right, _Pr2 _Pred)
; 1676 : 		{	// merge in elements from _Right, both ordered by _Pred
; 1677 : 		if (&_Right != this)
; 1678 : 			{	// safe to merge, do it
; 1679 : 			iterator _First1 = begin(), _Last1 = end();
; 1680 : 			iterator _First2 = _Right.begin(), _Last2 = _Right.end();
; 1681 : 			_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 1682 : 			_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 1683 : 
; 1684 : 			while (_First1 != _Last1 && _First2 != _Last2)
; 1685 : 				if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))
; 1686 : 					{	// splice in an element from _Right
; 1687 : 					iterator _Mid2 = _First2;
; 1688 : 					_Splice(_First1, _Right, _First2, ++_Mid2, 1);
; 1689 : 					_First2 = _Mid2;
; 1690 : 					}
; 1691 : 				else
; 1692 : 					++_First1;
; 1693 : 
; 1694 : 			if (_First2 != _Last2)
; 1695 : 				_Splice(_Last1, _Right, _First2, _Last2,
; 1696 : 					_Right._Mysize);	// splice remainder of _Right
; 1697 : 			}
; 1698 : 		}
; 1699 : 
; 1700 : 	template<class _Pr2>
; 1701 : 		void merge(_Myt&& _Right, _Pr2 _Pred)
; 1702 : 		{	// merge in elements from _Right, both ordered by _Pred
; 1703 : 		merge((_Myt&)_Right, _Pred);
; 1704 : 		}
; 1705 : 
; 1706 : 	void sort()
; 1707 : 		{	// order sequence, using operator<
; 1708 : 		sort(less<>());
; 1709 : 		}
; 1710 : 
; 1711 : 	template<class _Pr2>
; 1712 : 		void sort(_Pr2 _Pred)
; 1713 : 		{	// order sequence, using _Pred
; 1714 : 		if (2 <= this->_Mysize)
; 1715 : 			{	// worth sorting, do it
; 1716 : 			const size_t _MAXBINS = 25;
; 1717 : 			_Myt _Templist(this->_Getal()), _Binlist[_MAXBINS + 1];
; 1718 : 			size_t _Maxbin = 0;
; 1719 : 
; 1720 : 			while (!empty())
; 1721 : 				{	// sort another element, using bins
; 1722 : 				_Templist._Splice_same(_Templist.begin(), *this, begin(),
; 1723 : 					++begin(), 1);
; 1724 : 
; 1725 : 				size_t _Bin;
; 1726 : 				for (_Bin = 0; _Bin < _Maxbin && !_Binlist[_Bin].empty();
; 1727 : 					++_Bin)
; 1728 : 					{	// merge into ever larger bins
; 1729 : 					_Binlist[_Bin].merge(_Templist, _Pred);
; 1730 : 					_Binlist[_Bin].swap(_Templist);
; 1731 : 					}
; 1732 : 
; 1733 : 				if (_Bin == _MAXBINS)
; 1734 : 					_Binlist[_Bin - 1].merge(_Templist, _Pred);
; 1735 : 				else
; 1736 : 					{	// spill to new bin, while they last
; 1737 : 					_Binlist[_Bin].swap(_Templist);
; 1738 : 					if (_Bin == _Maxbin)
; 1739 : 						++_Maxbin;
; 1740 : 					}
; 1741 : 				}
; 1742 : 
; 1743 : 			for (size_t _Bin = 1; _Bin < _Maxbin; ++_Bin)
; 1744 : 				_Binlist[_Bin].merge(_Binlist[_Bin - 1],
; 1745 : 					_Pred);	// merge up
; 1746 : 
; 1747 : 			_Analysis_assume_(0 < _Maxbin);
; 1748 : 
; 1749 : 			splice(begin(), _Binlist[_Maxbin - 1]);	// result in last bin
; 1750 : 			}
; 1751 : 		}
; 1752 : 
; 1753 : 	void reverse() _NOEXCEPT
; 1754 : 		{	// reverse sequence
; 1755 : 		const _Nodeptr _Phead = this->_Myhead;
; 1756 : 		_Nodeptr _Pnode = _Phead;
; 1757 : 
; 1758 : 		for (; ; )
; 1759 : 			{	// flip pointers in a node
; 1760 : 			const _Nodeptr _Pnext = this->_Nextnode(_Pnode);
; 1761 : 			this->_Nextnode(_Pnode) = this->_Prevnode(_Pnode);
; 1762 : 			this->_Prevnode(_Pnode) = _Pnext;
; 1763 : 
; 1764 : 			if (_Pnext == _Phead)
; 1765 : 				break;
; 1766 : 			_Pnode = _Pnext;
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	void _Splice(const_iterator _Where,
; 1771 : 		_Myt& _Right, const_iterator _First, const_iterator _Last,
; 1772 : 		size_type _Count)
; 1773 : 		{	// splice _Right [_First, _Last) before _Where
; 1774 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1775 : 		if (_Where._Getcont() != this)
; 1776 : 			_DEBUG_ERROR("list splice iterator outside range");
; 1777 : 		if (this->_Getal() != _Right._Getal())
; 1778 : 			_DEBUG_ERROR("list containers incompatible for splice");
; 1779 : 
; 1780 : 		if (this != &_Right)
; 1781 : 			{	// transfer ownership
; 1782 : 			_Lockit _Lock(_LOCK_DEBUG);
; 1783 : 
; 1784 : 			const bool _One = _Count == 1;
; 1785 : 			const bool _All = _Count == _Right.size();
; 1786 : 			const bool _Some = !_One && !_All;
; 1787 : 
; 1788 : 			_Nodeptr _Oldprev = _First._Ptr->_Prev;
; 1789 : 
; 1790 : 			if (_Some)
; 1791 : 				for (_Nodeptr _Ptr = _First._Ptr; _Ptr != _Last._Ptr;
; 1792 : 					_Ptr = _Ptr->_Next)
; 1793 : 					{	// mark _Prev pointers
; 1794 : 					_Ptr->_Prev = 0;
; 1795 : 					}
; 1796 : 
; 1797 : 			const_iterator **_Pnext = (const_iterator **)_Right._Getpfirst();
; 1798 : 
; 1799 : 			if (_Pnext == 0)
; 1800 : 				_DEBUG_ERROR("list container corrupted");
; 1801 : 
; 1802 : 			while (*_Pnext != 0)
; 1803 : 				{	// check the iterator
; 1804 : 				const_iterator& _Iter = **_Pnext;
; 1805 : 
; 1806 : 				if ((_One && _Iter._Ptr == _First._Ptr)
; 1807 : 					|| (_All && _Iter._Ptr != _Right._Myhead)
; 1808 : 					|| (_Some && _Iter._Ptr->_Prev == 0))
; 1809 : 					{	// adopt the iterator
; 1810 : 					*_Pnext = (const_iterator *)_Iter._Mynextiter;
; 1811 : 					_Iter._Myproxy = this->_Myproxy;
; 1812 : 					_Iter._Mynextiter = this->_Myproxy->_Myfirstiter;
; 1813 : 					this->_Myproxy->_Myfirstiter = &_Iter;
; 1814 : 					}
; 1815 : 				else
; 1816 : 					{	// skip the iterator
; 1817 : 					_Pnext = (const_iterator **)_Iter._Getpnext();
; 1818 : 					}
; 1819 : 				}
; 1820 : 
; 1821 : 			if (_Some)
; 1822 : 				for (_Nodeptr _Ptr = _First._Ptr; _Ptr != _Last._Ptr;
; 1823 : 					_Ptr = _Ptr->_Next)
; 1824 : 					{	// restore _Prev pointers
; 1825 : 					_Ptr->_Prev = _Oldprev;
; 1826 : 					_Oldprev = _Ptr;
; 1827 : 					}
; 1828 : 			}
; 1829 : 
; 1830 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1831 : 		if (this->_Getal() != _Right._Getal())
; 1832 : 			_XSTD terminate();
; 1833 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1834 : 
; 1835 : 		_Splice_same(_Where, _Right, _First, _Last, _Count);
; 1836 : 		}
; 1837 : 
; 1838 : 	void _Splice_same(const_iterator _Where,
; 1839 : 		_Myt& _Right, const_iterator _First, const_iterator _Last,
; 1840 : 		size_type _Count)
; 1841 : 		{	// splice _Right [_First, _Last) before _Where
; 1842 : 		if (this != &_Right)
; 1843 : 			{	// splicing from another list, adjust counts
; 1844 : 			_Incsize(_Count);
; 1845 : 			_Right._Mysize -= _Count;
; 1846 : 			}
; 1847 : 		this->_Nextnode(this->_Prevnode(_First._Mynode())) =
; 1848 : 			_Last._Mynode();
; 1849 : 		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
; 1850 : 			_Where._Mynode();
; 1851 : 		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
; 1852 : 			_First._Mynode();
; 1853 : 
; 1854 : 		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
; 1855 : 		this->_Prevnode(_Where._Mynode()) =
; 1856 : 			this->_Prevnode(_Last._Mynode());
; 1857 : 		this->_Prevnode(_Last._Mynode()) =
; 1858 : 			this->_Prevnode(_First._Mynode());
; 1859 : 		this->_Prevnode(_First._Mynode()) = _Pnode;
; 1860 : 		}
; 1861 : 
; 1862 : 	void _Unchecked_splice(_Unchecked_const_iterator _Where,
; 1863 : 		_Unchecked_const_iterator _First,
; 1864 : 		_Unchecked_const_iterator _Last)
; 1865 : 		{	// splice [_First, _Last) before _Where
; 1866 : 		this->_Nextnode(this->_Prevnode(_First._Mynode())) =
; 1867 : 			_Last._Mynode();
; 1868 : 		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
; 1869 : 			_Where._Mynode();
; 1870 : 		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
; 1871 : 			_First._Mynode();
; 1872 : 
; 1873 : 		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
; 1874 : 		this->_Prevnode(_Where._Mynode()) =
; 1875 : 			this->_Prevnode(_Last._Mynode());
; 1876 : 		this->_Prevnode(_Last._Mynode()) =
; 1877 : 			this->_Prevnode(_First._Mynode());
; 1878 : 		this->_Prevnode(_First._Mynode()) = _Pnode;
; 1879 : 		}
; 1880 : 
; 1881 : 	void _Tidy()
; 1882 : 		{	// free all storage
; 1883 : 		clear();
; 1884 : 		}
; 1885 : 
; 1886 : 	void _Insert_n(_Unchecked_const_iterator _Where,
; 1887 : 		size_type _Count, const _Ty& _Val)
; 1888 : 		{	// insert _Count * _Val at _Where
; 1889 : 		size_type _Countsave = _Count;
; 1890 : 
; 1891 : 		_TRY_BEGIN
; 1892 : 		for (; 0 < _Count; --_Count)
; 1893 : 			_Insert(_Where, _Val);
; 1894 : 		_CATCH_ALL
; 1895 : 		for (; _Count < _Countsave; ++_Count)
; 1896 : 			{	// undo inserts
; 1897 : 			_Unchecked_const_iterator _Before = _Where;
; 1898 : 			_Unchecked_erase(--_Before);
; 1899 : 			}
; 1900 : 		_RERAISE;
; 1901 : 		_CATCH_END
; 1902 : 		}
; 1903 : 
; 1904 : 	void _Incsize(size_type _Count)
; 1905 : 		{	// alter element count, with checking
; 1906 : 		if (max_size() - this->_Mysize - 1 < _Count)

  00018	b9 fe ff ff 07	 mov	 ecx, 134217726		; 07fffffeH
  0001d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00020	2b c8		 sub	 ecx, eax
  00022	83 f9 01	 cmp	 ecx, 1
  00025	72 12		 jb	 SHORT $LN30@Insert

; 1908 : 		this->_Mysize += _Count;

  00027	40		 inc	 eax
  00028	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1063 : 		_Incsize(1);
; 1064 : 		this->_Prevnode(_Pnode) = _Newnode;

  0002b	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 533  : 		return ((_Nodepref)_Pnode->_Next);

  0002e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi

; 1065 : 		this->_Nextnode(this->_Prevnode(_Newnode)) = _Newnode;

  00033	89 10		 mov	 DWORD PTR [eax], edx

; 1066 : 		}

  00035	5d		 pop	 ebp
  00036	c2 08 00	 ret	 8
$LN30@Insert:

; 1907 : 			_Xlength_error("list<T> too long");

  00039	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  0003e	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN32@Insert:
$LN29@Insert:
  00043	cc		 int	 3
??$_Insert@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U_Iterator_base0@2@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::list<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Insert<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@PAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@YAPAPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@YAPAPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@0@AAPAU10@@Z PROC ; std::addressof<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> *>, COMDAT

; 92   : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 96   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@PAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@YAPAPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@0@AAPAU10@@Z ENDP ; std::addressof<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> > >::destroy<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> *>, COMDAT
; _this$ = ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);
; 880  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> > >::destroy<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 877  : 		void destroy(_Ty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0000b	72 0a		 jb	 SHORT $LN30@destroy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0000d	ff 36		 push	 DWORD PTR [esi]
  0000f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00014	83 c4 04	 add	 esp, 4
$LN30@destroy:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00017	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0001e	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00025	c6 06 00	 mov	 BYTE PTR [esi], 0
  00028	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 880  : 		}

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@AAPAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> > >::construct<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> *,std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> * &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@AAPAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> > >::construct<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> *,std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@YAPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@0@IPAU10@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@YAPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@0@IPAU10@@Z PROC ; std::_Allocate<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> >, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 1e		 je	 SHORT $LN2@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 07	 cmp	 eax, 134217727		; 07ffffffH
  00011	77 12		 ja	 SHORT $LN1@Allocate
  00013	c1 e0 05	 shl	 eax, 5
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	75 05		 jne	 SHORT $LN2@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00025	e9 00 00 00 00	 jmp	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN2@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

  0002a	8b c1		 mov	 eax, ecx

; 32   : 	}

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
??$_Allocate@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@YAPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@0@IPAU10@@Z ENDP ; std::_Allocate<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ?_Incsize@?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Incsize@?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z PROC ; std::list<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Incsize, COMDAT
; _this$ = ecx

; 1905 : 		{	// alter element count, with checking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1906 : 		if (max_size() - this->_Mysize - 1 < _Count)

  00003	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00006	b8 fe ff ff 07	 mov	 eax, 134217726		; 07fffffeH
  0000b	56		 push	 esi
  0000c	8b 75 08	 mov	 esi, DWORD PTR __Count$[ebp]
  0000f	2b c2		 sub	 eax, edx
  00011	3b c6		 cmp	 eax, esi
  00013	72 0b		 jb	 SHORT $LN15@Incsize

; 1908 : 		this->_Mysize += _Count;

  00015	8d 04 32	 lea	 eax, DWORD PTR [edx+esi]
  00018	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0001b	5e		 pop	 esi

; 1909 : 		}

  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
$LN15@Incsize:

; 1907 : 			_Xlength_error("list<T> too long");

  00020	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  00025	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN17@Incsize:
$LN14@Incsize:
  0002a	cc		 int	 3
?_Incsize@?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z ENDP ; std::list<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Incsize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 96   : 		return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 97   : 		}

  00002	c3		 ret	 0
?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ?max_size@?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ PROC ; std::list<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size, COMDAT
; _this$ = ecx

; 1241 : 		return (this->_Getal().max_size());

  00000	b8 ff ff ff 07	 mov	 eax, 134217727		; 07ffffffH

; 1242 : 		}

  00005	c3		 ret	 0
?max_size@?$list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ENDP ; std::list<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> > >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (_Mytraits::max_size(*this));

  00000	b8 ff ff ff 07	 mov	 eax, 134217727		; 07ffffffH

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@2@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> > >::max_size, COMDAT

; 735  : 		return (_Al.max_size());

  00000	b8 ff ff ff 07	 mov	 eax, 134217727		; 07ffffffH

; 736  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@2@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@QBEIXZ PROC ; std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> >::max_size, COMDAT
; _this$ = ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 ff ff ff 07	 mov	 eax, 134217727		; 07ffffffH

; 613  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@QBEIXZ ENDP ; std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??$_Buynode@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_buy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@PAU21@0ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
$T2 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ptr$ = 8						; size = 4
__Next$ = 8						; size = 4
__Pnode$ = 12						; size = 4
__Prev$ = 12						; size = 4
_<_Val_0>$ = 16						; size = 4
??$_Buynode@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_buy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@PAU21@0ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_List_buy<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Buynode<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>, COMDAT
; _this$ = ecx

; 827  : 		_Nodeptr _Buynode(_Nodeptr _Next, _Nodeptr _Prev,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Buynode@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_buy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@PAU21@0ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 828  : 			_Valty&&... _Val)
; 829  : 		{	// allocate a node and set links and value
; 830  : 		_Nodeptr _Pnode = this->_Buynode0(_Next, _Prev);

  0002b	ff 75 0c	 push	 DWORD PTR __Prev$[ebp]
  0002e	ff 75 08	 push	 DWORD PTR __Next$[ebp]
  00031	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@2@PAU32@0@Z ; std::_List_alloc<0,std::_List_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Buynode0
  00036	8b f0		 mov	 esi, eax

; 831  : 
; 832  : 		_TRY_BEGIN

  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0003f	89 75 0c	 mov	 DWORD PTR __Pnode$[ebp], esi

; 543  : 		return ((reference)_Pnode->_Myval);

  00042	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]

; 833  : 		this->_Getal().construct(
; 834  : 			_STD addressof(this->_Myval(_Pnode)),
; 835  : 				_STD forward<_Valty>(_Val)...);

  00045	89 4d 08	 mov	 DWORD PTR __Ptr$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00048	89 4d ec	 mov	 DWORD PTR $T2[ebp], ecx
  0004b	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  0004f	85 c9		 test	 ecx, ecx
  00051	74 1d		 je	 SHORT $LN26@Buynode
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 726  : 		assign(_Right, 0, npos);

  00053	6a ff		 push	 -1
  00055	6a 00		 push	 0
  00057	ff 75 10	 push	 DWORD PTR _<_Val_0>$[ebp]

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  0005a	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH

; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00061	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00068	c6 01 00	 mov	 BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 726  : 		assign(_Right, 0, npos);

  0006b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN26@Buynode:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 841  : 		return (_Pnode);

  00070	8b c6		 mov	 eax, esi

; 842  : 		}

  00072	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00075	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007c	59		 pop	 ecx
  0007d	5f		 pop	 edi
  0007e	5e		 pop	 esi
  0007f	5b		 pop	 ebx
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c2 0c 00	 ret	 12			; 0000000cH
__catch$??$_Buynode@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_buy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@PAU21@0ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00086	ff 75 0c	 push	 DWORD PTR __Pnode$[ebp]
  00089	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0008e	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 838  : 		_RERAISE;

  00091	6a 00		 push	 0
  00093	6a 00		 push	 0
  00095	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN83@Buynode:
$LN82@Buynode:
  0009a	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Buynode@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_buy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@PAU21@0ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$2:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Buynode@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_buy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@PAU21@0ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Buynode@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_buy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@PAU21@0ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Buynode@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_List_buy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@PAU21@0ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_List_buy<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Buynode<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@1@PAPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@1@PAPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> > >::destroy<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> *>, COMDAT

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);
; 731  : 		}

  00000	c3		 ret	 0
??$destroy@PAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@1@PAPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> > >::destroy<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator_traits@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator_traits@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 728  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0000b	72 0a		 jb	 SHORT $LN28@destroy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0000d	ff 36		 push	 DWORD PTR [esi]
  0000f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00014	83 c4 04	 add	 esp, 4
$LN28@destroy:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00017	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0001e	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00025	c6 06 00	 mov	 BYTE PTR [esi], 0
  00028	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 731  : 		}

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator_traits@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@YAAAPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@YAAAPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@0@AAPAU10@@Z PROC ; std::forward<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> * &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@YAAAPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@0@AAPAU10@@Z ENDP ; std::forward<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@1@PAPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@AAPAU31@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@1@PAPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@AAPAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> > >::construct<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> *,std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> * &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN7@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@1@PAPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@AAPAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> > >::construct<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> *,std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00023	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c9		 test	 ecx, ecx
  00032	74 1d		 je	 SHORT $LN11@construct
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 726  : 		assign(_Right, 0, npos);

  00034	6a ff		 push	 -1
  00036	6a 00		 push	 0
  00038	ff 75 0c	 push	 DWORD PTR _<_Args_0>$[ebp]

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  0003b	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH

; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00042	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00049	c6 01 00	 mov	 BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 726  : 		assign(_Right, 0, npos);

  0004c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN11@construct:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 873  : 		}

  00051	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00054	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005b	59		 pop	 ecx
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@@Z PROC ; std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> >::destroy<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> *>, COMDAT
; _this$ = ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@@Z ENDP ; std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> >::destroy<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 605  : 		void destroy(_Uty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0000b	72 0a		 jb	 SHORT $LN26@destroy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0000d	ff 36		 push	 DWORD PTR [esi]
  0000f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00014	83 c4 04	 add	 esp, 4
$LN26@destroy:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00017	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0001e	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00025	c6 06 00	 mov	 BYTE PTR [esi], 0
  00028	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 608  : 		}

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@AAPAU21@@Z PROC ; std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> >::construct<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> *,std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> * &>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 601  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@1@AAPAU21@@Z ENDP ; std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> >::construct<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> *,std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator_traits@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV31@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator_traits@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV31@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator_traits@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV31@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00023	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c9		 test	 ecx, ecx
  00032	74 1d		 je	 SHORT $LN7@construct
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 726  : 		assign(_Right, 0, npos);

  00034	6a ff		 push	 -1
  00036	6a 00		 push	 0
  00038	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  0003b	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH

; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00042	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00049	c6 01 00	 mov	 BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 726  : 		assign(_Right, 0, npos);

  0004c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN7@construct:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 724  : 		}

  00051	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00054	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005b	59		 pop	 ecx
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator_traits@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV31@@Z$0:
  00000	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator_traits@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV31@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator_traits@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV31@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator_traits@V?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV31@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z PROC ; std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00023	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c9		 test	 ecx, ecx
  00032	74 1d		 je	 SHORT $LN3@construct
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 726  : 		assign(_Right, 0, npos);

  00034	6a ff		 push	 -1
  00036	6a 00		 push	 0
  00038	ff 75 0c	 push	 DWORD PTR _<_Args_0>$[ebp]

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  0003b	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH

; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00042	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00049	c6 01 00	 mov	 BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 726  : 		assign(_Right, 0, npos);

  0004c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN3@construct:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 601  : 		}

  00051	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00054	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005b	59		 pop	 ecx
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator@U?$_List_node@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAX@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z ENDP ; std::allocator<std::_List_node<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void *> >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
END
