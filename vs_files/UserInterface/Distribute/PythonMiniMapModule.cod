; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	D:\Metin2\Metin2\client_source_clean\client_source_clean\source\UserInterface\PythonMiniMapModule.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CO@JOBACLFH@CPythonMiniMap?3?3Instance?$CI?$CJ?4LoadA@ ; `string'
PUBLIC	??_C@_05BHNEPGFM@isiil?$AA@			; `string'
PUBLIC	??_C@_03LMKNDPCK@bii?$AA@			; `string'
PUBLIC	??_C@_06NGPFBJMH@isiili?$AA@			; `string'
PUBLIC	??_C@_07CNPAFGOE@ScaleUp?$AA@			; `string'
PUBLIC	??_C@_08FMFAIGAB@SetScale?$AA@			; `string'
PUBLIC	??_C@_0P@JDEKHKMA@SetMiniMapSize?$AA@		; `string'
PUBLIC	??_C@_09EHCACONO@ScaleDown?$AA@			; `string'
PUBLIC	??_C@_09IMDAKKFO@LoadAtlas?$AA@			; `string'
PUBLIC	??_C@_06FDNPFPAD@isShow?$AA@			; `string'
PUBLIC	??_C@_0M@KMBFBAJA@RenderAtlas?$AA@		; `string'
PUBLIC	??_C@_0M@EIPBNHOF@UpdateAtlas?$AA@		; `string'
PUBLIC	??_C@_09BIFGHGHO@HideAtlas?$AA@			; `string'
PUBLIC	??_C@_09HNEIIJJD@ShowAtlas?$AA@			; `string'
PUBLIC	??_C@_07IFCOGPLJ@IsAtlas?$AA@			; `string'
PUBLIC	??_C@_0M@DHCMEFOB@isShowAtlas?$AA@		; `string'
PUBLIC	??_C@_0N@ENAKBIJM@GetAtlasSize?$AA@		; `string'
PUBLIC	??_C@_0N@BFFOBNJI@GetAtlasInfo?$AA@		; `string'
PUBLIC	??_C@_0P@BPFHEFHK@RemoveWayPoint?$AA@		; `string'
PUBLIC	??_C@_0M@DMLHJAOH@AddWayPoint?$AA@		; `string'
PUBLIC	??_C@_0BG@BMPPHBMB@UnregisterAtlasWindow?$AA@	; `string'
PUBLIC	??_C@_0BE@DJCJPBHI@RegisterAtlasWindow?$AA@	; `string'
PUBLIC	??_C@_07GGJFLPNN@miniMap?$AA@			; `string'
PUBLIC	??_C@_0P@JOOPKKLO@GetGuildAreaID?$AA@		; `string'
PUBLIC	??_C@_0M@KBKKLFCC@TYPE_OPCPVP?$AA@		; `string'
PUBLIC	??_C@_08MOLNEDKJ@TYPE_OPC?$AA@			; `string'
PUBLIC	??_C@_08HGABCEMM@TYPE_NPC?$AA@			; `string'
PUBLIC	??_C@_0BA@DAENBNGA@TYPE_OPCPVPSELF?$AA@		; `string'
PUBLIC	??_C@_09LAKONOKF@TYPE_WARP?$AA@			; `string'
PUBLIC	??_C@_0N@MFCFPPMD@TYPE_MONSTER?$AA@		; `string'
PUBLIC	??_C@_0L@NHHJIHMA@TYPE_PARTY?$AA@		; `string'
PUBLIC	??_C@_0O@JMCMGHKJ@TYPE_WAYPOINT?$AA@		; `string'
PUBLIC	??_C@_0M@IAHPEAKG@TYPE_EMPIRE?$AA@		; `string'
EXTRN	?PR_ICNV@@3JA:DWORD				; PR_ICNV
EXTRN	?PR_FCNV@@3MA:DWORD				; PR_FCNV
;	COMDAT ?s_methods@?1??initMiniMap@@YAXXZ@4PAUPyMethodDef@@A
_DATA	SEGMENT
?s_methods@?1??initMiniMap@@YAXXZ@4PAUPyMethodDef@@A DD FLAT:??_C@_08FMFAIGAB@SetScale?$AA@ ; `initMiniMap'::`2'::s_methods
	DD	FLAT:?miniMapSetScale@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_07CNPAFGOE@ScaleUp?$AA@
	DD	FLAT:?miniMapScaleUp@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_09EHCACONO@ScaleDown?$AA@
	DD	FLAT:?miniMapScaleDown@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0P@JDEKHKMA@SetMiniMapSize?$AA@
	DD	FLAT:?miniMapSetMiniMapSize@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BC@MCKFCFLJ@SetCenterPosition?$AA@
	DD	FLAT:?miniMapSetCenterPosition@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_07BDCAJABG@Destroy?$AA@
	DD	FLAT:?miniMapDestroy@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_06MIKANEJK@Create?$AA@
	DD	FLAT:?miniMapCreate@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_06LMAGPFNF@Update?$AA@
	DD	FLAT:?miniMapUpdate@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_06EPLDPNDB@Render?$AA@
	DD	FLAT:?miniMapRender@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_04JLAJABDJ@Show?$AA@
	DD	FLAT:?miniMapShow@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_04EACEFPPN@Hide?$AA@
	DD	FLAT:?miniMapHide@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_06FDNPFPAD@isShow?$AA@
	DD	FLAT:?miniMapisShow@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_07NAJNLNAF@GetInfo?$AA@
	DD	FLAT:?miniMapGetInfo@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_09IMDAKKFO@LoadAtlas?$AA@
	DD	FLAT:?miniMapLoadAtlas@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0M@EIPBNHOF@UpdateAtlas?$AA@
	DD	FLAT:?miniMapUpdateAtlas@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0M@KMBFBAJA@RenderAtlas?$AA@
	DD	FLAT:?miniMapRenderAtlas@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_09HNEIIJJD@ShowAtlas?$AA@
	DD	FLAT:?miniMapShowAtlas@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_09BIFGHGHO@HideAtlas?$AA@
	DD	FLAT:?miniMapHideAtlas@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0M@DHCMEFOB@isShowAtlas?$AA@
	DD	FLAT:?miniMapisShowAtlas@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_07IFCOGPLJ@IsAtlas?$AA@
	DD	FLAT:?miniMapIsAtlas@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0N@BFFOBNJI@GetAtlasInfo?$AA@
	DD	FLAT:?miniMapGetAtlasInfo@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0N@ENAKBIJM@GetAtlasSize?$AA@
	DD	FLAT:?miniMapGetAtlasSize@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0M@DMLHJAOH@AddWayPoint?$AA@
	DD	FLAT:?miniMapAddWayPoint@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0P@BPFHEFHK@RemoveWayPoint?$AA@
	DD	FLAT:?miniMapRemoveWayPoint@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BE@DJCJPBHI@RegisterAtlasWindow?$AA@
	DD	FLAT:?miniMapRegisterAtlasWindow@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BG@BMPPHBMB@UnregisterAtlasWindow?$AA@
	DD	FLAT:?miniMapUnregisterAtlasWindow@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0P@JOOPKKLO@GetGuildAreaID?$AA@
	DD	FLAT:?miniMapGetGuildAreaID@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	00H
	DD	00H
	ORG $+8
_DATA	ENDS
;	COMDAT ??_C@_0M@IAHPEAKG@TYPE_EMPIRE?$AA@
CONST	SEGMENT
??_C@_0M@IAHPEAKG@TYPE_EMPIRE?$AA@ DB 'TYPE_EMPIRE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JMCMGHKJ@TYPE_WAYPOINT?$AA@
CONST	SEGMENT
??_C@_0O@JMCMGHKJ@TYPE_WAYPOINT?$AA@ DB 'TYPE_WAYPOINT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NHHJIHMA@TYPE_PARTY?$AA@
CONST	SEGMENT
??_C@_0L@NHHJIHMA@TYPE_PARTY?$AA@ DB 'TYPE_PARTY', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MFCFPPMD@TYPE_MONSTER?$AA@
CONST	SEGMENT
??_C@_0N@MFCFPPMD@TYPE_MONSTER?$AA@ DB 'TYPE_MONSTER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09LAKONOKF@TYPE_WARP?$AA@
CONST	SEGMENT
??_C@_09LAKONOKF@TYPE_WARP?$AA@ DB 'TYPE_WARP', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DAENBNGA@TYPE_OPCPVPSELF?$AA@
CONST	SEGMENT
??_C@_0BA@DAENBNGA@TYPE_OPCPVPSELF?$AA@ DB 'TYPE_OPCPVPSELF', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08HGABCEMM@TYPE_NPC?$AA@
CONST	SEGMENT
??_C@_08HGABCEMM@TYPE_NPC?$AA@ DB 'TYPE_NPC', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08MOLNEDKJ@TYPE_OPC?$AA@
CONST	SEGMENT
??_C@_08MOLNEDKJ@TYPE_OPC?$AA@ DB 'TYPE_OPC', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KBKKLFCC@TYPE_OPCPVP?$AA@
CONST	SEGMENT
??_C@_0M@KBKKLFCC@TYPE_OPCPVP?$AA@ DB 'TYPE_OPCPVP', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JOOPKKLO@GetGuildAreaID?$AA@
CONST	SEGMENT
??_C@_0P@JOOPKKLO@GetGuildAreaID?$AA@ DB 'GetGuildAreaID', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07GGJFLPNN@miniMap?$AA@
CONST	SEGMENT
??_C@_07GGJFLPNN@miniMap?$AA@ DB 'miniMap', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DJCJPBHI@RegisterAtlasWindow?$AA@
CONST	SEGMENT
??_C@_0BE@DJCJPBHI@RegisterAtlasWindow?$AA@ DB 'RegisterAtlasWindow', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@BMPPHBMB@UnregisterAtlasWindow?$AA@
CONST	SEGMENT
??_C@_0BG@BMPPHBMB@UnregisterAtlasWindow?$AA@ DB 'UnregisterAtlasWindow', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DMLHJAOH@AddWayPoint?$AA@
CONST	SEGMENT
??_C@_0M@DMLHJAOH@AddWayPoint?$AA@ DB 'AddWayPoint', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BPFHEFHK@RemoveWayPoint?$AA@
CONST	SEGMENT
??_C@_0P@BPFHEFHK@RemoveWayPoint?$AA@ DB 'RemoveWayPoint', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BFFOBNJI@GetAtlasInfo?$AA@
CONST	SEGMENT
??_C@_0N@BFFOBNJI@GetAtlasInfo?$AA@ DB 'GetAtlasInfo', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@ENAKBIJM@GetAtlasSize?$AA@
CONST	SEGMENT
??_C@_0N@ENAKBIJM@GetAtlasSize?$AA@ DB 'GetAtlasSize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DHCMEFOB@isShowAtlas?$AA@
CONST	SEGMENT
??_C@_0M@DHCMEFOB@isShowAtlas?$AA@ DB 'isShowAtlas', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07IFCOGPLJ@IsAtlas?$AA@
CONST	SEGMENT
??_C@_07IFCOGPLJ@IsAtlas?$AA@ DB 'IsAtlas', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09HNEIIJJD@ShowAtlas?$AA@
CONST	SEGMENT
??_C@_09HNEIIJJD@ShowAtlas?$AA@ DB 'ShowAtlas', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09BIFGHGHO@HideAtlas?$AA@
CONST	SEGMENT
??_C@_09BIFGHGHO@HideAtlas?$AA@ DB 'HideAtlas', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EIPBNHOF@UpdateAtlas?$AA@
CONST	SEGMENT
??_C@_0M@EIPBNHOF@UpdateAtlas?$AA@ DB 'UpdateAtlas', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KMBFBAJA@RenderAtlas?$AA@
CONST	SEGMENT
??_C@_0M@KMBFBAJA@RenderAtlas?$AA@ DB 'RenderAtlas', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06FDNPFPAD@isShow?$AA@
CONST	SEGMENT
??_C@_06FDNPFPAD@isShow?$AA@ DB 'isShow', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09IMDAKKFO@LoadAtlas?$AA@
CONST	SEGMENT
??_C@_09IMDAKKFO@LoadAtlas?$AA@ DB 'LoadAtlas', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09EHCACONO@ScaleDown?$AA@
CONST	SEGMENT
??_C@_09EHCACONO@ScaleDown?$AA@ DB 'ScaleDown', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JDEKHKMA@SetMiniMapSize?$AA@
CONST	SEGMENT
??_C@_0P@JDEKHKMA@SetMiniMapSize?$AA@ DB 'SetMiniMapSize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08FMFAIGAB@SetScale?$AA@
CONST	SEGMENT
??_C@_08FMFAIGAB@SetScale?$AA@ DB 'SetScale', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07CNPAFGOE@ScaleUp?$AA@
CONST	SEGMENT
??_C@_07CNPAFGOE@ScaleUp?$AA@ DB 'ScaleUp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06NGPFBJMH@isiili?$AA@
CONST	SEGMENT
??_C@_06NGPFBJMH@isiili?$AA@ DB 'isiili', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03LMKNDPCK@bii?$AA@
CONST	SEGMENT
??_C@_03LMKNDPCK@bii?$AA@ DB 'bii', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05BHNEPGFM@isiil?$AA@
CONST	SEGMENT
??_C@_05BHNEPGFM@isiil?$AA@ DB 'isiil', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@JOBACLFH@CPythonMiniMap?3?3Instance?$CI?$CJ?4LoadA@
CONST	SEGMENT
??_C@_0CO@JOBACLFH@CPythonMiniMap?3?3Instance?$CI?$CJ?4LoadA@ DB 'CPython'
	DB	'MiniMap::Instance().LoadAtlas() Failed', 00H ; `string'
PUBLIC	?initMiniMap@@YAXXZ				; initMiniMap
PUBLIC	?miniMapGetGuildAreaID@@YAPAU_object@@PAU1@0@Z	; miniMapGetGuildAreaID
PUBLIC	?miniMapUnregisterAtlasWindow@@YAPAU_object@@PAU1@0@Z ; miniMapUnregisterAtlasWindow
PUBLIC	?miniMapRegisterAtlasWindow@@YAPAU_object@@PAU1@0@Z ; miniMapRegisterAtlasWindow
PUBLIC	?miniMapRemoveWayPoint@@YAPAU_object@@PAU1@0@Z	; miniMapRemoveWayPoint
PUBLIC	?miniMapAddWayPoint@@YAPAU_object@@PAU1@0@Z	; miniMapAddWayPoint
PUBLIC	?miniMapGetAtlasSize@@YAPAU_object@@PAU1@0@Z	; miniMapGetAtlasSize
PUBLIC	?miniMapGetAtlasInfo@@YAPAU_object@@PAU1@0@Z	; miniMapGetAtlasInfo
PUBLIC	?miniMapIsAtlas@@YAPAU_object@@PAU1@0@Z		; miniMapIsAtlas
PUBLIC	?miniMapisShowAtlas@@YAPAU_object@@PAU1@0@Z	; miniMapisShowAtlas
PUBLIC	?miniMapHideAtlas@@YAPAU_object@@PAU1@0@Z	; miniMapHideAtlas
PUBLIC	?miniMapShowAtlas@@YAPAU_object@@PAU1@0@Z	; miniMapShowAtlas
PUBLIC	?miniMapRenderAtlas@@YAPAU_object@@PAU1@0@Z	; miniMapRenderAtlas
PUBLIC	?miniMapUpdateAtlas@@YAPAU_object@@PAU1@0@Z	; miniMapUpdateAtlas
PUBLIC	?miniMapLoadAtlas@@YAPAU_object@@PAU1@0@Z	; miniMapLoadAtlas
PUBLIC	?miniMapGetInfo@@YAPAU_object@@PAU1@0@Z		; miniMapGetInfo
PUBLIC	?miniMapScaleDown@@YAPAU_object@@PAU1@0@Z	; miniMapScaleDown
PUBLIC	?miniMapScaleUp@@YAPAU_object@@PAU1@0@Z		; miniMapScaleUp
PUBLIC	?miniMapisShow@@YAPAU_object@@PAU1@0@Z		; miniMapisShow
PUBLIC	?miniMapHide@@YAPAU_object@@PAU1@0@Z		; miniMapHide
PUBLIC	?miniMapShow@@YAPAU_object@@PAU1@0@Z		; miniMapShow
PUBLIC	?miniMapRender@@YAPAU_object@@PAU1@0@Z		; miniMapRender
PUBLIC	?miniMapUpdate@@YAPAU_object@@PAU1@0@Z		; miniMapUpdate
PUBLIC	?miniMapCreate@@YAPAU_object@@PAU1@0@Z		; miniMapCreate
PUBLIC	?miniMapDestroy@@YAPAU_object@@PAU1@0@Z		; miniMapDestroy
PUBLIC	?miniMapSetMiniMapSize@@YAPAU_object@@PAU1@0@Z	; miniMapSetMiniMapSize
PUBLIC	?miniMapSetCenterPosition@@YAPAU_object@@PAU1@0@Z ; miniMapSetCenterPosition
PUBLIC	?miniMapSetScale@@YAPAU_object@@PAU1@0@Z	; miniMapSetScale
	ALIGN	4

_piecewise_construct DB 01H DUP (?)
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?miniMapGetInfo@@YAPAU_object@@PAU1@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?miniMapGetInfo@@YAPAU_object@@PAU1@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?miniMapGetInfo@@YAPAU_object@@PAU1@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?miniMapGetInfo@@YAPAU_object@@PAU1@0@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?miniMapGetAtlasInfo@@YAPAU_object@@PAU1@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?miniMapGetAtlasInfo@@YAPAU_object@@PAU1@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?miniMapGetAtlasInfo@@YAPAU_object@@PAU1@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?miniMapGetAtlasInfo@@YAPAU_object@@PAU1@0@Z$0
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonminimapmodule.cpp
;	COMDAT ?miniMapSetScale@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_fScale$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?miniMapSetScale@@YAPAU_object@@PAU1@0@Z PROC		; miniMapSetScale, COMDAT

; 5    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 6    : 	float fScale;
; 7    : 	if (!PyTuple_GetFloat(poArgs, 0, &fScale))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _fScale$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetFloat@@YA_NPAU_object@@HPAM@Z ; PyTuple_GetFloat
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@miniMapSet

; 8    : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 12   : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@miniMapSet:

; 9    : 
; 10   : 	CPythonMiniMap::Instance().SetScale(fScale);

  00027	f3 0f 10 4d fc	 movss	 xmm1, DWORD PTR _fScale$[ebp]
  0002c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMiniMap@@@@0PAVCPythonMiniMap@@A ; CSingleton<CPythonMiniMap>::ms_singleton
  00032	e8 00 00 00 00	 call	 ?SetScale@CPythonMiniMap@@QAEXM@Z ; CPythonMiniMap::SetScale

; 11   : 	return Py_BuildNone();

  00037	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 12   : }

  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?miniMapSetScale@@YAPAU_object@@PAU1@0@Z ENDP		; miniMapSetScale
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonminimapmodule.cpp
;	COMDAT ?miniMapSetCenterPosition@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_fCenterX$ = -8						; size = 4
_fCenterY$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?miniMapSetCenterPosition@@YAPAU_object@@PAU1@0@Z PROC	; miniMapSetCenterPosition, COMDAT

; 15   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 16   : 	float fCenterX;
; 17   : 	if (!PyTuple_GetFloat(poArgs, 0, &fCenterX))

  00006	8d 45 f8	 lea	 eax, DWORD PTR _fCenterX$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetFloat@@YA_NPAU_object@@HPAM@Z ; PyTuple_GetFloat
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 0e		 jne	 SHORT $LN2@miniMapSet
$LN7@miniMapSet:

; 18   : 		return Py_BuildException();

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00022	83 c4 04	 add	 esp, 4

; 26   : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN2@miniMapSet:

; 19   : 	
; 20   : 	float fCenterY;
; 21   : 	if (!PyTuple_GetFloat(poArgs, 1, &fCenterY))

  00029	8d 45 fc	 lea	 eax, DWORD PTR _fCenterY$[ebp]
  0002c	50		 push	 eax
  0002d	6a 01		 push	 1
  0002f	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  00032	e8 00 00 00 00	 call	 ?PyTuple_GetFloat@@YA_NPAU_object@@HPAM@Z ; PyTuple_GetFloat
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	84 c0		 test	 al, al
  0003c	74 dd		 je	 SHORT $LN7@miniMapSet

; 22   : 		return Py_BuildException();
; 23   : 	
; 24   : 	CPythonMiniMap::Instance().SetCenterPosition(fCenterX, fCenterY);

  0003e	f3 0f 10 55 fc	 movss	 xmm2, DWORD PTR _fCenterY$[ebp]
  00043	f3 0f 10 4d f8	 movss	 xmm1, DWORD PTR _fCenterX$[ebp]
  00048	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMiniMap@@@@0PAVCPythonMiniMap@@A ; CSingleton<CPythonMiniMap>::ms_singleton
  0004e	e8 00 00 00 00	 call	 ?SetCenterPosition@CPythonMiniMap@@QAEXMM@Z ; CPythonMiniMap::SetCenterPosition

; 25   : 	return Py_BuildNone();

  00053	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 26   : }

  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
?miniMapSetCenterPosition@@YAPAU_object@@PAU1@0@Z ENDP	; miniMapSetCenterPosition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonminimapmodule.cpp
;	COMDAT ?miniMapSetMiniMapSize@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_fWidth$ = -8						; size = 4
_fHeight$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?miniMapSetMiniMapSize@@YAPAU_object@@PAU1@0@Z PROC	; miniMapSetMiniMapSize, COMDAT

; 30   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 31   : 	float fWidth;
; 32   : 	if (!PyTuple_GetFloat(poArgs, 0, &fWidth))

  00006	8d 45 f8	 lea	 eax, DWORD PTR _fWidth$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetFloat@@YA_NPAU_object@@HPAM@Z ; PyTuple_GetFloat
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 0e		 jne	 SHORT $LN2@miniMapSet
$LN7@miniMapSet:

; 33   : 		return Py_BuildException();

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00022	83 c4 04	 add	 esp, 4

; 41   : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN2@miniMapSet:

; 34   : 
; 35   : 	float fHeight;
; 36   : 	if (!PyTuple_GetFloat(poArgs, 1, &fHeight))

  00029	8d 45 fc	 lea	 eax, DWORD PTR _fHeight$[ebp]
  0002c	50		 push	 eax
  0002d	6a 01		 push	 1
  0002f	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  00032	e8 00 00 00 00	 call	 ?PyTuple_GetFloat@@YA_NPAU_object@@HPAM@Z ; PyTuple_GetFloat
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	84 c0		 test	 al, al
  0003c	74 dd		 je	 SHORT $LN7@miniMapSet

; 37   : 		return Py_BuildException();
; 38   : 
; 39   : 	CPythonMiniMap::Instance().SetMiniMapSize(fWidth, fHeight);

  0003e	f3 0f 10 55 fc	 movss	 xmm2, DWORD PTR _fHeight$[ebp]
  00043	f3 0f 10 4d f8	 movss	 xmm1, DWORD PTR _fWidth$[ebp]
  00048	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMiniMap@@@@0PAVCPythonMiniMap@@A ; CSingleton<CPythonMiniMap>::ms_singleton
  0004e	e8 00 00 00 00	 call	 ?SetMiniMapSize@CPythonMiniMap@@QAEXMM@Z ; CPythonMiniMap::SetMiniMapSize

; 40   : 	return Py_BuildNone();

  00053	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 41   : }

  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
?miniMapSetMiniMapSize@@YAPAU_object@@PAU1@0@Z ENDP	; miniMapSetMiniMapSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonminimapmodule.cpp
;	COMDAT ?miniMapDestroy@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?miniMapDestroy@@YAPAU_object@@PAU1@0@Z PROC		; miniMapDestroy, COMDAT

; 45   : 	CPythonMiniMap::Instance().Destroy();

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMiniMap@@@@0PAVCPythonMiniMap@@A ; CSingleton<CPythonMiniMap>::ms_singleton
  00006	e8 00 00 00 00	 call	 ?Destroy@CPythonMiniMap@@QAEXXZ ; CPythonMiniMap::Destroy

; 46   : 	return Py_BuildNone();

  0000b	e9 00 00 00 00	 jmp	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
?miniMapDestroy@@YAPAU_object@@PAU1@0@Z ENDP		; miniMapDestroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonminimapmodule.cpp
;	COMDAT ?miniMapCreate@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?miniMapCreate@@YAPAU_object@@PAU1@0@Z PROC		; miniMapCreate, COMDAT

; 51   : 	CPythonMiniMap::Instance().Create();

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMiniMap@@@@0PAVCPythonMiniMap@@A ; CSingleton<CPythonMiniMap>::ms_singleton
  00006	e8 00 00 00 00	 call	 ?Create@CPythonMiniMap@@QAE_NXZ ; CPythonMiniMap::Create

; 52   : 	return Py_BuildNone();

  0000b	e9 00 00 00 00	 jmp	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
?miniMapCreate@@YAPAU_object@@PAU1@0@Z ENDP		; miniMapCreate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonminimapmodule.cpp
;	COMDAT ?miniMapUpdate@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_fCenterX$ = -8						; size = 4
_fCenterY$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?miniMapUpdate@@YAPAU_object@@PAU1@0@Z PROC		; miniMapUpdate, COMDAT

; 56   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 57   : 	float fCenterX;
; 58   : 	if (!PyTuple_GetFloat(poArgs, 0, &fCenterX))

  00006	8d 45 f8	 lea	 eax, DWORD PTR _fCenterX$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetFloat@@YA_NPAU_object@@HPAM@Z ; PyTuple_GetFloat
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 0e		 jne	 SHORT $LN2@miniMapUpd
$LN7@miniMapUpd:

; 59   : 		return Py_BuildException();

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00022	83 c4 04	 add	 esp, 4

; 67   : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN2@miniMapUpd:

; 60   : 
; 61   : 	float fCenterY;
; 62   : 	if (!PyTuple_GetFloat(poArgs, 1, &fCenterY))

  00029	8d 45 fc	 lea	 eax, DWORD PTR _fCenterY$[ebp]
  0002c	50		 push	 eax
  0002d	6a 01		 push	 1
  0002f	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  00032	e8 00 00 00 00	 call	 ?PyTuple_GetFloat@@YA_NPAU_object@@HPAM@Z ; PyTuple_GetFloat
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	84 c0		 test	 al, al
  0003c	74 dd		 je	 SHORT $LN7@miniMapUpd

; 63   : 		return Py_BuildException();
; 64   : 
; 65   : 	CPythonMiniMap::Instance().Update(fCenterX, fCenterY);

  0003e	f3 0f 10 55 fc	 movss	 xmm2, DWORD PTR _fCenterY$[ebp]
  00043	f3 0f 10 4d f8	 movss	 xmm1, DWORD PTR _fCenterX$[ebp]
  00048	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMiniMap@@@@0PAVCPythonMiniMap@@A ; CSingleton<CPythonMiniMap>::ms_singleton
  0004e	e8 00 00 00 00	 call	 ?Update@CPythonMiniMap@@QAEXMM@Z ; CPythonMiniMap::Update

; 66   : 	return Py_BuildNone();

  00053	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 67   : }

  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
?miniMapUpdate@@YAPAU_object@@PAU1@0@Z ENDP		; miniMapUpdate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonminimapmodule.cpp
;	COMDAT ?miniMapRender@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_fScrrenX$ = -8						; size = 4
_fScrrenY$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?miniMapRender@@YAPAU_object@@PAU1@0@Z PROC		; miniMapRender, COMDAT

; 70   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 71   : 	float fScrrenX;
; 72   : 	if (!PyTuple_GetFloat(poArgs, 0, &fScrrenX))

  00006	8d 45 f8	 lea	 eax, DWORD PTR _fScrrenX$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetFloat@@YA_NPAU_object@@HPAM@Z ; PyTuple_GetFloat
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 0e		 jne	 SHORT $LN2@miniMapRen
$LN7@miniMapRen:

; 73   : 		return Py_BuildException();

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00022	83 c4 04	 add	 esp, 4

; 81   : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN2@miniMapRen:

; 74   : 
; 75   : 	float fScrrenY;
; 76   : 	if (!PyTuple_GetFloat(poArgs, 1, &fScrrenY))

  00029	8d 45 fc	 lea	 eax, DWORD PTR _fScrrenY$[ebp]
  0002c	50		 push	 eax
  0002d	6a 01		 push	 1
  0002f	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  00032	e8 00 00 00 00	 call	 ?PyTuple_GetFloat@@YA_NPAU_object@@HPAM@Z ; PyTuple_GetFloat
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	84 c0		 test	 al, al
  0003c	74 dd		 je	 SHORT $LN7@miniMapRen

; 77   : 		return Py_BuildException();
; 78   : 
; 79   : 	CPythonMiniMap::Instance().Render(fScrrenX, fScrrenY);

  0003e	f3 0f 10 55 fc	 movss	 xmm2, DWORD PTR _fScrrenY$[ebp]
  00043	f3 0f 10 4d f8	 movss	 xmm1, DWORD PTR _fScrrenX$[ebp]
  00048	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMiniMap@@@@0PAVCPythonMiniMap@@A ; CSingleton<CPythonMiniMap>::ms_singleton
  0004e	e8 00 00 00 00	 call	 ?Render@CPythonMiniMap@@QAEXMM@Z ; CPythonMiniMap::Render

; 80   : 	return Py_BuildNone();

  00053	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 81   : }

  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
?miniMapRender@@YAPAU_object@@PAU1@0@Z ENDP		; miniMapRender
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonminimapmodule.cpp
;	COMDAT ?miniMapShow@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?miniMapShow@@YAPAU_object@@PAU1@0@Z PROC		; miniMapShow, COMDAT

; 85   : 	CPythonMiniMap::Instance().Show();

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMiniMap@@@@0PAVCPythonMiniMap@@A ; CSingleton<CPythonMiniMap>::ms_singleton
  00006	e8 00 00 00 00	 call	 ?Show@CPythonMiniMap@@QAEXXZ ; CPythonMiniMap::Show

; 86   : 	return Py_BuildNone();

  0000b	e9 00 00 00 00	 jmp	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
?miniMapShow@@YAPAU_object@@PAU1@0@Z ENDP		; miniMapShow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonminimapmodule.cpp
;	COMDAT ?miniMapHide@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?miniMapHide@@YAPAU_object@@PAU1@0@Z PROC		; miniMapHide, COMDAT

; 91   : 	CPythonMiniMap::Instance().Hide();

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMiniMap@@@@0PAVCPythonMiniMap@@A ; CSingleton<CPythonMiniMap>::ms_singleton
  00006	e8 00 00 00 00	 call	 ?Hide@CPythonMiniMap@@QAEXXZ ; CPythonMiniMap::Hide

; 92   : 	return Py_BuildNone();

  0000b	e9 00 00 00 00	 jmp	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
?miniMapHide@@YAPAU_object@@PAU1@0@Z ENDP		; miniMapHide
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonminimapmodule.cpp
;	COMDAT ?miniMapisShow@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?miniMapisShow@@YAPAU_object@@PAU1@0@Z PROC		; miniMapisShow, COMDAT

; 97   : 	bool bShow = CPythonMiniMap::Instance().CanShow();

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMiniMap@@@@0PAVCPythonMiniMap@@A ; CSingleton<CPythonMiniMap>::ms_singleton
  00006	e8 00 00 00 00	 call	 ?CanShow@CPythonMiniMap@@QAE_NXZ ; CPythonMiniMap::CanShow

; 98   : 	return Py_BuildValue("b", bShow);

  0000b	0f b6 c0	 movzx	 eax, al
  0000e	50		 push	 eax
  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_01OJONOECF@b?$AA@
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0001a	83 c4 08	 add	 esp, 8

; 99   : }

  0001d	c3		 ret	 0
?miniMapisShow@@YAPAU_object@@PAU1@0@Z ENDP		; miniMapisShow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonminimapmodule.cpp
;	COMDAT ?miniMapScaleUp@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?miniMapScaleUp@@YAPAU_object@@PAU1@0@Z PROC		; miniMapScaleUp, COMDAT

; 103  : 	CPythonMiniMap::Instance().ScaleUp();

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMiniMap@@@@0PAVCPythonMiniMap@@A ; CSingleton<CPythonMiniMap>::ms_singleton
  00006	e8 00 00 00 00	 call	 ?ScaleUp@CPythonMiniMap@@QAEXXZ ; CPythonMiniMap::ScaleUp

; 104  : 	return Py_BuildNone();

  0000b	e9 00 00 00 00	 jmp	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
?miniMapScaleUp@@YAPAU_object@@PAU1@0@Z ENDP		; miniMapScaleUp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonminimapmodule.cpp
;	COMDAT ?miniMapScaleDown@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?miniMapScaleDown@@YAPAU_object@@PAU1@0@Z PROC		; miniMapScaleDown, COMDAT

; 109  : 	CPythonMiniMap::Instance().ScaleDown();

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMiniMap@@@@0PAVCPythonMiniMap@@A ; CSingleton<CPythonMiniMap>::ms_singleton
  00006	e8 00 00 00 00	 call	 ?ScaleDown@CPythonMiniMap@@QAEXXZ ; CPythonMiniMap::ScaleDown

; 110  : 	return Py_BuildNone();

  0000b	e9 00 00 00 00	 jmp	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
?miniMapScaleDown@@YAPAU_object@@PAU1@0@Z ENDP		; miniMapScaleDown
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonminimapmodule.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonminimapmodule.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonminimapmodule.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonminimapmodule.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonminimapmodule.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonminimapmodule.cpp
;	COMDAT ?miniMapGetInfo@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_fPosX$ = -64						; size = 4
_fPosY$ = -60						; size = 4
_fScrrenX$ = -56					; size = 4
_dwTextColor$ = -52					; size = 4
_fScrrenY$ = -48					; size = 4
_aString$ = -44						; size = 24
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?miniMapGetInfo@@YAPAU_object@@PAU1@0@Z PROC		; miniMapGetInfo, COMDAT

; 114  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?miniMapGetInfo@@YAPAU_object@@PAU1@0@Z
  0000d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00013	50		 push	 eax
  00014	83 ec 34	 sub	 esp, 52			; 00000034H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c4		 xor	 eax, esp
  0001e	89 44 24 2c	 mov	 DWORD PTR __$ArrayPad$[esp+64], eax
  00022	53		 push	 ebx
  00023	56		 push	 esi
  00024	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00029	33 c4		 xor	 eax, esp
  0002b	50		 push	 eax
  0002c	8d 44 24 40	 lea	 eax, DWORD PTR __$EHRec$[esp+76]
  00030	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00036	8b 75 0c	 mov	 esi, DWORD PTR _poArgs$[ebp]

; 115  : 	float fScrrenX;
; 116  : 	if (!PyTuple_GetFloat(poArgs, 0, &fScrrenX))

  00039	8d 44 24 14	 lea	 eax, DWORD PTR _fScrrenX$[esp+76]
  0003d	50		 push	 eax
  0003e	6a 00		 push	 0
  00040	56		 push	 esi
  00041	e8 00 00 00 00	 call	 ?PyTuple_GetFloat@@YA_NPAU_object@@HPAM@Z ; PyTuple_GetFloat
  00046	83 c4 0c	 add	 esp, 12			; 0000000cH
  00049	84 c0		 test	 al, al
  0004b	75 0f		 jne	 SHORT $LN2@miniMapGet
$LN91@miniMapGet:

; 117  : 		return Py_BuildException();

  0004d	6a 00		 push	 0
  0004f	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00054	83 c4 04	 add	 esp, 4
  00057	e9 20 01 00 00	 jmp	 $LN3@miniMapGet
$LN2@miniMapGet:

; 118  : 	
; 119  : 	float fScrrenY;
; 120  : 	if (!PyTuple_GetFloat(poArgs, 1, &fScrrenY))

  0005c	8d 44 24 1c	 lea	 eax, DWORD PTR _fScrrenY$[esp+76]
  00060	50		 push	 eax
  00061	6a 01		 push	 1
  00063	56		 push	 esi
  00064	e8 00 00 00 00	 call	 ?PyTuple_GetFloat@@YA_NPAU_object@@HPAM@Z ; PyTuple_GetFloat
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006c	84 c0		 test	 al, al
  0006e	74 dd		 je	 SHORT $LN91@miniMapGet
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00070	c7 44 24 34 0f
	00 00 00	 mov	 DWORD PTR _aString$[esp+96], 15 ; 0000000fH

; 521  : 		}
; 522  : 
; 523  : 	union _Bxty
; 524  : 		{	// storage for small buffer or pointer to larger one
; 525  : 		value_type _Buf[_BUF_SIZE];
; 526  : 		pointer _Ptr;
; 527  : 		char _Alias[_BUF_SIZE];	// to permit aliasing
; 528  : 		} _Bx;
; 529  : 
; 530  : 	size_type _Mysize;	// current length of string
; 531  : 	size_type _Myres;	// current storage reserved for string
; 532  : 	};
; 533  : 
; 534  : 		// TEMPLATE CLASS _String_alloc
; 535  : template<bool _Al_has_storage,
; 536  : 	class _Alloc_types>
; 537  : 	class _String_alloc
; 538  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 539  : 	{	// base class for basic_string to hold allocator with storage
; 540  : public:
; 541  : 	typename _Alloc_types::_Alty _Alval;	// allocator object
; 542  : 
; 543  : 	typedef _String_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 544  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 545  : 	typedef typename _Alloc_types::_Alty _Alty;
; 546  : 
; 547  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 548  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 549  : 		: _Alval(_Al)
; 550  : 		{	// construct allocator from _Al
; 551  : 		}
; 552  : 
; 553  : 	void _Change_alloc(const _Alty& _Al)
; 554  : 		{	// replace old allocator
; 555  : 		this->_Alval = _Al;
; 556  : 		}
; 557  : 
; 558  : 	void _Swap_alloc(_Myt& _Right)
; 559  : 		{	// swap allocators
; 560  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 561  : 		}
; 562  : 
; 563  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 564  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 565  : 		: _Alval(_Al)
; 566  : 		{	// construct allocator from _Al
; 567  : 		_Alloc_proxy();
; 568  : 		}
; 569  : 
; 570  : 	~_String_alloc() _NOEXCEPT
; 571  : 		{	// destroy the object
; 572  : 		_Free_proxy();
; 573  : 		}
; 574  : 
; 575  : 	void _Change_alloc(const _Alty& _Al)
; 576  : 		{	// replace old allocator
; 577  : 		_Free_proxy();
; 578  : 		this->_Alval = _Al;
; 579  : 		_Alloc_proxy();
; 580  : 		}
; 581  : 
; 582  : 	void _Swap_alloc(_Myt& _Right)
; 583  : 		{	// swap allocators
; 584  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 585  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 586  : 		}
; 587  : 
; 588  : 	void _Alloc_proxy()
; 589  : 		{	// construct proxy from _Alval
; 590  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 591  : 			_Alproxy(this->_Alval);
; 592  : 		this->_Myproxy = _Alproxy.allocate(1);
; 593  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 594  : 		this->_Myproxy->_Mycont = this;
; 595  : 		}
; 596  : 
; 597  : 	void _Free_proxy()
; 598  : 		{	// destroy proxy
; 599  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 600  : 			_Alproxy(this->_Alval);
; 601  : 		this->_Orphan_all();
; 602  : 		_Alproxy.destroy(this->_Myproxy);
; 603  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 604  : 		this->_Myproxy = 0;
; 605  : 		}
; 606  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 607  : 
; 608  : 	_Alty& _Getal()
; 609  : 		{	// get reference to allocator
; 610  : 		return (this->_Alval);
; 611  : 		}
; 612  : 
; 613  : 	const _Alty& _Getal() const
; 614  : 		{	// get reference to allocator
; 615  : 		return (this->_Alval);
; 616  : 		}
; 617  : 	};
; 618  : 
; 619  : template<class _Alloc_types>
; 620  : 	class _String_alloc<false, _Alloc_types>
; 621  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 622  : 	{	// base class for basic_string to hold allocator with no storage
; 623  : public:
; 624  : 	typedef _String_alloc<false, _Alloc_types> _Myt;
; 625  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 626  : 
; 627  : 	typedef typename _Alloc_types::_Alty _Alty;
; 628  : 
; 629  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 630  : 	_String_alloc(const _Alloc& = _Alloc())
; 631  : 		{	// construct allocator from _Al
; 632  : 		}
; 633  : 
; 634  : 	void _Change_alloc(const _Alty&)
; 635  : 		{	// replace old allocator
; 636  : 		}
; 637  : 
; 638  : 	void _Swap_alloc(_Myt&)
; 639  : 		{	// swap allocators
; 640  : 		}
; 641  : 
; 642  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 643  : 	_String_alloc(const _Alloc& = _Alloc())
; 644  : 		{	// construct allocator from _Al
; 645  : 		_Alloc_proxy();
; 646  : 		}
; 647  : 
; 648  : 	~_String_alloc() _NOEXCEPT
; 649  : 		{	// destroy the object
; 650  : 		_Free_proxy();
; 651  : 		}
; 652  : 
; 653  : 	void _Change_alloc(const _Alty&)
; 654  : 		{	// replace old allocator
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 660  : 		}
; 661  : 
; 662  : 	void _Alloc_proxy()
; 663  : 		{	// construct proxy from _Alval
; 664  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 665  : 			_Alproxy;
; 666  : 		this->_Myproxy = _Alproxy.allocate(1);
; 667  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 668  : 		this->_Myproxy->_Mycont = this;
; 669  : 		}
; 670  : 
; 671  : 	void _Free_proxy()
; 672  : 		{	// destroy proxy
; 673  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 674  : 			_Alproxy;
; 675  : 		this->_Orphan_all();
; 676  : 		_Alproxy.destroy(this->_Myproxy);
; 677  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 678  : 		this->_Myproxy = 0;
; 679  : 		}
; 680  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 681  : 
; 682  : 	_Alty _Getal() const
; 683  : 		{	// get reference to allocator
; 684  : 		return (_Alty());
; 685  : 		}
; 686  : 	};
; 687  : 
; 688  : 		// TEMPLATE CLASS basic_string
; 689  : template<class _Elem,
; 690  : 	class _Traits,
; 691  : 	class _Alloc>
; 692  : 	class basic_string
; 693  : 		: public _String_alloc<!is_empty<_Alloc>::value,
; 694  : 			_String_base_types<_Elem, _Alloc> >
; 695  : 	{	// null-terminated transparent array of elements
; 696  : public:
; 697  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
; 698  : 	typedef _String_alloc<!is_empty<_Alloc>::value,
; 699  : 		_String_base_types<_Elem, _Alloc> > _Mybase;
; 700  : 	typedef _Traits traits_type;
; 701  : 	typedef _Alloc allocator_type;
; 702  : 
; 703  : 	typedef typename _Mybase::_Alty _Alty;
; 704  : 
; 705  : 	typedef typename _Mybase::value_type value_type;
; 706  : 	typedef typename _Mybase::size_type size_type;
; 707  : 	typedef typename _Mybase::difference_type difference_type;
; 708  : 	typedef typename _Mybase::pointer pointer;
; 709  : 	typedef typename _Mybase::const_pointer const_pointer;
; 710  : 	typedef typename _Mybase::reference reference;
; 711  : 	typedef typename _Mybase::const_reference const_reference;
; 712  : 
; 713  : 	typedef typename _Mybase::iterator iterator;
; 714  : 	typedef typename _Mybase::const_iterator const_iterator;
; 715  : 
; 716  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 717  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 718  : 
; 719  : 	basic_string(const _Myt& _Right)
; 720  : 
; 721  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 722  : 
; 723  : 
; 724  : 		{	// construct by copying _Right
; 725  : 		_Tidy();
; 726  : 		assign(_Right, 0, npos);
; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00078	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR _aString$[esp+92], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00080	c6 44 24 20 00	 mov	 BYTE PTR _aString$[esp+76], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonminimapmodule.cpp

; 126  : 	bool bFind = CPythonMiniMap::Instance().GetPickedInstanceInfo(fScrrenX, fScrrenY, aString, &fPosX, &fPosY, &dwTextColor);

  00085	8d 44 24 18	 lea	 eax, DWORD PTR _dwTextColor$[esp+76]
  00089	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+84], 0
  00091	f3 0f 10 54 24
	1c		 movss	 xmm2, DWORD PTR _fScrrenY$[esp+76]
  00097	f3 0f 10 4c 24
	14		 movss	 xmm1, DWORD PTR _fScrrenX$[esp+76]
  0009d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMiniMap@@@@0PAVCPythonMiniMap@@A ; CSingleton<CPythonMiniMap>::ms_singleton
  000a3	50		 push	 eax
  000a4	8d 44 24 14	 lea	 eax, DWORD PTR _fPosY$[esp+80]
  000a8	50		 push	 eax
  000a9	8d 44 24 14	 lea	 eax, DWORD PTR _fPosX$[esp+84]
  000ad	50		 push	 eax
  000ae	8d 44 24 2c	 lea	 eax, DWORD PTR _aString$[esp+88]
  000b2	50		 push	 eax
  000b3	e8 00 00 00 00	 call	 ?GetPickedInstanceInfo@CPythonMiniMap@@QAE_NMMAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAM1PAK@Z ; CPythonMiniMap::GetPickedInstanceInfo

; 127  : 	int iPosX, iPosY;
; 128  : 	PR_FLOAT_TO_INT(fPosX, iPosX);

  000b8	f3 0f 10 44 24
	0c		 movss	 xmm0, DWORD PTR _fPosX$[esp+76]
  000be	8a d8		 mov	 bl, al
  000c0	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?PR_FCNV@@3MA, xmm0
  000c8	d9 05 00 00 00
	00		 fld	 DWORD PTR ?PR_FCNV@@3MA	; PR_FCNV
  000ce	db 1d 00 00 00
	00		 fistp	 DWORD PTR ?PR_ICNV@@3JA
  000d4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  000da	66 0f 6e c2	 movd	 xmm0, edx
  000de	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000e1	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR ?PR_FCNV@@3MA
  000e8	76 01		 jbe	 SHORT $LN5@miniMapGet
  000ea	4a		 dec	 edx
$LN5@miniMapGet:

; 129  : 	PR_FLOAT_TO_INT(fPosY, iPosY);

  000eb	f3 0f 10 44 24
	10		 movss	 xmm0, DWORD PTR _fPosY$[esp+76]
  000f1	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?PR_FCNV@@3MA, xmm0
  000f9	d9 05 00 00 00
	00		 fld	 DWORD PTR ?PR_FCNV@@3MA	; PR_FCNV
  000ff	db 1d 00 00 00
	00		 fistp	 DWORD PTR ?PR_ICNV@@3JA
  00105	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  0010b	66 0f 6e c1	 movd	 xmm0, ecx
  0010f	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00112	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR ?PR_FCNV@@3MA
  00119	76 01		 jbe	 SHORT $LN7@miniMapGet
  0011b	49		 dec	 ecx
$LN7@miniMapGet:

; 132  : 	return Py_BuildValue("isiil", (int)bFind, aString.c_str(), iPosX, iPosY, (signed) dwTextColor);

  0011c	ff 74 24 18	 push	 DWORD PTR _dwTextColor$[esp+76]
  00120	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00125	f7 ea		 imul	 edx
  00127	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  0012c	c1 fa 05	 sar	 edx, 5
  0012f	8b f2		 mov	 esi, edx
  00131	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  00134	03 f2		 add	 esi, edx
  00136	f7 e9		 imul	 ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00138	8d 44 24 24	 lea	 eax, DWORD PTR _aString$[esp+80]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonminimapmodule.cpp

; 131  : 	iPosY /= 100;

  0013c	c1 fa 05	 sar	 edx, 5
  0013f	8b ca		 mov	 ecx, edx
  00141	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00144	03 ca		 add	 ecx, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00146	83 7c 24 38 10	 cmp	 DWORD PTR _aString$[esp+100], 16 ; 00000010H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonminimapmodule.cpp

; 132  : 	return Py_BuildValue("isiil", (int)bFind, aString.c_str(), iPosX, iPosY, (signed) dwTextColor);

  0014b	51		 push	 ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  0014c	0f 43 44 24 28	 cmovae	 eax, DWORD PTR _aString$[esp+84]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonminimapmodule.cpp

; 132  : 	return Py_BuildValue("isiil", (int)bFind, aString.c_str(), iPosX, iPosY, (signed) dwTextColor);

  00151	56		 push	 esi
  00152	50		 push	 eax
  00153	0f b6 c3	 movzx	 eax, bl
  00156	50		 push	 eax
  00157	68 00 00 00 00	 push	 OFFSET ??_C@_05BHNEPGFM@isiil?$AA@
  0015c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00162	83 c4 18	 add	 esp, 24			; 00000018H
  00165	8b f0		 mov	 esi, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00167	83 7c 24 34 10	 cmp	 DWORD PTR _aString$[esp+96], 16 ; 00000010H
  0016c	72 0c		 jb	 SHORT $LN78@miniMapGet
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0016e	ff 74 24 20	 push	 DWORD PTR _aString$[esp+76]
  00172	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00177	83 c4 04	 add	 esp, 4
$LN78@miniMapGet:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonminimapmodule.cpp

; 132  : 	return Py_BuildValue("isiil", (int)bFind, aString.c_str(), iPosX, iPosY, (signed) dwTextColor);

  0017a	8b c6		 mov	 eax, esi
$LN3@miniMapGet:

; 133  : }

  0017c	8b 4c 24 40	 mov	 ecx, DWORD PTR __$EHRec$[esp+76]
  00180	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00187	59		 pop	 ecx
  00188	5e		 pop	 esi
  00189	5b		 pop	 ebx
  0018a	8b 4c 24 2c	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+64]
  0018e	33 cc		 xor	 ecx, esp
  00190	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00195	8b e5		 mov	 esp, ebp
  00197	5d		 pop	 ebp
  00198	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?miniMapGetInfo@@YAPAU_object@@PAU1@0@Z$0:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR _aString$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?miniMapGetInfo@@YAPAU_object@@PAU1@0@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 c4	 lea	 eax, DWORD PTR [edx-60]
  0000f	8b 4a c0	 mov	 ecx, DWORD PTR [edx-64]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	83 c0 08	 add	 eax, 8
  0001c	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?miniMapGetInfo@@YAPAU_object@@PAU1@0@Z
  0002b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?miniMapGetInfo@@YAPAU_object@@PAU1@0@Z ENDP		; miniMapGetInfo
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonminimapmodule.cpp
;	COMDAT ?miniMapLoadAtlas@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?miniMapLoadAtlas@@YAPAU_object@@PAU1@0@Z PROC		; miniMapLoadAtlas, COMDAT

; 139  : 	if (!CPythonMiniMap::Instance().LoadAtlas())

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMiniMap@@@@0PAVCPythonMiniMap@@A ; CSingleton<CPythonMiniMap>::ms_singleton
  00006	e8 00 00 00 00	 call	 ?LoadAtlas@CPythonMiniMap@@QAE_NXZ ; CPythonMiniMap::LoadAtlas
  0000b	84 c0		 test	 al, al
  0000d	75 0d		 jne	 SHORT $LN1@miniMapLoa

; 140  : 		TraceError("CPythonMiniMap::Instance().LoadAtlas() Failed");

  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@JOBACLFH@CPythonMiniMap?3?3Instance?$CI?$CJ?4LoadA@
  00014	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00019	83 c4 04	 add	 esp, 4
$LN1@miniMapLoa:

; 141  : 	return Py_BuildNone();

  0001c	e9 00 00 00 00	 jmp	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
?miniMapLoadAtlas@@YAPAU_object@@PAU1@0@Z ENDP		; miniMapLoadAtlas
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonminimapmodule.cpp
;	COMDAT ?miniMapUpdateAtlas@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?miniMapUpdateAtlas@@YAPAU_object@@PAU1@0@Z PROC	; miniMapUpdateAtlas, COMDAT

; 146  : 	CPythonMiniMap::Instance().UpdateAtlas();

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMiniMap@@@@0PAVCPythonMiniMap@@A ; CSingleton<CPythonMiniMap>::ms_singleton
  00006	e8 00 00 00 00	 call	 ?UpdateAtlas@CPythonMiniMap@@QAEXXZ ; CPythonMiniMap::UpdateAtlas

; 147  : 	return Py_BuildNone();

  0000b	e9 00 00 00 00	 jmp	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
?miniMapUpdateAtlas@@YAPAU_object@@PAU1@0@Z ENDP	; miniMapUpdateAtlas
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonminimapmodule.cpp
;	COMDAT ?miniMapRenderAtlas@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_fScrrenX$ = -8						; size = 4
_fScrrenY$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?miniMapRenderAtlas@@YAPAU_object@@PAU1@0@Z PROC	; miniMapRenderAtlas, COMDAT

; 151  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 152  : 	float fScrrenX;
; 153  : 	if (!PyTuple_GetFloat(poArgs, 0, &fScrrenX))

  00006	8d 45 f8	 lea	 eax, DWORD PTR _fScrrenX$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetFloat@@YA_NPAU_object@@HPAM@Z ; PyTuple_GetFloat
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 0e		 jne	 SHORT $LN2@miniMapRen
$LN7@miniMapRen:

; 154  : 		return Py_BuildException();

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00022	83 c4 04	 add	 esp, 4

; 162  : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN2@miniMapRen:

; 155  : 	
; 156  : 	float fScrrenY;
; 157  : 	if (!PyTuple_GetFloat(poArgs, 1, &fScrrenY))

  00029	8d 45 fc	 lea	 eax, DWORD PTR _fScrrenY$[ebp]
  0002c	50		 push	 eax
  0002d	6a 01		 push	 1
  0002f	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  00032	e8 00 00 00 00	 call	 ?PyTuple_GetFloat@@YA_NPAU_object@@HPAM@Z ; PyTuple_GetFloat
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	84 c0		 test	 al, al
  0003c	74 dd		 je	 SHORT $LN7@miniMapRen

; 158  : 		return Py_BuildException();
; 159  : 	
; 160  : 	CPythonMiniMap::Instance().RenderAtlas(fScrrenX, fScrrenY);

  0003e	f3 0f 10 55 fc	 movss	 xmm2, DWORD PTR _fScrrenY$[ebp]
  00043	f3 0f 10 4d f8	 movss	 xmm1, DWORD PTR _fScrrenX$[ebp]
  00048	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMiniMap@@@@0PAVCPythonMiniMap@@A ; CSingleton<CPythonMiniMap>::ms_singleton
  0004e	e8 00 00 00 00	 call	 ?RenderAtlas@CPythonMiniMap@@QAEXMM@Z ; CPythonMiniMap::RenderAtlas

; 161  : 	return Py_BuildNone();

  00053	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 162  : }

  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
?miniMapRenderAtlas@@YAPAU_object@@PAU1@0@Z ENDP	; miniMapRenderAtlas
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonminimapmodule.cpp
;	COMDAT ?miniMapShowAtlas@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?miniMapShowAtlas@@YAPAU_object@@PAU1@0@Z PROC		; miniMapShowAtlas, COMDAT

; 166  : 	CPythonMiniMap::Instance().ShowAtlas();

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMiniMap@@@@0PAVCPythonMiniMap@@A ; CSingleton<CPythonMiniMap>::ms_singleton
  00006	e8 00 00 00 00	 call	 ?ShowAtlas@CPythonMiniMap@@QAEXXZ ; CPythonMiniMap::ShowAtlas

; 167  : 	return Py_BuildNone();

  0000b	e9 00 00 00 00	 jmp	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
?miniMapShowAtlas@@YAPAU_object@@PAU1@0@Z ENDP		; miniMapShowAtlas
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonminimapmodule.cpp
;	COMDAT ?miniMapHideAtlas@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?miniMapHideAtlas@@YAPAU_object@@PAU1@0@Z PROC		; miniMapHideAtlas, COMDAT

; 172  : 	CPythonMiniMap::Instance().HideAtlas();

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMiniMap@@@@0PAVCPythonMiniMap@@A ; CSingleton<CPythonMiniMap>::ms_singleton
  00006	e8 00 00 00 00	 call	 ?HideAtlas@CPythonMiniMap@@QAEXXZ ; CPythonMiniMap::HideAtlas

; 173  : 	return Py_BuildNone();

  0000b	e9 00 00 00 00	 jmp	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
?miniMapHideAtlas@@YAPAU_object@@PAU1@0@Z ENDP		; miniMapHideAtlas
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonminimapmodule.cpp
;	COMDAT ?miniMapisShowAtlas@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?miniMapisShowAtlas@@YAPAU_object@@PAU1@0@Z PROC	; miniMapisShowAtlas, COMDAT

; 178  : 	bool bShow = CPythonMiniMap::Instance().CanShowAtlas();

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMiniMap@@@@0PAVCPythonMiniMap@@A ; CSingleton<CPythonMiniMap>::ms_singleton
  00006	e8 00 00 00 00	 call	 ?CanShowAtlas@CPythonMiniMap@@QAE_NXZ ; CPythonMiniMap::CanShowAtlas

; 179  : 	return Py_BuildValue("b", bShow);

  0000b	0f b6 c0	 movzx	 eax, al
  0000e	50		 push	 eax
  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_01OJONOECF@b?$AA@
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0001a	83 c4 08	 add	 esp, 8

; 180  : }

  0001d	c3		 ret	 0
?miniMapisShowAtlas@@YAPAU_object@@PAU1@0@Z ENDP	; miniMapisShowAtlas
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonminimapmodule.cpp
;	COMDAT ?miniMapIsAtlas@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?miniMapIsAtlas@@YAPAU_object@@PAU1@0@Z PROC		; miniMapIsAtlas, COMDAT

; 184  : 	bool isData = CPythonMiniMap::Instance().IsAtlas();

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMiniMap@@@@0PAVCPythonMiniMap@@A ; CSingleton<CPythonMiniMap>::ms_singleton
  00006	e8 00 00 00 00	 call	 ?IsAtlas@CPythonMiniMap@@QAE_NXZ ; CPythonMiniMap::IsAtlas

; 185  : 	return Py_BuildValue("b", isData);

  0000b	0f b6 c0	 movzx	 eax, al
  0000e	50		 push	 eax
  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_01OJONOECF@b?$AA@
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0001a	83 c4 08	 add	 esp, 8

; 186  : }

  0001d	c3		 ret	 0
?miniMapIsAtlas@@YAPAU_object@@PAU1@0@Z ENDP		; miniMapIsAtlas
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonminimapmodule.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonminimapmodule.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonminimapmodule.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonminimapmodule.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonminimapmodule.cpp
;	COMDAT ?miniMapGetAtlasInfo@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_dwTextColor$ = -68					; size = 4
_fPosX$ = -64						; size = 4
_dwGuildID$ = -60					; size = 4
_fPosY$ = -56						; size = 4
_fScrrenY$ = -52					; size = 4
_fScrrenX$ = -48					; size = 4
_aString$ = -44						; size = 24
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?miniMapGetAtlasInfo@@YAPAU_object@@PAU1@0@Z PROC	; miniMapGetAtlasInfo, COMDAT

; 190  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?miniMapGetAtlasInfo@@YAPAU_object@@PAU1@0@Z
  0000d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00013	50		 push	 eax
  00014	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c4		 xor	 eax, esp
  0001e	89 44 24 34	 mov	 DWORD PTR __$ArrayPad$[esp+72], eax
  00022	53		 push	 ebx
  00023	56		 push	 esi
  00024	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00029	33 c4		 xor	 eax, esp
  0002b	50		 push	 eax
  0002c	8d 44 24 48	 lea	 eax, DWORD PTR __$EHRec$[esp+84]
  00030	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00036	8b 75 0c	 mov	 esi, DWORD PTR _poArgs$[ebp]

; 191  : 	float fScrrenX;
; 192  : 	if (!PyTuple_GetFloat(poArgs, 0, &fScrrenX))

  00039	8d 44 24 24	 lea	 eax, DWORD PTR _fScrrenX$[esp+84]
  0003d	50		 push	 eax
  0003e	6a 00		 push	 0
  00040	56		 push	 esi
  00041	e8 00 00 00 00	 call	 ?PyTuple_GetFloat@@YA_NPAU_object@@HPAM@Z ; PyTuple_GetFloat
  00046	83 c4 0c	 add	 esp, 12			; 0000000cH
  00049	84 c0		 test	 al, al
  0004b	75 0f		 jne	 SHORT $LN2@miniMapGet
$LN53@miniMapGet:

; 193  : 		return Py_BuildException();

  0004d	6a 00		 push	 0
  0004f	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00054	83 c4 04	 add	 esp, 4
  00057	e9 42 01 00 00	 jmp	 $LN3@miniMapGet
$LN2@miniMapGet:

; 194  : 	float fScrrenY;
; 195  : 	if (!PyTuple_GetFloat(poArgs, 1, &fScrrenY))

  0005c	8d 44 24 20	 lea	 eax, DWORD PTR _fScrrenY$[esp+84]
  00060	50		 push	 eax
  00061	6a 01		 push	 1
  00063	56		 push	 esi
  00064	e8 00 00 00 00	 call	 ?PyTuple_GetFloat@@YA_NPAU_object@@HPAM@Z ; PyTuple_GetFloat
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006c	84 c0		 test	 al, al
  0006e	74 dd		 je	 SHORT $LN53@miniMapGet

; 196  : 		return Py_BuildException();
; 197  : 
; 198  : 	std::string aString = "";

  00070	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00075	8d 4c 24 2c	 lea	 ecx, DWORD PTR _aString$[esp+88]
  00079	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 199  : 	float fPosX = 0.0f;
; 200  : 	float fPosY = 0.0f;
; 201  : 	DWORD dwTextColor = 0;
; 202  : 	DWORD dwGuildID = 0;
; 203  : 	bool bFind = CPythonMiniMap::Instance().GetAtlasInfo(fScrrenX, fScrrenY, aString, &fPosX, &fPosY, &dwTextColor, &dwGuildID);

  0007e	8d 44 24 18	 lea	 eax, DWORD PTR _dwGuildID$[esp+84]
  00082	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+92], 0
  0008a	f3 0f 10 54 24
	20		 movss	 xmm2, DWORD PTR _fScrrenY$[esp+84]
  00090	f3 0f 10 4c 24
	24		 movss	 xmm1, DWORD PTR _fScrrenX$[esp+84]
  00096	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMiniMap@@@@0PAVCPythonMiniMap@@A ; CSingleton<CPythonMiniMap>::ms_singleton
  0009c	50		 push	 eax
  0009d	8d 44 24 14	 lea	 eax, DWORD PTR _dwTextColor$[esp+88]
  000a1	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _fPosX$[esp+88], 0
  000a9	50		 push	 eax
  000aa	8d 44 24 24	 lea	 eax, DWORD PTR _fPosY$[esp+92]
  000ae	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR _fPosY$[esp+92], 0
  000b6	50		 push	 eax
  000b7	8d 44 24 20	 lea	 eax, DWORD PTR _fPosX$[esp+96]
  000bb	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR _dwTextColor$[esp+96], 0
  000c3	50		 push	 eax
  000c4	8d 44 24 38	 lea	 eax, DWORD PTR _aString$[esp+100]
  000c8	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR _dwGuildID$[esp+100], 0
  000d0	50		 push	 eax
  000d1	e8 00 00 00 00	 call	 ?GetAtlasInfo@CPythonMiniMap@@QAE_NMMAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAM1PAK2@Z ; CPythonMiniMap::GetAtlasInfo

; 204  : 	int iPosX, iPosY;
; 205  : 	PR_FLOAT_TO_INT(fPosX, iPosX);

  000d6	f3 0f 10 44 24
	14		 movss	 xmm0, DWORD PTR _fPosX$[esp+84]
  000dc	8a d8		 mov	 bl, al
  000de	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?PR_FCNV@@3MA, xmm0
  000e6	d9 05 00 00 00
	00		 fld	 DWORD PTR ?PR_FCNV@@3MA	; PR_FCNV
  000ec	db 1d 00 00 00
	00		 fistp	 DWORD PTR ?PR_ICNV@@3JA
  000f2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  000f8	66 0f 6e c2	 movd	 xmm0, edx
  000fc	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000ff	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR ?PR_FCNV@@3MA
  00106	76 01		 jbe	 SHORT $LN5@miniMapGet
  00108	4a		 dec	 edx
$LN5@miniMapGet:

; 206  : 	PR_FLOAT_TO_INT(fPosY, iPosY);

  00109	f3 0f 10 44 24
	1c		 movss	 xmm0, DWORD PTR _fPosY$[esp+84]
  0010f	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?PR_FCNV@@3MA, xmm0
  00117	d9 05 00 00 00
	00		 fld	 DWORD PTR ?PR_FCNV@@3MA	; PR_FCNV
  0011d	db 1d 00 00 00
	00		 fistp	 DWORD PTR ?PR_ICNV@@3JA
  00123	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  00129	66 0f 6e c1	 movd	 xmm0, ecx
  0012d	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00130	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR ?PR_FCNV@@3MA
  00137	76 01		 jbe	 SHORT $LN7@miniMapGet
  00139	49		 dec	 ecx
$LN7@miniMapGet:

; 209  : 	return Py_BuildValue("isiili", (int)bFind, aString.c_str(), iPosX, iPosY, (signed) dwTextColor, dwGuildID);

  0013a	ff 74 24 18	 push	 DWORD PTR _dwGuildID$[esp+84]
  0013e	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00143	ff 74 24 14	 push	 DWORD PTR _dwTextColor$[esp+88]
  00147	f7 ea		 imul	 edx
  00149	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  0014e	c1 fa 05	 sar	 edx, 5
  00151	8b f2		 mov	 esi, edx
  00153	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  00156	03 f2		 add	 esi, edx
  00158	f7 e9		 imul	 ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  0015a	8d 44 24 30	 lea	 eax, DWORD PTR _aString$[esp+92]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonminimapmodule.cpp

; 208  : 	iPosY /= 100;

  0015e	c1 fa 05	 sar	 edx, 5
  00161	8b ca		 mov	 ecx, edx
  00163	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00166	03 ca		 add	 ecx, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00168	83 7c 24 44 10	 cmp	 DWORD PTR _aString$[esp+112], 16 ; 00000010H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonminimapmodule.cpp

; 209  : 	return Py_BuildValue("isiili", (int)bFind, aString.c_str(), iPosX, iPosY, (signed) dwTextColor, dwGuildID);

  0016d	51		 push	 ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  0016e	0f 43 44 24 34	 cmovae	 eax, DWORD PTR _aString$[esp+96]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonminimapmodule.cpp

; 209  : 	return Py_BuildValue("isiili", (int)bFind, aString.c_str(), iPosX, iPosY, (signed) dwTextColor, dwGuildID);

  00173	56		 push	 esi
  00174	50		 push	 eax
  00175	0f b6 c3	 movzx	 eax, bl
  00178	50		 push	 eax
  00179	68 00 00 00 00	 push	 OFFSET ??_C@_06NGPFBJMH@isiili?$AA@
  0017e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00184	83 c4 1c	 add	 esp, 28			; 0000001cH
  00187	8b f0		 mov	 esi, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00189	83 7c 24 3c 10	 cmp	 DWORD PTR _aString$[esp+104], 16 ; 00000010H
  0018e	72 0c		 jb	 SHORT $LN40@miniMapGet
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00190	ff 74 24 28	 push	 DWORD PTR _aString$[esp+84]
  00194	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00199	83 c4 04	 add	 esp, 4
$LN40@miniMapGet:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonminimapmodule.cpp

; 209  : 	return Py_BuildValue("isiili", (int)bFind, aString.c_str(), iPosX, iPosY, (signed) dwTextColor, dwGuildID);

  0019c	8b c6		 mov	 eax, esi
$LN3@miniMapGet:

; 210  : }

  0019e	8b 4c 24 48	 mov	 ecx, DWORD PTR __$EHRec$[esp+84]
  001a2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001a9	59		 pop	 ecx
  001aa	5e		 pop	 esi
  001ab	5b		 pop	 ebx
  001ac	8b 4c 24 34	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+72]
  001b0	33 cc		 xor	 ecx, esp
  001b2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b7	8b e5		 mov	 esp, ebp
  001b9	5d		 pop	 ebp
  001ba	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?miniMapGetAtlasInfo@@YAPAU_object@@PAU1@0@Z$0:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR _aString$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?miniMapGetAtlasInfo@@YAPAU_object@@PAU1@0@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 bc	 lea	 eax, DWORD PTR [edx-68]
  0000f	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	83 c0 08	 add	 eax, 8
  0001c	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?miniMapGetAtlasInfo@@YAPAU_object@@PAU1@0@Z
  0002b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?miniMapGetAtlasInfo@@YAPAU_object@@PAU1@0@Z ENDP	; miniMapGetAtlasInfo
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonminimapmodule.cpp
;	COMDAT ?miniMapGetAtlasSize@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_fSizeY$ = -8						; size = 4
_fSizeX$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?miniMapGetAtlasSize@@YAPAU_object@@PAU1@0@Z PROC	; miniMapGetAtlasSize, COMDAT

; 213  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 214  : 	float fSizeX, fSizeY;
; 215  : 	bool bGet = CPythonMiniMap::Instance().GetAtlasSize(&fSizeX, &fSizeY);

  00006	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMiniMap@@@@0PAVCPythonMiniMap@@A ; CSingleton<CPythonMiniMap>::ms_singleton
  0000c	8d 45 f8	 lea	 eax, DWORD PTR _fSizeY$[ebp]
  0000f	50		 push	 eax
  00010	8d 45 fc	 lea	 eax, DWORD PTR _fSizeX$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ?GetAtlasSize@CPythonMiniMap@@QAE_NPAM0@Z ; CPythonMiniMap::GetAtlasSize

; 216  : 
; 217  : /*
; 218  : 	float fSizeXoo256 = fSizeX / 256.0f;
; 219  : 	float fSizeYoo256 = fSizeY / 256.0f;
; 220  : 
; 221  : 	if (fSizeXoo256 >= fSizeYoo256)
; 222  : 	{
; 223  : 		fSizeX /= fSizeYoo256;
; 224  : 		fSizeY = 256.0f;
; 225  : 	}
; 226  : 	else
; 227  : 	{
; 228  : 		fSizeX = 256.0f;
; 229  : 		fSizeY /= fSizeXoo256;
; 230  : 	}
; 231  : */
; 232  : 
; 233  : 	int iSizeX, iSizeY;
; 234  : 	PR_FLOAT_TO_INT(fSizeX, iSizeX);

  00019	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _fSizeX$[ebp]
  0001e	8a d0		 mov	 dl, al
  00020	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?PR_FCNV@@3MA, xmm0
  00028	d9 05 00 00 00
	00		 fld	 DWORD PTR ?PR_FCNV@@3MA	; PR_FCNV
  0002e	db 1d 00 00 00
	00		 fistp	 DWORD PTR ?PR_ICNV@@3JA
  00034	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  0003a	66 0f 6e c1	 movd	 xmm0, ecx
  0003e	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00041	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR ?PR_FCNV@@3MA
  00048	76 01		 jbe	 SHORT $LN3@miniMapGet
  0004a	49		 dec	 ecx
$LN3@miniMapGet:

; 235  : 	PR_FLOAT_TO_INT(fSizeY, iSizeY);

  0004b	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _fSizeY$[ebp]
  00050	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?PR_FCNV@@3MA, xmm0
  00058	d9 05 00 00 00
	00		 fld	 DWORD PTR ?PR_FCNV@@3MA	; PR_FCNV
  0005e	db 1d 00 00 00
	00		 fistp	 DWORD PTR ?PR_ICNV@@3JA
  00064	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  00069	66 0f 6e c0	 movd	 xmm0, eax
  0006d	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00070	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR ?PR_FCNV@@3MA
  00077	76 01		 jbe	 SHORT $LN5@miniMapGet
  00079	48		 dec	 eax
$LN5@miniMapGet:

; 236  : 
; 237  : 	return Py_BuildValue("bii", (int)bGet, iSizeX, iSizeY);

  0007a	50		 push	 eax
  0007b	51		 push	 ecx
  0007c	0f b6 c2	 movzx	 eax, dl
  0007f	50		 push	 eax
  00080	68 00 00 00 00	 push	 OFFSET ??_C@_03LMKNDPCK@bii?$AA@
  00085	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0008b	83 c4 10	 add	 esp, 16			; 00000010H

; 238  : }

  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c3		 ret	 0
?miniMapGetAtlasSize@@YAPAU_object@@PAU1@0@Z ENDP	; miniMapGetAtlasSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonminimapmodule.cpp
;	COMDAT ?miniMapAddWayPoint@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_fX$ = -16						; size = 4
_iID$ = -12						; size = 4
_fY$ = -8						; size = 4
_buf$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?miniMapAddWayPoint@@YAPAU_object@@PAU1@0@Z PROC	; miniMapAddWayPoint, COMDAT

; 241  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 242  : 	int iID;
; 243  : 	if (!PyTuple_GetInteger(poArgs, 0, &iID))

  00006	8d 45 f4	 lea	 eax, DWORD PTR _iID$[ebp]
  00009	56		 push	 esi
  0000a	8b 75 0c	 mov	 esi, DWORD PTR _poArgs$[ebp]
  0000d	50		 push	 eax
  0000e	6a 00		 push	 0
  00010	56		 push	 esi
  00011	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
  00019	84 c0		 test	 al, al
  0001b	75 0f		 jne	 SHORT $LN4@miniMapAdd
$LN10@miniMapAdd:

; 244  : 		return Py_BuildException();

  0001d	6a 00		 push	 0
$LN11@miniMapAdd:
  0001f	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00024	83 c4 04	 add	 esp, 4

; 261  : }

  00027	5e		 pop	 esi
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
$LN4@miniMapAdd:

; 245  : 	
; 246  : 	float fX;
; 247  : 	if (!PyTuple_GetFloat(poArgs, 1, &fX))

  0002c	8d 45 f0	 lea	 eax, DWORD PTR _fX$[ebp]
  0002f	50		 push	 eax
  00030	6a 01		 push	 1
  00032	56		 push	 esi
  00033	e8 00 00 00 00	 call	 ?PyTuple_GetFloat@@YA_NPAU_object@@HPAM@Z ; PyTuple_GetFloat
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003b	84 c0		 test	 al, al
  0003d	74 de		 je	 SHORT $LN10@miniMapAdd

; 248  : 		return Py_BuildException();
; 249  : 	
; 250  : 	float fY;
; 251  : 	if (!PyTuple_GetFloat(poArgs, 2, &fY))

  0003f	8d 45 f8	 lea	 eax, DWORD PTR _fY$[ebp]
  00042	50		 push	 eax
  00043	6a 02		 push	 2
  00045	56		 push	 esi
  00046	e8 00 00 00 00	 call	 ?PyTuple_GetFloat@@YA_NPAU_object@@HPAM@Z ; PyTuple_GetFloat
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004e	84 c0		 test	 al, al
  00050	74 cb		 je	 SHORT $LN10@miniMapAdd

; 252  : 		return Py_BuildException();
; 253  : 
; 254  : 	char * buf;
; 255  : 	if (!PyTuple_GetString(poArgs, 3, &buf))

  00052	8d 45 fc	 lea	 eax, DWORD PTR _buf$[ebp]
  00055	50		 push	 eax
  00056	6a 03		 push	 3
  00058	56		 push	 esi
  00059	e8 00 00 00 00	 call	 ?PyTuple_GetString@@YA_NPAU_object@@HPAPAD@Z ; PyTuple_GetString
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 256  : 		return Py_BuildException();

  00061	6a 00		 push	 0
  00063	84 c0		 test	 al, al
  00065	74 b8		 je	 SHORT $LN11@miniMapAdd

; 257  : 
; 258  : 	CPythonMiniMap::Instance().AddWayPoint(CPythonMiniMap::TYPE_WAYPOINT, (DWORD)iID, fX, fY, buf);

  00067	83 ec 18	 sub	 esp, 24			; 00000018H
  0006a	8b cc		 mov	 ecx, esp
  0006c	ff 75 fc	 push	 DWORD PTR _buf$[ebp]
  0006f	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00074	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _fY$[ebp]
  00079	f3 0f 10 5d f0	 movss	 xmm3, DWORD PTR _fX$[ebp]
  0007e	51		 push	 ecx
  0007f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMiniMap@@@@0PAVCPythonMiniMap@@A ; CSingleton<CPythonMiniMap>::ms_singleton
  00085	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0008a	ff 75 f4	 push	 DWORD PTR _iID$[ebp]
  0008d	6a 06		 push	 6
  0008f	e8 00 00 00 00	 call	 ?AddWayPoint@CPythonMiniMap@@QAEXEKMMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; CPythonMiniMap::AddWayPoint

; 259  : 	
; 260  : 	return Py_BuildNone();

  00094	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 261  : }

  00099	5e		 pop	 esi
  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c3		 ret	 0
?miniMapAddWayPoint@@YAPAU_object@@PAU1@0@Z ENDP	; miniMapAddWayPoint
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonminimapmodule.cpp
;	COMDAT ?miniMapRemoveWayPoint@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iID$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?miniMapRemoveWayPoint@@YAPAU_object@@PAU1@0@Z PROC	; miniMapRemoveWayPoint, COMDAT

; 264  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 265  : 	int iID;
; 266  : 	if (!PyTuple_GetInteger(poArgs, 0, &iID))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iID$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@miniMapRem

; 267  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 272  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@miniMapRem:

; 268  : 	
; 269  : 	CPythonMiniMap::Instance().RemoveWayPoint((DWORD)iID);

  00027	ff 75 fc	 push	 DWORD PTR _iID$[ebp]
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMiniMap@@@@0PAVCPythonMiniMap@@A ; CSingleton<CPythonMiniMap>::ms_singleton
  00030	e8 00 00 00 00	 call	 ?RemoveWayPoint@CPythonMiniMap@@QAEXK@Z ; CPythonMiniMap::RemoveWayPoint

; 270  : 	
; 271  : 	return Py_BuildNone();

  00035	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 272  : }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?miniMapRemoveWayPoint@@YAPAU_object@@PAU1@0@Z ENDP	; miniMapRemoveWayPoint
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonminimapmodule.cpp
;	COMDAT ?miniMapRegisterAtlasWindow@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poHandler$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?miniMapRegisterAtlasWindow@@YAPAU_object@@PAU1@0@Z PROC ; miniMapRegisterAtlasWindow, COMDAT

; 275  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 276  : 	PyObject * poHandler;
; 277  : 	if (!PyTuple_GetObject(poArgs, 0, &poHandler))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _poHandler$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetObject@@YA_NPAU_object@@HPAPAU1@@Z ; PyTuple_GetObject
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@miniMapReg

; 278  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 281  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@miniMapReg:

; 279  : 	CPythonMiniMap::Instance().RegisterAtlasWindow(poHandler);

  00027	ff 75 fc	 push	 DWORD PTR _poHandler$[ebp]
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMiniMap@@@@0PAVCPythonMiniMap@@A ; CSingleton<CPythonMiniMap>::ms_singleton
  00030	e8 00 00 00 00	 call	 ?RegisterAtlasWindow@CPythonMiniMap@@QAEXPAU_object@@@Z ; CPythonMiniMap::RegisterAtlasWindow

; 280  : 	return Py_BuildNone();

  00035	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 281  : }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?miniMapRegisterAtlasWindow@@YAPAU_object@@PAU1@0@Z ENDP ; miniMapRegisterAtlasWindow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonminimapmodule.cpp
;	COMDAT ?miniMapUnregisterAtlasWindow@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?miniMapUnregisterAtlasWindow@@YAPAU_object@@PAU1@0@Z PROC ; miniMapUnregisterAtlasWindow, COMDAT

; 285  : 	CPythonMiniMap::Instance().UnregisterAtlasWindow();

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMiniMap@@@@0PAVCPythonMiniMap@@A ; CSingleton<CPythonMiniMap>::ms_singleton
  00006	e8 00 00 00 00	 call	 ?UnregisterAtlasWindow@CPythonMiniMap@@QAEXXZ ; CPythonMiniMap::UnregisterAtlasWindow

; 286  : 	return Py_BuildNone();

  0000b	e9 00 00 00 00	 jmp	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
?miniMapUnregisterAtlasWindow@@YAPAU_object@@PAU1@0@Z ENDP ; miniMapUnregisterAtlasWindow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonminimapmodule.cpp
;	COMDAT ?miniMapGetGuildAreaID@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_fx$ = -8						; size = 4
_fy$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?miniMapGetGuildAreaID@@YAPAU_object@@PAU1@0@Z PROC	; miniMapGetGuildAreaID, COMDAT

; 290  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 291  : 	float fx;
; 292  : 	if (!PyTuple_GetFloat(poArgs, 0, &fx))

  00006	8d 45 f8	 lea	 eax, DWORD PTR _fx$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetFloat@@YA_NPAU_object@@HPAM@Z ; PyTuple_GetFloat
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 0e		 jne	 SHORT $LN2@miniMapGet
$LN7@miniMapGet:

; 293  : 		return Py_BuildException();

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00022	83 c4 04	 add	 esp, 4

; 300  : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN2@miniMapGet:

; 294  : 	float fy;
; 295  : 	if (!PyTuple_GetFloat(poArgs, 1, &fy))

  00029	8d 45 fc	 lea	 eax, DWORD PTR _fy$[ebp]
  0002c	50		 push	 eax
  0002d	6a 01		 push	 1
  0002f	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  00032	e8 00 00 00 00	 call	 ?PyTuple_GetFloat@@YA_NPAU_object@@HPAM@Z ; PyTuple_GetFloat
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	84 c0		 test	 al, al
  0003c	74 dd		 je	 SHORT $LN7@miniMapGet

; 296  : 		return Py_BuildException();
; 297  : 
; 298  : 	DWORD dwGuildID = CPythonMiniMap::Instance().GetGuildAreaID(fx, fy);

  0003e	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00043	e8 00 00 00 00	 call	 __ftoui3
  00048	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _fx$[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 __ftoui3
  00053	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMiniMap@@@@0PAVCPythonMiniMap@@A ; CSingleton<CPythonMiniMap>::ms_singleton
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 ?GetGuildAreaID@CPythonMiniMap@@QAEKKK@Z ; CPythonMiniMap::GetGuildAreaID

; 299  : 	return Py_BuildValue("i", dwGuildID);

  0005f	50		 push	 eax
  00060	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0006b	83 c4 08	 add	 esp, 8

; 300  : }

  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
?miniMapGetGuildAreaID@@YAPAU_object@@PAU1@0@Z ENDP	; miniMapGetGuildAreaID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonminimapmodule.cpp
;	COMDAT ?initMiniMap@@YAXXZ
_TEXT	SEGMENT
?initMiniMap@@YAXXZ PROC				; initMiniMap, COMDAT

; 303  : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 304  : 	static PyMethodDef s_methods[] = 
; 305  : 	{
; 306  : 		{ "SetScale",						miniMapSetScale,								METH_VARARGS },
; 307  : 		{ "ScaleUp",						miniMapScaleUp,									METH_VARARGS },
; 308  : 		{ "ScaleDown",						miniMapScaleDown,								METH_VARARGS },
; 309  : 		{ "SetMiniMapSize",					miniMapSetMiniMapSize,							METH_VARARGS },
; 310  : 
; 311  : 		{ "SetCenterPosition",				miniMapSetCenterPosition,						METH_VARARGS },
; 312  : 
; 313  : 		{ "Destroy",						miniMapDestroy,									METH_VARARGS },
; 314  : 		{ "Create",							miniMapCreate,									METH_VARARGS },
; 315  : 		{ "Update",							miniMapUpdate,									METH_VARARGS },
; 316  : 		{ "Render",							miniMapRender,									METH_VARARGS },
; 317  : 
; 318  : 		{ "Show",							miniMapShow,									METH_VARARGS },
; 319  : 		{ "Hide",							miniMapHide,									METH_VARARGS },
; 320  : 
; 321  : 		{ "isShow",							miniMapisShow,									METH_VARARGS },
; 322  : 
; 323  : 		{ "GetInfo",						miniMapGetInfo,									METH_VARARGS },
; 324  : 
; 325  : 		{ "LoadAtlas",						miniMapLoadAtlas,								METH_VARARGS },
; 326  : 		{ "UpdateAtlas",					miniMapUpdateAtlas,								METH_VARARGS },
; 327  : 		{ "RenderAtlas",					miniMapRenderAtlas,								METH_VARARGS },
; 328  : 		{ "ShowAtlas",						miniMapShowAtlas,								METH_VARARGS },
; 329  : 		{ "HideAtlas",						miniMapHideAtlas,								METH_VARARGS },
; 330  : 		{ "isShowAtlas",					miniMapisShowAtlas,								METH_VARARGS },
; 331  : 		{ "IsAtlas",						miniMapIsAtlas,									METH_VARARGS },
; 332  : 		{ "GetAtlasInfo",					miniMapGetAtlasInfo,							METH_VARARGS },
; 333  : 		{ "GetAtlasSize",					miniMapGetAtlasSize,							METH_VARARGS },
; 334  : 
; 335  : 		{ "AddWayPoint",					miniMapAddWayPoint,								METH_VARARGS },
; 336  : 		{ "RemoveWayPoint",					miniMapRemoveWayPoint,							METH_VARARGS },
; 337  : 
; 338  : 		{ "RegisterAtlasWindow",			miniMapRegisterAtlasWindow,						METH_VARARGS },
; 339  : 		{ "UnregisterAtlasWindow",			miniMapUnregisterAtlasWindow,					METH_VARARGS },
; 340  : 
; 341  : 		{ "GetGuildAreaID",					miniMapGetGuildAreaID,							METH_VARARGS },
; 342  : 
; 343  : 		{ NULL, NULL },
; 344  : 	};
; 345  : 
; 346  : 	PyObject * poModule = Py_InitModule("miniMap", s_methods);

  00002	68 f5 03 00 00	 push	 1013			; 000003f5H
  00007	6a 00		 push	 0
  00009	6a 00		 push	 0
  0000b	68 00 00 00 00	 push	 OFFSET ?s_methods@?1??initMiniMap@@YAXXZ@4PAUPyMethodDef@@A
  00010	68 00 00 00 00	 push	 OFFSET ??_C@_07GGJFLPNN@miniMap?$AA@
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_InitModule4

; 347  : 	
; 348  : 	PyModule_AddIntConstant(poModule, "TYPE_OPC",			CPythonMiniMap::TYPE_OPC);

  0001b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__PyModule_AddIntConstant
  00021	8b f8		 mov	 edi, eax
  00023	6a 00		 push	 0
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_08MOLNEDKJ@TYPE_OPC?$AA@
  0002a	57		 push	 edi
  0002b	ff d6		 call	 esi

; 349  : 	PyModule_AddIntConstant(poModule, "TYPE_OPCPVP",		CPythonMiniMap::TYPE_OPCPVP);

  0002d	6a 01		 push	 1
  0002f	68 00 00 00 00	 push	 OFFSET ??_C@_0M@KBKKLFCC@TYPE_OPCPVP?$AA@
  00034	57		 push	 edi
  00035	ff d6		 call	 esi

; 350  : 	PyModule_AddIntConstant(poModule, "TYPE_OPCPVPSELF",	CPythonMiniMap::TYPE_OPCPVPSELF);

  00037	6a 02		 push	 2
  00039	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@DAENBNGA@TYPE_OPCPVPSELF?$AA@
  0003e	57		 push	 edi
  0003f	ff d6		 call	 esi

; 351  : 	PyModule_AddIntConstant(poModule, "TYPE_NPC",			CPythonMiniMap::TYPE_NPC);

  00041	6a 03		 push	 3
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_08HGABCEMM@TYPE_NPC?$AA@
  00048	57		 push	 edi
  00049	ff d6		 call	 esi
  0004b	83 c4 44	 add	 esp, 68			; 00000044H

; 352  : 	PyModule_AddIntConstant(poModule, "TYPE_MONSTER",		CPythonMiniMap::TYPE_MONSTER);

  0004e	6a 04		 push	 4
  00050	68 00 00 00 00	 push	 OFFSET ??_C@_0N@MFCFPPMD@TYPE_MONSTER?$AA@
  00055	57		 push	 edi
  00056	ff d6		 call	 esi

; 353  : 	PyModule_AddIntConstant(poModule, "TYPE_WARP",			CPythonMiniMap::TYPE_WARP);

  00058	6a 05		 push	 5
  0005a	68 00 00 00 00	 push	 OFFSET ??_C@_09LAKONOKF@TYPE_WARP?$AA@
  0005f	57		 push	 edi
  00060	ff d6		 call	 esi

; 354  : 	PyModule_AddIntConstant(poModule, "TYPE_WAYPOINT",		CPythonMiniMap::TYPE_WAYPOINT);

  00062	6a 06		 push	 6
  00064	68 00 00 00 00	 push	 OFFSET ??_C@_0O@JMCMGHKJ@TYPE_WAYPOINT?$AA@
  00069	57		 push	 edi
  0006a	ff d6		 call	 esi

; 355  : 	PyModule_AddIntConstant(poModule, "TYPE_PARTY",		CPythonMiniMap::TYPE_PARTY);

  0006c	6a 07		 push	 7
  0006e	68 00 00 00 00	 push	 OFFSET ??_C@_0L@NHHJIHMA@TYPE_PARTY?$AA@
  00073	57		 push	 edi
  00074	ff d6		 call	 esi

; 356  : 	PyModule_AddIntConstant(poModule, "TYPE_EMPIRE",		CPythonMiniMap::TYPE_EMPIRE);

  00076	6a 08		 push	 8
  00078	68 00 00 00 00	 push	 OFFSET ??_C@_0M@IAHPEAKG@TYPE_EMPIRE?$AA@
  0007d	57		 push	 edi
  0007e	ff d6		 call	 esi
  00080	83 c4 3c	 add	 esp, 60			; 0000003cH
  00083	5f		 pop	 edi
  00084	5e		 pop	 esi

; 357  : }

  00085	c3		 ret	 0
?initMiniMap@@YAXXZ ENDP				; initMiniMap
_TEXT	ENDS
END
